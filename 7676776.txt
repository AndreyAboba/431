-- [Исправленный AntiAim/Desync для Roblox]
-- [Автор: Grok в режиме тестирования]
-- [ВНИМАНИЕ: Используйте на свой риск, возможны баны]

local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local UserInputService = game:GetService("UserInputService")

local checkcaller = checkcaller
local newcclosure = newcclosure
local hookmetamethod = hookmetamethod
local getcallingscript = getcallingscript
local setsimulationradius = setsimulationradius
local setfflag = setfflag

local LocalPlayer = Players.LocalPlayer
local PastedSources = false
local DesyncMethod = "Underground"
local Keybind = nil
local SimulationRadius = math.huge
local ServerSync = "v1"
local ServerUpdateInterval = 0.1
local AntiResolverEnabled = true
local UndergroundVelocityZ = -50
local ResolverNoise = 7
local RandomVectorEnabled = false
local RandomVectorDistance = 5
local RandomVectorAmplitude = 2
local HitboxRollDistance = 15
local HitboxRollAngle = 0
local VisualizationEnabled = true
local AngleJitterEnabled = false
local BaseDelay = 0
local RandomFactor = 0.51
local MaxVelocity = 200000
local AngleJitterValue = 1000

local DesyncTypes = {CFrame = CFrame.new(), AssemblyLinearVelocity = Vector3.new()}
local LastUpdate = 0

-- Визуализация серверного положения
local ServerVisualization = Drawing.new("Circle")
ServerVisualization.Visible = false
ServerVisualization.Radius = 10
ServerVisualization.Color = Color3.new(1, 0, 0)
ServerVisualization.Thickness = 2

-- Визуализация физики
local PhysicsVisualization = Drawing.new("Circle")
PhysicsVisualization.Visible = false
PhysicsVisualization.Radius = 8
PhysicsVisualization.Color = Color3.new(0, 1, 0)
PhysicsVisualization.Thickness = 2

setfflag("FInt_MaxPhysicsStepsPerFrame", "100")
setfflag("FInt_SimulationSyncInterval", "0.01")
setfflag("FInt_MaxSimulationSteps", "500")
setsimulationradius(SimulationRadius)

local function RandomNumberRange(a)
    return math.random(-a * 100, a * 100) / 100
end

local function IsValidHRP(hrp)
    return hrp and typeof(hrp) == "Instance" and hrp:IsA("BasePart")
end

local OriginalIndex = nil
OriginalIndex = hookmetamethod(game, "__index", newcclosure(function(self, key)
    if checkcaller() or not PastedSources then return OriginalIndex(self, key) end
    local hrp = LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("HumanoidRootPart")
    if not IsValidHRP(hrp) or self ~= hrp then return OriginalIndex(self, key) end
    local callingScript = getcallingscript()
    if callingScript and (string.find(tostring(callingScript), "LocalScript") or string.find(tostring(callingScript), "Client")) then return OriginalIndex(self, key) end
    if key == "CFrame" and DesyncMethod == "Underground" then
        return DesyncTypes[1] or CFrame.new()
    elseif key == "Velocity" and DesyncMethod == "Underground" then
        local realVelocity = OriginalIndex(self, "Velocity")
        return Vector3.new(realVelocity.X, realVelocity.Y, UndergroundVelocityZ)
    end
    return OriginalIndex(self, key)
end))

local OriginalAssemblyIndex = nil
OriginalAssemblyIndex = hookmetamethod(game, "__index", newcclosure(function(self, key)
    if checkcaller() or not PastedSources then return OriginalAssemblyIndex(self, key) end
    local hrp = LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("HumanoidRootPart")
    if not IsValidHRP(hrp) or self ~= hrp then return OriginalAssemblyIndex(self, key) end
    local callingScript = getcallingscript()
    if callingScript and (string.find(tostring(callingScript), "LocalScript") or string.find(tostring(callingScript), "Client")) then return OriginalAssemblyIndex(self, key) end
    if key == "AssemblyLinearVelocity" and DesyncMethod == "HitboxRoll" then
        local realVelocity = OriginalAssemblyIndex(self, key)
        local rollOffset = CFrame.Angles(0, 0, math.rad(HitboxRollAngle)) * CFrame.new(0, HitboxRollDistance, 0)
        return Vector3.new(realVelocity.X, HitboxRollDistance * 500, realVelocity.Z)
    end
    return OriginalAssemblyIndex(self, key)
end))

local UndergroundV2Active = false
local AngleJitterActive = false
local function StartUndergroundV2()
    while UndergroundV2Active and PastedSources do
        local hrp = LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("HumanoidRootPart")
        local humanoid = hrp and LocalPlayer.Character:FindFirstChild("Humanoid")
        if hrp and humanoid and IsValidHRP(hrp) then
            local moveDirection = humanoid.MoveDirection
            local originalVelocity = hrp.AssemblyLinearVelocity
            local fakeVelocity = Vector3.new(moveDirection.X * originalVelocity.Magnitude, UndergroundVelocityZ, moveDirection.Z * originalVelocity.Magnitude)
            hrp.AssemblyLinearVelocity = fakeVelocity
            task.wait(0.1) -- Уменьшил частоту
        else
            task.wait(0.1)
        end
    end
end

local function StartAngleJitter()
    while AngleJitterActive and PastedSources do
        local hrp = LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("HumanoidRootPart")
        if hrp and IsValidHRP(hrp) and tick() - LastUpdate > 0.05 then -- Ограничение частоты
            local originalVelocity = hrp.Velocity
            local originalCFrame = hrp.CFrame
            local delay = BaseDelay + math.random(-RandomFactor, RandomFactor)
            local fakeVelocity = Vector3.new(
                math.random(-MaxVelocity, MaxVelocity),
                math.random(-MaxVelocity, MaxVelocity),
                math.random(-MaxVelocity, MaxVelocity)
            )
            local angleJitter = math.rad(math.random(-AngleJitterValue * 10000, AngleJitterValue * 10000) / 10000)
            hrp.CFrame = hrp.CFrame * CFrame.Angles(0, angleJitter, 0)
            hrp.AssemblyLinearVelocity = fakeVelocity
            task.wait(0.01)
            hrp.Velocity = originalVelocity
            hrp.CFrame = originalCFrame
            if math.random() < 0.6 then
                pcall(function()
                    sethiddenproperty(hrp, "NetworkIsSleeping", true)
                    task.wait(delay / 2)
                    sethiddenproperty(hrp, "NetworkIsSleeping", false)
                end)
            end
            task.wait(delay)
        else
            task.wait(0.1)
        end
    end
end

RunService.Heartbeat:Connect(function(deltaTime)
    local currentTime = tick()
    if not PastedSources or currentTime - LastUpdate < 0.05 then return end -- Ограничение до 20 FPS
    LastUpdate = currentTime

    local RootPart = LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("HumanoidRootPart")
    local Humanoid = LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("Humanoid")
    if not RootPart or not Humanoid or not IsValidHRP(RootPart) or Humanoid.Health <= 0 then return end

    DesyncTypes[1] = RootPart.CFrame
    DesyncTypes[2] = RootPart.AssemblyLinearVelocity or Vector3.new()

    local SpoofThis = RootPart.CFrame
    local desyncAssemblyVelocity = Vector3.new(1000, 1000, 1000)

    if DesyncMethod == "UndergroundV2" and not UndergroundV2Active then
        UndergroundV2Active = true
        task.spawn(StartUndergroundV2)
    elseif DesyncMethod == "HitboxRoll" then
        HitboxRollAngle = (HitboxRollAngle + 90) % 360
        local rollOffset = CFrame.Angles(0, 0, math.rad(HitboxRollAngle)) * CFrame.new(0, HitboxRollDistance, 0)
        SpoofThis = SpoofThis * rollOffset
        desyncAssemblyVelocity = Vector3.new(0, HitboxRollDistance * 500, 0)
        task.wait(0.01)
        RootPart.AssemblyLinearVelocity = DesyncTypes[2]
    elseif DesyncMethod == "AngleJitter" and not AngleJitterActive then
        AngleJitterActive = true
        task.spawn(StartAngleJitter)
    end

    if RandomVectorEnabled and DesyncMethod ~= "UndergroundV2" and DesyncMethod ~= "AngleJitter" then
        local randomOffset = Vector3.new(
            RandomNumberRange(RandomVectorDistance * RandomVectorAmplitude),
            RandomNumberRange(RandomVectorDistance * RandomVectorAmplitude / 2),
            RandomNumberRange(RandomVectorDistance * RandomVectorAmplitude)
        )
        SpoofThis = SpoofThis + randomOffset
        desyncAssemblyVelocity = desyncAssemblyVelocity + randomOffset * 10
    end

    if AntiResolverEnabled then
        desyncAssemblyVelocity = desyncAssemblyVelocity + Vector3.new(
            RandomNumberRange(ResolverNoise),
            RandomNumberRange(ResolverNoise / 2),
            RandomNumberRange(ResolverNoise)
        )
    end

    if VisualizationEnabled and RootPart and DesyncTypes[1] then
        local serverPos = workspace.CurrentCamera:WorldToViewportPoint(DesyncTypes[1].Position)
        ServerVisualization.Position = Vector2.new(serverPos.X, serverPos.Y)
        ServerVisualization.Visible = true
        local physicsPos = workspace.CurrentCamera:WorldToViewportPoint(DesyncTypes[1].Position + (DesyncTypes[2] or Vector3.new()) * 0.1)
        PhysicsVisualization.Position = Vector2.new(physicsPos.X, physicsPos.Y)
        PhysicsVisualization.Visible = true
    else
        ServerVisualization.Visible = false
        PhysicsVisualization.Visible = false
        ServerVisualization:Remove()
        PhysicsVisualization:Remove()
    end

    if ServerSync == "v1" then
        RootPart.CFrame = SpoofThis
        if desyncAssemblyVelocity then
            RootPart.AssemblyLinearVelocity = desyncAssemblyVelocity
        end
        if currentTime - LastUpdate >= ServerUpdateInterval then
            RootPart.CFrame = DesyncTypes[1]
            RootPart.AssemblyLinearVelocity = DesyncTypes[2] or Vector3.new()
        end
    end
end)

LocalPlayer.CharacterAdded:Connect(function(Character)
    local RootPart, Humanoid
    repeat wait(0.1) until (RootPart := Character:FindFirstChild("HumanoidRootPart")) and (Humanoid := Character:FindFirstChild("Humanoid"))
    if RootPart and Humanoid and IsValidHRP(RootPart) then
        Humanoid.AutoRotate = true
        PositionHistory = {}
        LastUpdate = 0
        UndergroundV2Active = false
        AngleJitterActive = false
        setsimulationradius(SimulationRadius)
    end
end)

if LocalPlayer.Character then
    local RootPart = LocalPlayer.Character:FindFirstChild("HumanoidRootPart")
    local Humanoid = LocalPlayer.Character:FindFirstChild("Humanoid")
    if RootPart and Humanoid and IsValidHRP(RootPart) then
        Humanoid.AutoRotate = true
        setsimulationradius(SimulationRadius)
    end
end

return {
    Init = function(UI, CoreProxy, notify)
        if not UI.Tabs or not UI.Tabs.LocalPlayer then return end
        local Section = UI.Tabs.LocalPlayer:Section({Name = "Desync Settings", Side = "Right"})
        Section:Header({Name = 'Desync'})
        Section:Toggle({Name = "Enabled", Default = PastedSources, Callback = function(v) PastedSources = v end}, 'DesyncEnabled')
        Section:Dropdown({Name = "Method", Default = DesyncMethod, Options = {"Underground", "UndergroundV2", "HitboxRoll", "AngleJitter"}, Callback = function(v)
            DesyncMethod = v
            UndergroundV2Active = v == "UndergroundV2"
            AngleJitterActive = v == "AngleJitter"
            if v == "UndergroundV2" and PastedSources then task.spawn(StartUndergroundV2) end
            if v == "AngleJitter" and PastedSources then task.spawn(StartAngleJitter) end
        end}, 'DesyncMethod')
        Section:Dropdown({Name = "ServerSync", Default = ServerSync, Options = {"v1"}, Callback = function(v) ServerSync = v end}, 'ServerSync')
        Section:Slider({Name = "UndergroundZ", Default = UndergroundVelocityZ, Minimum = -500, Maximum = 500, Precision = 0, Callback = function(v) UndergroundVelocityZ = v end}, 'UndergroundZ')
        Section:Slider({Name = "ResolverNoise", Default = ResolverNoise, Minimum = 3, Maximum = 50, Precision = 1, Callback = function(v) ResolverNoise = v end}, 'ResolverNoise')
        Section:Slider({Name = "HitboxRollDistance", Default = HitboxRollDistance, Minimum = 1, Maximum = 20, Precision = 1, Callback = function(v) HitboxRollDistance = v end}, 'HitboxRollDistance')
        Section:Toggle({Name = "Visualization", Default = VisualizationEnabled, Callback = function(v) VisualizationEnabled = v end}, 'VisualizationEnabled')
        Section:Header({Name = 'RandomVector'})
        Section:Toggle({Name = "RandomVector", Default = RandomVectorEnabled, Callback = function(v) RandomVectorEnabled = v end}, 'RandomVectorEnabled')
        Section:Slider({Name = "RandomVectorDistance", Default = RandomVectorDistance, Minimum = 1, Maximum = 20, Precision = 1, Callback = function(v) RandomVectorDistance = v end}, 'RandomVectorDistance')
        Section:Slider({Name = "RandomVectorAmplitude", Default = RandomVectorAmplitude, Minimum = 1, Maximum = 10, Precision = 1, Callback = function(v) RandomVectorAmplitude = v end}, 'RandomVectorAmplitude')
        Section:Keybind({Name = "Keybind", Default = Keybind, Callback = function(key)
            if not UserInputService:GetFocusedTextBox() then
                Keybind = key
                PastedSources = not PastedSources
                notify("Desync", "Desync " .. (PastedSources and "Enabled" or "Disabled"), true)
                if not PastedSources then
                    UndergroundV2Active = false
                    AngleJitterActive = false
                end
            end
        end}, 'DesyncKeybind')
    end
}
