local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local UserInputService = game:GetService("UserInputService")

local checkcaller = checkcaller
local newcclosure = newcclosure
local hookmetamethod = hookmetamethod
local getcallingscript = getcallingscript
local setsimulationradius = setsimulationradius

local LocalPlayer = Players.LocalPlayer
local Mouse = LocalPlayer:GetMouse()
local PastedSources = false
local DesyncMethod = "FakeRotation"
local Keybind = nil
local LastHitboxRoll = 0
local LastServerUpdate = 0
local SimulationRadius = math.huge
local ServerSync = true
local ServerUpdateInterval = 0.1
local AntiResolverEnabled = true
local UndergroundVelocityY = -50
local BacktrackDelay = 3
local HitboxRollDistance = 300
local HitboxRollInterval = 0.0012
local HitboxReturnSpeed = 25
local FakeRotationSpeed = 300
local ResolverNoise = 7
local RandomVectorEnabled = false
local RandomVectorSpeed = 10
local RandomVectorDistance = 5
local LagSimulationDelay = 0.05

local DesyncTypes = {CFrame = CFrame.new(), AssemblyLinearVelocity = Vector3.new()}
local PositionHistory = {}

-- Установка радиуса симуляции
setsimulationradius(SimulationRadius)

-- Toggles
Mouse.KeyDown:Connect(function(key)
    if key == string.lower("b") then
        PastedSources = not PastedSources
    end
end)

local function RandomNumberRange(a)
    return math.random(-a * 100, a * 100) / 100
end

local function InterpolateCFrame(cframe1, cframe2, t)
    local pos1 = cframe1.Position
    local pos2 = cframe2.Position
    local interpolatedPos = pos1:Lerp(pos2, t)
    local rot1 = cframe1 - cframe1.Position
    local rot2 = cframe2 - cframe2.Position
    local interpolatedRot = rot1:Lerp(rot2, t)
    return CFrame.new(interpolatedPos) * interpolatedRot
end

local function GetFakeRotationCFrame(currentCFrame, deltaTime)
    local rotationAngle = tick() * FakeRotationSpeed
    return currentCFrame * CFrame.Angles(
        math.rad(math.sin(rotationAngle) * 180),
        math.rad(math.cos(rotationAngle) * 180),
        math.rad(math.sin(rotationAngle * 0.5) * 180)
    )
end

RunService.Heartbeat:Connect(function(deltaTime)
    if PastedSources then
        local RootPart = LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("HumanoidRootPart")
        local Humanoid = LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("Humanoid")
        if not RootPart or not Humanoid or Humanoid.Health <= 0 then return end

        local currentTime = tick()
        table.insert(PositionHistory, {Time = currentTime, CFrame = RootPart.CFrame})

        DesyncTypes[1] = RootPart.CFrame
        DesyncTypes[2] = RootPart.AssemblyLinearVelocity or Vector3.new()

        local SpoofThis = RootPart.CFrame
        local desyncAssemblyVelocity = DesyncTypes[2]

        if DesyncMethod == "Underground" then
            desyncAssemblyVelocity = Vector3.new(DesyncTypes[2].X, UndergroundVelocityY, DesyncTypes[2].Z)
        elseif DesyncMethod == "UndergroundV2" then
            desyncAssemblyVelocity = Vector3.new(
                DesyncTypes[2].X + RandomNumberRange(5),
                UndergroundVelocityY,
                DesyncTypes[2].Z + RandomNumberRange(5)
            )
            RootPart.Velocity = desyncAssemblyVelocity * RandomVectorSpeed
        elseif DesyncMethod == "Backtrack" then
            local targetTime = currentTime - BacktrackDelay
            if #PositionHistory > 1 then
                local closestBefore, closestAfter
                for i = 1, #PositionHistory do
                    local entry = PositionHistory[i]
                    if entry.Time <= targetTime then
                        closestBefore = entry
                    elseif entry.Time > targetTime then
                        closestAfter = entry
                        break
                    end
                end
                if closestBefore and closestAfter then
                    local timeDiff = closestAfter.Time - closestBefore.Time
                    local t = (targetTime - closestBefore.Time) / timeDiff
                    SpoofThis = InterpolateCFrame(closestBefore.CFrame, closestAfter.CFrame, t)
                elseif closestBefore then
                    SpoofThis = closestBefore.CFrame
                end
            end
        elseif DesyncMethod == "HitboxRoll" then
            if currentTime - LastHitboxRoll >= HitboxRollInterval then
                desyncAssemblyVelocity = Vector3.new(
                    RandomNumberRange(HitboxRollDistance),
                    RandomNumberRange(HitboxRollDistance / 2),
                    RandomNumberRange(HitboxRollDistance)
                ) * 10
                SpoofThis = RootPart.CFrame + desyncAssemblyVelocity.Unit * HitboxRollDistance
                LastHitboxRoll = currentTime
            else
                local distanceToReturn = (DesyncTypes[1].Position - SpoofThis.Position).Magnitude
                if distanceToReturn > 1 then
                    local returnVector = (DesyncTypes[1].Position - SpoofThis.Position).Unit * math.min(HitboxReturnSpeed * deltaTime, distanceToReturn)
                    SpoofThis = SpoofThis + returnVector
                end
            end
        elseif DesyncMethod == "FakeRotation" then
            SpoofThis = GetFakeRotationCFrame(RootPart.CFrame, deltaTime)
            desyncAssemblyVelocity = desyncAssemblyVelocity + Vector3.new(RandomNumberRange(ResolverNoise / 2), 0, RandomNumberRange(ResolverNoise / 2))
        elseif DesyncMethod == "RandomJitter" then
            local jitterOffset = Vector3.new(
                RandomNumberRange(RandomVectorDistance),
                RandomNumberRange(RandomVectorDistance / 2),
                RandomNumberRange(RandomVectorDistance)
            )
            SpoofThis = RootPart.CFrame + jitterOffset
            desyncAssemblyVelocity = desyncAssemblyVelocity + jitterOffset * RandomVectorSpeed
        elseif DesyncMethod == "LagSimulation" then
            if currentTime - LastServerUpdate >= LagSimulationDelay then
                SpoofThis = RootPart.CFrame + Vector3.new(RandomNumberRange(10), RandomNumberRange(5), RandomNumberRange(10))
                LastServerUpdate = currentTime
            end
        end

        if RandomVectorEnabled and DesyncMethod ~= "UndergroundV2" then
            local randomOffset = Vector3.new(
                RandomNumberRange(RandomVectorDistance),
                RandomNumberRange(RandomVectorDistance / 2),
                RandomNumberRange(RandomVectorDistance)
            )
            SpoofThis = SpoofThis + randomOffset
            desyncAssemblyVelocity = desyncAssemblyVelocity + randomOffset * RandomVectorSpeed
        end

        if AntiResolverEnabled then
            desyncAssemblyVelocity = desyncAssemblyVelocity + Vector3.new(
                RandomNumberRange(ResolverNoise),
                RandomNumberRange(ResolverNoise / 2),
                RandomNumberRange(ResolverNoise)
            )
        end

        SpoofThis = SpoofThis * CFrame.Angles(
            math.rad(RandomNumberRange(180)),
            math.rad(RandomNumberRange(360)),
            math.rad(RandomNumberRange(180))
        )

        if ServerSync == "proxy" then
            local callingScript = getcallingscript()
            if callingScript and not string.find(tostring(callingScript), "Server") and not string.find(tostring(callingScript), "Network") then
                RootPart.CFrame = SpoofThis
                if desyncAssemblyVelocity then
                    RootPart.AssemblyLinearVelocity = desyncAssemblyVelocity
                end
            end
        elseif ServerSync == "v1" then
            RootPart.CFrame = SpoofThis
            if desyncAssemblyVelocity then
                RootPart.AssemblyLinearVelocity = desyncAssemblyVelocity
            end
            if tick() - LastServerUpdate >= ServerUpdateInterval then
                RootPart.CFrame = DesyncTypes[1]
                RootPart.AssemblyLinearVelocity = DesyncTypes[2] or Vector3.new()
                LastServerUpdate = tick()
            end
        end

        RunService.RenderStepped:Wait()
        RootPart.CFrame = DesyncTypes[1]
        RootPart.AssemblyLinearVelocity = DesyncTypes[2] or Vector3.new()
    end
end)

local XDDDDDD = nil
XDDDDDD = hookmetamethod(game, "__index", newcclosure(function(self, key)
    if PastedSources and not checkcaller() then
        if key == "CFrame" and LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("HumanoidRootPart") and LocalPlayer.Character:FindFirstChild("Humanoid") and LocalPlayer.Character.Humanoid.Health > 0 then
            if ServerSync == "proxy" then
                local callingScript = getcallingscript()
                if callingScript and not string.find(tostring(callingScript), "Server") and not string.find(tostring(callingScript), "Network") then
                    if self == LocalPlayer.Character.HumanoidRootPart then
                        return DesyncTypes[1] or CFrame.new()
                    elseif self == LocalPlayer.Character.Head then
                        return DesyncTypes[1] and DesyncTypes[1] + Vector3.new(0, LocalPlayer.Character.HumanoidRootPart.Size.Y / 2 + 0.5, 0) or CFrame.new()
                    end
                end
            elseif ServerSync == "v1" then
                if self == LocalPlayer.Character.HumanoidRootPart then
                    return DesyncTypes[1] or CFrame.new()
                elseif self == LocalPlayer.Character.Head then
                    return DesyncTypes[1] and DesyncTypes[1] + Vector3.new(0, LocalPlayer.Character.HumanoidRootPart.Size.Y / 2 + 0.5, 0) or CFrame.new()
                end
            end
        end
    end
    return XDDDDDD(self, key)
end))

LocalPlayer.CharacterAdded:Connect(function(Character)
    local RootPart, Humanoid
    repeat
        RootPart = Character:FindFirstChild("HumanoidRootPart")
        Humanoid = Character:FindFirstChild("Humanoid")
        wait(0.1)
    until RootPart and Humanoid
    Humanoid.AutoRotate = true
    PositionHistory = {}
    LastServerUpdate = 0
    LastHitboxRoll = 0
    setsimulationradius(SimulationRadius)
end)

if LocalPlayer.Character then
    local RootPart = LocalPlayer.Character:FindFirstChild("HumanoidRootPart")
    local Humanoid = LocalPlayer.Character:FindFirstChild("Humanoid")
    if RootPart and Humanoid then
        Humanoid.AutoRotate = true
        setsimulationradius(SimulationRadius)
    end
end

return {
    Init = function(UI, CoreProxy, notify)
        if not UI.Tabs or not UI.Tabs.LocalPlayer then
            warn("LocalPlayer tab not found in UI.Tabs")
            return
        end

        local Section = UI.Tabs.LocalPlayer:Section({ Name = "Desync Settings", Side = "Right" })

        Section:Header({ Name = 'Desync' })

        Section:Toggle({
            Name = "Enabled",
            Default = PastedSources,
            Callback = function(value)
                PastedSources = value
                notify("Desync", "Desync " .. (value and "Enabled" or "Disabled"), true)
            end
        }, 'DesyncEnabled')

        Section:Dropdown({
            Name = "Method",
            Default = DesyncMethod,
            Options = {"Underground", "UndergroundV2", "Backtrack", "HitboxRoll", "FakeRotation", "RandomJitter", "LagSimulation"},
            Callback = function(value)
                DesyncMethod = value
            end
        }, 'DesyncMethod')

        Section:Dropdown({
            Name = "ServerSync",
            Default = ServerSync,
            Options = {"v1", "proxy"},
            Callback = function(value)
                ServerSync = value
            end
        }, 'ServerSync')

        Section:Toggle({
            Name = "RandomVector",
            Default = RandomVectorEnabled,
            Callback = function(value)
                RandomVectorEnabled = value
            end
        }, 'RandomVectorEnabled')

        Section:Slider({
            Name = "HitboxRollDistance",
            Default = HitboxRollDistance,
            Minimum = 10,
            Maximum = 350,
            Precision = 0,
            Callback = function(value)
                HitboxRollDistance = value
            end
        }, 'HitboxRollDistance')

        Section:Slider({
            Name = "HitboxRollInterval",
            Default = HitboxRollInterval,
            Minimum = 0.001,
            Maximum = 0.5,
            Precision = 4,
            Callback = function(value)
                HitboxRollInterval = value
            end
        }, 'HitboxRollInterval')

        Section:Slider({
            Name = "HitboxReturnSpeed",
            Default = HitboxReturnSpeed,
            Minimum = 1,
            Maximum = 200,
            Precision = 0,
            Callback = function(value)
                HitboxReturnSpeed = value
            end
        }, 'HitboxReturnSpeed')

        Section:Slider({
            Name = "FakeRotationSpeed",
            Default = FakeRotationSpeed,
            Minimum = 10000,
            Maximum = 100000,
            Precision = 0,
            Callback = function(value)
                FakeRotationSpeed = value
            end
        }, 'FakeRotationSpeed')

        Section:Slider({
            Name = "BacktrackDelay",
            Default = BacktrackDelay,
            Minimum = 0.5,
            Maximum = 10,
            Precision = 2,
            Callback = function(value)
                BacktrackDelay = value
            end
        }, 'BacktrackDelay')

        Section:Slider({
            Name = "VelocityY",
            Default = UndergroundVelocityY,
            Minimum = -500,
            Maximum = 500,
            Precision = 0,
            Callback = function(value)
                UndergroundVelocityY = value
            end
        }, 'UndergroundVelocityY')

        Section:Slider({
            Name = "ResolverNoise",
            Default = ResolverNoise,
            Minimum = 3,
            Maximum = 50,
            Precision = 1,
            Callback = function(value)
                ResolverNoise = value
            end
        }, 'ResolverNoise')

        Section:Slider({
            Name = "RandomVectorDistance",
            Default = RandomVectorDistance,
            Minimum = 1,
            Maximum = 5,
            Precision = 1,
            Callback = function(value)
                RandomVectorDistance = value
            end
        }, 'RandomVectorDistance')

        Section:Slider({
            Name = "RandomVectorSpeed",
            Default = RandomVectorSpeed,
            Minimum = 5,
            Maximum = 500,
            Precision = 0,
            Callback = function(value)
                RandomVectorSpeed = value
            end
        }, 'RandomVectorSpeed')

        Section:Slider({
            Name = "LagSimulationDelay",
            Default = LagSimulationDelay,
            Minimum = 0.01,
            Maximum = 0.5,
            Precision = 2,
            Callback = function(value)
                LagSimulationDelay = value
            end
        }, 'LagSimulationDelay')

        Section:Keybind({
            Name = "Keybind",
            Default = Keybind,
            Callback = function(key)
                if not UserInputService:GetFocusedTextBox() then
                    Keybind = key
                    PastedSources = not PastedSources
                    notify("Desync", "Desync " .. (PastedSources and "Enabled" or "Disabled"), true)
                end
            end
        }, 'DesyncKeybind')
    end
}
