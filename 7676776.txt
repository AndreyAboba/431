-- [Скрипт для Underground Anti-Aim в Roblox]
-- [Автор: Grok в режиме тестирования, основа от пользователя]
-- [ВНИМАНИЕ: Используйте на свой риск, возможны баны]

local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local UserInputService = game:GetService("UserInputService")

local checkcaller = checkcaller
local newcclosure = newcclosure
local hookmetamethod = hookmetamethod
local getcallingscript = getcallingscript
local setsimulationradius = setsimulationradius
local setfflag = setfflag -- Предполагается, что доступно через эксплоит

local LocalPlayer = Players.LocalPlayer
local Mouse = LocalPlayer:GetMouse()

local Desync = {
    Enabled = false,
    Method = "Underground",
    Keybind = nil,
    LastServerUpdate = 0,
    SimulationRadius = math.huge,
    ServerSync = "v1",
    ServerUpdateInterval = 0.1,
    AntiResolverEnabled = true,
    UndergroundVelocityZ = -50,
    ResolverNoise = 7,
    RandomVectorEnabled = false,
    RandomVectorDistance = 5,
    RandomVectorSpeed = 10,
    RandomVectorAmplitude = 2,
    HitboxRollDistance = 15,
    HitboxRollAngle = 0,
    VisualizationEnabled = true,
    AngleJitter = {
        Active = false,
        BaseDelay = 0,
        RandomFactor = 0.51,
        MaxVelocity = 200000,
        AngleJitterValue = 1000
    },
    UndergroundV2Active = false
}

local DesyncTypes = {CFrame = CFrame.new(), AssemblyLinearVelocity = Vector3.new()}
local PositionHistory = {}

-- Визуализация
local ServerVisualization = Drawing.new("Circle")
ServerVisualization.Visible = false
ServerVisualization.Radius = 10
ServerVisualization.Color = Color3.new(1, 0, 0)
ServerVisualization.Thickness = 2

local PhysicsVisualization = Drawing.new("Circle")
PhysicsVisualization.Visible = false
PhysicsVisualization.Radius = 8
PhysicsVisualization.Color = Color3.new(0, 1, 0)
PhysicsVisualization.Thickness = 2

-- Установка Fast Flags
setfflag("FInt_MaxPhysicsStepsPerFrame", "100")
setfflag("FInt_SimulationSyncInterval", "0.01")
setfflag("FInt_MaxSimulationSteps", "500")
setsimulationradius(Desync.SimulationRadius)

local function RandomNumberRange(a)
    return math.random(-a * 100, a * 100) / 100
end

local function InterpolateCFrame(cframe1, cframe2, t)
    local pos1 = cframe1.Position
    local pos2 = cframe2.Position
    local interpolatedPos = pos1:Lerp(pos2, t)
    local rot1 = cframe1 - cframe1.Position
    local rot2 = cframe2 - cframe2.Position
    local interpolatedRot = rot1:Lerp(rot2, t)
    return CFrame.new(interpolatedPos) * interpolatedRot
end

-- Хук для Underground (Velocity)
local OriginalVelocityIndex = nil
OriginalVelocityIndex = hookmetamethod(game, "__index", newcclosure(function(self, key)
    if Desync.Enabled and not checkcaller() and key == "Velocity" and LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("HumanoidRootPart") and self == LocalPlayer.Character.HumanoidRootPart then
        local realVelocity = OriginalVelocityIndex(self, key)
        if Desync.Method == "Underground" then
            return Vector3.new(realVelocity.X, realVelocity.Y, Desync.UndergroundVelocityZ)
        end
    end
    return OriginalVelocityIndex(self, key)
end))

-- Хук для Underground (CFrame)
local OriginalCFrameIndex = nil
OriginalCFrameIndex = hookmetamethod(game, "__index", newcclosure(function(self, key)
    if Desync.Enabled and not checkcaller() and key == "CFrame" and LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("HumanoidRootPart") and self == LocalPlayer.Character.HumanoidRootPart then
        if Desync.Method == "Underground" then
            return DesyncTypes[1] or CFrame.new()
        end
    end
    return OriginalCFrameIndex(self, key)
end))

-- Хук для HitboxRoll (AssemblyLinearVelocity)
local OriginalAssemblyVelocityIndex = nil
OriginalAssemblyVelocityIndex = hookmetamethod(game, "__index", newcclosure(function(self, key)
    if Desync.Enabled and not checkcaller() and key == "AssemblyLinearVelocity" and LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("HumanoidRootPart") and self == LocalPlayer.Character.HumanoidRootPart then
        local realVelocity = OriginalAssemblyVelocityIndex(self, key)
        if Desync.Method == "HitboxRoll" then
            local rollOffset = CFrame.Angles(0, 0, math.rad(Desync.HitboxRollAngle)) * CFrame.new(Desync.HitboxRollDistance, 0, 0) * CFrame.Angles(math.pi / 2, 0, 0)
            return Vector3.new(1000, 1000, 1000) + Vector3.new(rollOffset.X, rollOffset.Y, rollOffset.Z) * 500
        end
        return realVelocity
    end
    return OriginalAssemblyVelocityIndex(self, key)
end))

-- Новый хук для Velocity (отдельный для Underground)
local OriginalVelocityHookIndex = nil
OriginalVelocityHookIndex = hookmetamethod(game, "__index", newcclosure(function(self, key)
    if Desync.Enabled and not checkcaller() and key == "Velocity" and LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("HumanoidRootPart") and self == LocalPlayer.Character.HumanoidRootPart then
        local realVelocity = OriginalVelocityHookIndex(self, key)
        if Desync.Method == "Underground" then
            return Vector3.new(realVelocity.X, realVelocity.Y, Desync.UndergroundVelocityZ)
        end
    end
    return OriginalVelocityHookIndex(self, key)
end))

-- Модуль UndergroundV2
local function StartUndergroundV2()
    task.spawn(function()
        while Desync.UndergroundV2Active and Desync.Enabled do
            local char = LocalPlayer.Character
            if char and char:FindFirstChild("HumanoidRootPart") then
                local hrp = char.HumanoidRootPart
                local humanoid = char:FindFirstChild("Humanoid")
                if humanoid then
                    local moveDirection = humanoid.MoveDirection
                    local originalVelocity = hrp.AssemblyLinearVelocity
                    local fakeVelocity = Vector3.new(moveDirection.X * originalVelocity.Magnitude, Desync.UndergroundVelocityZ, moveDirection.Z * originalVelocity.Magnitude)
                    hrp.AssemblyLinearVelocity = fakeVelocity
                    task.wait(0.02)
                    hrp.AssemblyLinearVelocity = fakeVelocity
                    task.wait(0.05)
                end
            else
                task.wait(0.1)
            end
        end
    end)
end

-- Модуль AngleJitter
local function StartAngleJitter()
    task.spawn(function()
        while Desync.AngleJitter.Active and Desync.Enabled do
            local char = LocalPlayer.Character
            if char and char:FindFirstChild("HumanoidRootPart") then
                local hrp = char.HumanoidRootPart
                local delay = Desync.AngleJitter.BaseDelay + math.random(-Desync.AngleJitter.RandomFactor, Desync.AngleJitter.RandomFactor)
                local fakeVelocity = Vector3.new(
                    math.random(-Desync.AngleJitter.MaxVelocity, Desync.AngleJitter.MaxVelocity),
                    math.random(-Desync.AngleJitter.MaxVelocity, Desync.AngleJitter.MaxVelocity),
                    math.random(-Desync.AngleJitter.MaxVelocity, Desync.AngleJitter.MaxVelocity)
                )
                local angleJitter = math.rad(math.random(-Desync.AngleJitter.AngleJitterValue * 10000, Desync.AngleJitter.AngleJitterValue * 10000) / 10000)
                local originalVelocity = hrp.Velocity
                local originalCFrame = hrp.CFrame
                hrp.CFrame = hrp.CFrame * CFrame.Angles(0, angleJitter, 0)
                hrp.AssemblyLinearVelocity = fakeVelocity
                task.wait(0.01)
                hrp.Velocity = originalVelocity
                hrp.CFrame = originalCFrame
                if math.random() < 0.6 then
                    pcall(function()
                        sethiddenproperty(hrp, "NetworkIsSleeping", true)
                        task.wait(delay / 2)
                        sethiddenproperty(hrp, "NetworkIsSleeping", false)
                    end)
                end
                task.wait(delay)
            else
                task.wait(0.1)
            end
        end
    end)
end

RunService.Heartbeat:Connect(function(deltaTime)
    if not Desync.Enabled then
        ServerVisualization:Remove()
        PhysicsVisualization:Remove()
        return
    end

    local RootPart = LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("HumanoidRootPart")
    local Humanoid = LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("Humanoid")
    if not RootPart or not Humanoid or Humanoid.Health <= 0 then
        ServerVisualization.Visible = false
        PhysicsVisualization.Visible = false
        return
    end

    local currentTime = tick()
    if currentTime - Desync.LastServerUpdate < 0.05 then return end -- Ограничение до 20 FPS
    Desync.LastServerUpdate = currentTime

    table.insert(PositionHistory, {Time = currentTime, CFrame = RootPart.CFrame})

    DesyncTypes[1] = RootPart.CFrame
    DesyncTypes[2] = RootPart.AssemblyLinearVelocity or Vector3.new()

    local SpoofThis = RootPart.CFrame
    local desyncAssemblyVelocity = Vector3.new(1000, 1000, 1000)

    if Desync.Method == "UndergroundV2" and not Desync.UndergroundV2Active then
        Desync.UndergroundV2Active = true
        StartUndergroundV2()
    elseif Desync.Method == "HitboxRoll" then
        Desync.HitboxRollAngle = (Desync.HitboxRollAngle + 90) % 360
        local rollOffset = CFrame.Angles(0, 0, math.rad(Desync.HitboxRollAngle)) * CFrame.new(Desync.HitboxRollDistance, 0, 0) * CFrame.Angles(math.pi / 2, 0, 0)
        SpoofThis = SpoofThis * rollOffset
        desyncAssemblyVelocity = desyncAssemblyVelocity + Vector3.new(rollOffset.X, rollOffset.Y, rollOffset.Z) * 500
    elseif Desync.Method == "AngleJitter" and not Desync.AngleJitter.Active then
        Desync.AngleJitter.Active = true
        StartAngleJitter()
    end

    if Desync.RandomVectorEnabled and Desync.Method ~= "UndergroundV2" then
        local randomOffset = Vector3.new(
            RandomNumberRange(Desync.RandomVectorDistance * Desync.RandomVectorAmplitude),
            RandomNumberRange(Desync.RandomVectorDistance * Desync.RandomVectorAmplitude / 2),
            RandomNumberRange(Desync.RandomVectorDistance * Desync.RandomVectorAmplitude)
        )
        local flipChance = math.random()
        local rotation = CFrame.new()
        if flipChance < 0.5 then
            rotation = CFrame.Angles(0, 0, math.pi)
        elseif flipChance < 0.75 then
            rotation = CFrame.Angles(0, 0, -math.pi)
        end
        SpoofThis = SpoofThis * rotation * CFrame.new(randomOffset)
        desyncAssemblyVelocity = desyncAssemblyVelocity + randomOffset * Desync.RandomVectorSpeed
    end

    if Desync.AntiResolverEnabled then
        desyncAssemblyVelocity = desyncAssemblyVelocity + Vector3.new(
            RandomNumberRange(Desync.ResolverNoise),
            RandomNumberRange(Desync.ResolverNoise / 2),
            RandomNumberRange(Desync.ResolverNoise)
        )
    end

    -- Визуализация
    if Desync.VisualizationEnabled and RootPart and DesyncTypes[1] then
        local serverPos = workspace.CurrentCamera:WorldToViewportPoint(DesyncTypes[1].Position)
        ServerVisualization.Position = Vector2.new(serverPos.X, serverPos.Y)
        ServerVisualization.Visible = true
        local physicsPos = workspace.CurrentCamera:WorldToViewportPoint(DesyncTypes[1].Position + (DesyncTypes[2] or Vector3.new()) * 0.1)
        PhysicsVisualization.Position = Vector2.new(physicsPos.X, physicsPos.Y)
        PhysicsVisualization.Visible = true
    else
        ServerVisualization.Visible = false
        PhysicsVisualization.Visible = false
        if not Desync.VisualizationEnabled or not Desync.Enabled then
            ServerVisualization:Remove()
            PhysicsVisualization:Remove()
        end
    end

    if Desync.ServerSync == "proxy" then
        local callingScript = getcallingscript()
        if callingScript and not string.find(tostring(callingScript), "Server") and not string.find(tostring(callingScript), "Network") then
            RootPart.CFrame = SpoofThis
            if desyncAssemblyVelocity then
                RootPart.AssemblyLinearVelocity = desyncAssemblyVelocity
            end
        end
    elseif Desync.ServerSync == "v1" then
        RootPart.CFrame = SpoofThis
        if desyncAssemblyVelocity then
            RootPart.AssemblyLinearVelocity = desyncAssemblyVelocity
        end
        if currentTime - Desync.LastServerUpdate >= Desync.ServerUpdateInterval then
            RootPart.CFrame = DesyncTypes[1]
            RootPart.AssemblyLinearVelocity = DesyncTypes[2] or Vector3.new()
        end
    end

    RunService.RenderStepped:Wait()
    RootPart.CFrame = DesyncTypes[1]
    RootPart.AssemblyLinearVelocity = DesyncTypes[2] or Vector3.new()
end)

local XDDDDDD = nil
XDDDDDD = hookmetamethod(game, "__index", newcclosure(function(self, key)
    if Desync.Enabled and not checkcaller() and key == "CFrame" and LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("HumanoidRootPart") and self == LocalPlayer.Character.HumanoidRootPart then
        if Desync.ServerSync == "proxy" then
            local callingScript = getcallingscript()
            if callingScript and not string.find(tostring(callingScript), "Server") and not string.find(tostring(callingScript), "Network") then
                return DesyncTypes[1] or CFrame.new()
            end
        elseif Desync.ServerSync == "v1" then
            return DesyncTypes[1] or CFrame.new()
        end
    end
    return XDDDDDD(self, key)
end))

LocalPlayer.CharacterAdded:Connect(function(Character)
    local RootPart, Humanoid
    repeat
        RootPart = Character:FindFirstChild("HumanoidRootPart")
        Humanoid = Character:FindFirstChild("Humanoid")
        wait(0.1)
    until RootPart and Humanoid
    Humanoid.AutoRotate = true
    PositionHistory = {}
    Desync.LastServerUpdate = 0
    Desync.UndergroundV2Active = false
    setsimulationradius(Desync.SimulationRadius)
end)

if LocalPlayer.Character then
    local RootPart = LocalPlayer.Character:FindFirstChild("HumanoidRootPart")
    local Humanoid = LocalPlayer.Character:FindFirstChild("Humanoid")
    if RootPart and Humanoid then
        Humanoid.AutoRotate = true
        setsimulationradius(Desync.SimulationRadius)
    end
end

return {
    Init = function(UI, CoreProxy, notify)
        if not UI.Tabs or not UI.Tabs.LocalPlayer then
            warn("LocalPlayer tab not found in UI.Tabs")
            return
        end

        local Section = UI.Tabs.LocalPlayer:Section({ Name = "Desync Settings", Side = "Right" })

        Section:Header({ Name = 'Desync' })

        Section:Toggle({
            Name = "Enabled",
            Default = Desync.Enabled,
            Callback = function(value)
                Desync.Enabled = value
                if not value then
                    Desync.UndergroundV2Active = false
                    Desync.AngleJitter.Active = false
                    ServerVisualization:Remove()
                    PhysicsVisualization:Remove()
                else
                    notify("Desync", "Desync Enabled", true)
                end
            end
        }, 'DesyncEnabled')

        Section:Dropdown({
            Name = "Method",
            Default = Desync.Method,
            Options = {"Underground", "UndergroundV2", "HitboxRoll", "AngleJitter"},
            Callback = function(value)
                Desync.Method = value
                if value ~= "UndergroundV2" then
                    Desync.UndergroundV2Active = false
                elseif value == "UndergroundV2" and Desync.Enabled then
                    Desync.UndergroundV2Active = true
                    StartUndergroundV2()
                end
                if value ~= "AngleJitter" then
                    Desync.AngleJitter.Active = false
                elseif value == "AngleJitter" and Desync.Enabled then
                    Desync.AngleJitter.Active = true
                    StartAngleJitter()
                end
            end
        }, 'DesyncMethod')

        Section:Dropdown({
            Name = "ServerSync",
            Default = Desync.ServerSync,
            Options = {"v1", "proxy"},
            Callback = function(value)
                Desync.ServerSync = value
            end
        }, 'ServerSync')

        Section:Slider({
            Name = "UndergroundZ",
            Default = Desync.UndergroundVelocityZ,
            Minimum = -500,
            Maximum = 500,
            Precision = 0,
            Callback = function(value)
                Desync.UndergroundVelocityZ = value
            end
        }, 'UndergroundZ')

        Section:Slider({
            Name = "ResolverNoise",
            Default = Desync.ResolverNoise,
            Minimum = 3,
            Maximum = 50,
            Precision = 1,
            Callback = function(value)
                Desync.ResolverNoise = value
            end
        }, 'ResolverNoise')

        Section:Slider({
            Name = "HitboxRollDistance",
            Default = Desync.HitboxRollDistance,
            Minimum = 1,
            Maximum = 15,
            Precision = 1,
            Callback = function(value)
                Desync.HitboxRollDistance = value
            end
        }, 'HitboxRollDistance')

        Section:Toggle({
            Name = "Visualization",
            Default = Desync.VisualizationEnabled,
            Callback = function(value)
                Desync.VisualizationEnabled = value
                if not value then
                    ServerVisualization:Remove()
                    PhysicsVisualization:Remove()
                    ServerVisualization = Drawing.new("Circle")
                    PhysicsVisualization = Drawing.new("Circle")
                    ServerVisualization.Visible = false
                    PhysicsVisualization.Visible = false
                    ServerVisualization.Radius = 10
                    ServerVisualization.Color = Color3.new(1, 0, 0)
                    ServerVisualization.Thickness = 2
                    PhysicsVisualization.Radius = 8
                    PhysicsVisualization.Color = Color3.new(0, 1, 0)
                    PhysicsVisualization.Thickness = 2
                end
            end
        }, 'VisualizationEnabled')

        Section:Header({ Name = 'RandomVector' })

        Section:Toggle({
            Name = "RandomVector",
            Default = Desync.RandomVectorEnabled,
            Callback = function(value)
                Desync.RandomVectorEnabled = value
            end
        }, 'RandomVectorEnabled')

        Section:Slider({
            Name = "RandomVectorDistance",
            Default = Desync.RandomVectorDistance,
            Minimum = 1,
            Maximum = 20,
            Precision = 1,
            Callback = function(value)
                Desync.RandomVectorDistance = value
            end
        }, 'RandomVectorDistance')

        Section:Slider({
            Name = "RandomVectorSpeed",
            Default = Desync.RandomVectorSpeed,
            Minimum = 5,
            Maximum = 100000000000,
            Precision = 0,
            Callback = function(value)
                Desync.RandomVectorSpeed = value
            end
        }, 'RandomVectorSpeed')

        Section:Slider({
            Name = "RandomVectorAmplitude",
            Default = Desync.RandomVectorAmplitude,
            Minimum = 1,
            Maximum = 10,
            Precision = 1,
            Callback = function(value)
                Desync.RandomVectorAmplitude = value
            end
        }, 'RandomVectorAmplitude')

        Section:Header({ Name = 'AngleJitter' })

        Section:Slider({
            Name = "BaseDelay",
            Default = Desync.AngleJitter.BaseDelay,
            Minimum = 0,
            Maximum = 1,
            Precision = 2,
            Callback = function(value)
                Desync.AngleJitter.BaseDelay = value
            end
        }, 'AngleJitterBaseDelay')

        Section:Slider({
            Name = "RandomFactor",
            Default = Desync.AngleJitter.RandomFactor,
            Minimum = 0,
            Maximum = 1,
            Precision = 2,
            Callback = function(value)
                Desync.AngleJitter.RandomFactor = value
            end
        }, 'AngleJitterRandomFactor')

        Section:Slider({
            Name = "MaxVelocity",
            Default = Desync.AngleJitter.MaxVelocity,
            Minimum = 10000,
            Maximum = 500000,
            Precision = 0,
            Callback = function(value)
                Desync.AngleJitter.MaxVelocity = value
            end
        }, 'AngleJitterMaxVelocity')

        Section:Slider({
            Name = "AngleJitterValue",
            Default = Desync.AngleJitter.AngleJitterValue,
            Minimum = 500,
            Maximum = 2000,
            Precision = 0,
            Callback = function(value)
                Desync.AngleJitter.AngleJitterValue = value
            end
        }, 'AngleJitterValue')

        Section:Keybind({
            Name = "Keybind",
            Default = Desync.Keybind,
            Callback = function(key)
                if not UserInputService:GetFocusedTextBox() then
                    Desync.Keybind = key
                    if Desync.Enabled then
                        Desync.Enabled = false
                        Desync.UndergroundV2Active = false
                        Desync.AngleJitter.Active = false
                        ServerVisualization:Remove()
                        PhysicsVisualization:Remove()
                        notify("Desync", "Desync Disabled", true)
                    else
                        Desync.Enabled = true
                        notify("Desync", "Desync Enabled", true)
                    end
                end
            end
        }, 'DesyncKeybind')
    end
}
