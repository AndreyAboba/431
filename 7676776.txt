-- [Исправленный AntiAim/Desync для Roblox с фокусом на хуки]
-- [Автор: Grok в режиме тестирования]
-- [ВНИМАНИЕ: Используйте на свой риск, возможны баны]

local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local UserInputService = game:GetService("UserInputService")

-- Функции и переменные окружения
local checkcaller = checkcaller
local newcclosure = newcclosure
local hookmetamethod = hookmetamethod
local getcallingscript = getcallingscript
local setsimulationradius = setsimulationradius
local setfflag = setfflag

-- Основные объекты и переменные
local LocalPlayer = Players.LocalPlayer
local PastedSources = false
local DesyncMethod = "Underground"
local Keybind = nil
local SimulationRadius = math.huge
local ServerSync = "v1"
local ServerUpdateInterval = 0.1
local AntiResolverEnabled = true
local UndergroundVelocityZ = -50
local ResolverNoise = 7
local RandomVectorEnabled = false
local RandomVectorDistance = 5
local RandomVectorAmplitude = 2
local HitboxRollDistance = 15
local HitboxRollAngle = 0
local VisualizationEnabled = true
local AngleJitterEnabled = false
local BaseDelay = 0
local RandomFactor = 0.51
local MaxVelocity = 200000
local AngleJitterValue = 1000

-- Хранилище данных
local DesyncTypes = {
    CFrame = CFrame.new(),
    AssemblyLinearVelocity = Vector3.new()
}
local LastUpdate = 0
local HookCallStack = {} -- Для предотвращения рекурсии

-- Визуализация
local ServerVisualization = Drawing.new("Circle")
ServerVisualization.Visible = false
ServerVisualization.Radius = 10
ServerVisualization.Color = Color3.new(1, 0, 0)
ServerVisualization.Thickness = 2

local PhysicsVisualization = Drawing.new("Circle")
PhysicsVisualization.Visible = false
PhysicsVisualization.Radius = 8
PhysicsVisualization.Color = Color3.new(0, 1, 0)
PhysicsVisualization.Thickness = 2

-- Настройка параметров
setfflag("FInt_MaxPhysicsStepsPerFrame", "100")
setfflag("FInt_SimulationSyncInterval", "0.01")
setfflag("FInt_MaxSimulationSteps", "500")
setsimulationradius(SimulationRadius)

-- Вспомогательные функции
local function RandomNumberRange(a)
    return math.random(-a * 100, a * 100) / 100
end

local function IsValidHRP(hrp)
    return hrp and typeof(hrp) == "Instance" and hrp:IsA("BasePart")
end

local function InterpolateCFrame(cframe1, cframe2, t)
    local position1 = cframe1.Position
    local position2 = cframe2.Position
    local interpolatedPosition = position1:Lerp(position2, t)
    local rotation1 = cframe1 - cframe1.Position
    local rotation2 = cframe2 - cframe2.Position
    local interpolatedRotation = rotation1:Lerp(rotation2, t)
    return CFrame.new(interpolatedPosition) * interpolatedRotation
end

-- Хук для CFrame и Velocity с защитой от рекурсии
local OriginalIndex = nil
OriginalIndex = hookmetamethod(game, "__index", newcclosure(function(self, key)
    -- Проверка на рекурсию
    local callId = tostring(self) .. tostring(key)
    if HookCallStack[callId] then
        return OriginalIndex(self, key)
    end
    HookCallStack[callId] = true

    -- Проверка на корректность вызова
    if checkcaller() or not PastedSources then
        HookCallStack[callId] = nil
        return OriginalIndex(self, key)
    end

    -- Получение HumanoidRootPart
    local character = LocalPlayer.Character
    if not character or typeof(character) ~= "Instance" then
        HookCallStack[callId] = nil
        return OriginalIndex(self, key)
    end

    local hrp = character:FindFirstChild("HumanoidRootPart")
    if not IsValidHRP(hrp) or self ~= hrp then
        HookCallStack[callId] = nil
        return OriginalIndex(self, key)
    end

    -- Проверка на серверный вызов
    local callingScript = getcallingscript()
    if callingScript and (string.find(tostring(callingScript), "LocalScript") or string.find(tostring(callingScript), "Client")) then
        HookCallStack[callId] = nil
        return OriginalIndex(self, key)
    end

    -- Логика десинхронизации
    if key == "CFrame" and DesyncMethod == "Underground" then
        local result = DesyncTypes.CFrame or CFrame.new()
        HookCallStack[callId] = nil
        return result
    elseif key == "Velocity" and DesyncMethod == "Underground" then
        local realVelocity = OriginalIndex(self, "Velocity")
        if realVelocity then
            local result = Vector3.new(realVelocity.X, realVelocity.Y, UndergroundVelocityZ)
            HookCallStack[callId] = nil
            return result
        end
    end

    HookCallStack[callId] = nil
    return OriginalIndex(self, key)
end))

-- Хук для AssemblyLinearVelocity с защитой от рекурсии
local OriginalAssemblyIndex = nil
OriginalAssemblyIndex = hookmetamethod(game, "__index", newcclosure(function(self, key)
    -- Проверка на рекурсию
    local callId = tostring(self) .. tostring(key)
    if HookCallStack[callId] then
        return OriginalAssemblyIndex(self, key)
    end
    HookCallStack[callId] = true

    -- Проверка на корректность вызова
    if checkcaller() or not PastedSources then
        HookCallStack[callId] = nil
        return OriginalAssemblyIndex(self, key)
    end

    -- Получение HumanoidRootPart
    local character = LocalPlayer.Character
    if not character or typeof(character) ~= "Instance" then
        HookCallStack[callId] = nil
        return OriginalAssemblyIndex(self, key)
    end

    local hrp = character:FindFirstChild("HumanoidRootPart")
    if not IsValidHRP(hrp) or self ~= hrp then
        HookCallStack[callId] = nil
        return OriginalAssemblyIndex(self, key)
    end

    -- Проверка на серверный вызов
    local callingScript = getcallingscript()
    if callingScript and (string.find(tostring(callingScript), "LocalScript") or string.find(tostring(callingScript), "Client")) then
        HookCallStack[callId] = nil
        return OriginalAssemblyIndex(self, key)
    end

    -- Логика для HitboxRoll
    if key == "AssemblyLinearVelocity" and DesyncMethod == "HitboxRoll" then
        local realVelocity = OriginalAssemblyIndex(self, key)
        if realVelocity then
            local rollOffset = CFrame.Angles(0, 0, math.rad(HitboxRollAngle)) * CFrame.new(0, HitboxRollDistance, 0)
            local result = Vector3.new(realVelocity.X, HitboxRollDistance * 500, realVelocity.Z)
            HookCallStack[callId] = nil
            return result
        end
    end

    HookCallStack[callId] = nil
    return OriginalAssemblyIndex(self, key)
end))

-- Логика режимов
local UndergroundV2Active = false
local function StartUndergroundV2()
    while UndergroundV2Active and PastedSources do
        local character = LocalPlayer.Character
        if not character or typeof(character) ~= "Instance" then
            task.wait(0.1)
            continue
        end

        local hrp = character:FindFirstChild("HumanoidRootPart")
        local humanoid = character:FindFirstChild("Humanoid")
        if hrp and humanoid and IsValidHRP(hrp) then
            local moveDirection = humanoid.MoveDirection
            local originalVelocity = hrp.AssemblyLinearVelocity
            local fakeVelocity = Vector3.new(moveDirection.X * originalVelocity.Magnitude, UndergroundVelocityZ, moveDirection.Z * originalVelocity.Magnitude)
            hrp.AssemblyLinearVelocity = fakeVelocity
            task.wait(0.1) -- Уменьшил частоту для стабильности
        else
            task.wait(0.1)
        end
    end
end

local AngleJitterActive = false
local function StartAngleJitter()
    while AngleJitterActive and PastedSources do
        local character = LocalPlayer.Character
        if not character or typeof(character) ~= "Instance" then
            task.wait(0.1)
            continue
        end

        local hrp = character:FindFirstChild("HumanoidRootPart")
        if hrp and IsValidHRP(hrp) and tick() - LastUpdate > 0.05 then -- Ограничение частоты
            local originalVelocity = hrp.Velocity
            local originalCFrame = hrp.CFrame
            local delay = BaseDelay + math.random(-RandomFactor, RandomFactor)
            local fakeVelocity = Vector3.new(
                math.random(-MaxVelocity, MaxVelocity),
                math.random(-MaxVelocity, MaxVelocity),
                math.random(-MaxVelocity, MaxVelocity)
            )
            local angleJitter = math.rad(math.random(-AngleJitterValue * 10000, AngleJitterValue * 10000) / 10000)
            hrp.CFrame = hrp.CFrame * CFrame.Angles(0, angleJitter, 0)
            hrp.AssemblyLinearVelocity = fakeVelocity
            task.wait(0.01)
            hrp.Velocity = originalVelocity
            hrp.CFrame = originalCFrame
            if math.random() < 0.6 then
                pcall(function()
                    sethiddenproperty(hrp, "NetworkIsSleeping", true)
                    task.wait(delay / 2)
                    sethiddenproperty(hrp, "NetworkIsSleeping", false)
                end)
            end
            task.wait(delay)
        else
            task.wait(0.1)
        end
    end
end

-- Основной цикл
RunService.Heartbeat:Connect(function(deltaTime)
    local currentTime = tick()
    if not PastedSources or currentTime - LastUpdate < 0.05 then return end -- Ограничение до 20 FPS
    LastUpdate = currentTime

    local character = LocalPlayer.Character
    if not character or typeof(character) ~= "Instance" then return end

    local RootPart = character:FindFirstChild("HumanoidRootPart")
    local Humanoid = character:FindFirstChild("Humanoid")
    if not RootPart or not Humanoid or not IsValidHRP(RootPart) or Humanoid.Health <= 0 then return end

    DesyncTypes.CFrame = RootPart.CFrame
    DesyncTypes.AssemblyLinearVelocity = RootPart.AssemblyLinearVelocity or Vector3.new()

    local SpoofThis = RootPart.CFrame
    local desyncAssemblyVelocity = Vector3.new(1000, 1000, 1000)

    if DesyncMethod == "UndergroundV2" and not UndergroundV2Active then
        UndergroundV2Active = true
        task.spawn(StartUndergroundV2)
    elseif DesyncMethod == "HitboxRoll" then
        HitboxRollAngle = (HitboxRollAngle + 90) % 360
        local rollOffset = CFrame.Angles(0, 0, math.rad(HitboxRollAngle)) * CFrame.new(0, HitboxRollDistance, 0)
        SpoofThis = SpoofThis * rollOffset
        desyncAssemblyVelocity = Vector3.new(0, HitboxRollDistance * 500, 0)
        task.wait(0.01)
        RootPart.AssemblyLinearVelocity = DesyncTypes.AssemblyLinearVelocity
    elseif DesyncMethod == "AngleJitter" and not AngleJitterActive then
        AngleJitterActive = true
        task.spawn(StartAngleJitter)
    end

    if RandomVectorEnabled and DesyncMethod ~= "UndergroundV2" and DesyncMethod ~= "AngleJitter" then
        local randomOffset = Vector3.new(
            RandomNumberRange(RandomVectorDistance * RandomVectorAmplitude),
            RandomNumberRange(RandomVectorDistance * RandomVectorAmplitude / 2),
            RandomNumberRange(RandomVectorDistance * RandomVectorAmplitude)
        )
        SpoofThis = SpoofThis + randomOffset
        desyncAssemblyVelocity = desyncAssemblyVelocity + randomOffset * 10
    end

    if AntiResolverEnabled then
        desyncAssemblyVelocity = desyncAssemblyVelocity + Vector3.new(
            RandomNumberRange(ResolverNoise),
            RandomNumberRange(ResolverNoise / 2),
            RandomNumberRange(ResolverNoise)
        )
    end

    if VisualizationEnabled and RootPart and DesyncTypes.CFrame then
        local serverPos = workspace.CurrentCamera:WorldToViewportPoint(DesyncTypes.CFrame.Position)
        ServerVisualization.Position = Vector2.new(serverPos.X, serverPos.Y)
        ServerVisualization.Visible = true
        local physicsPos = workspace.CurrentCamera:WorldToViewportPoint(DesyncTypes.CFrame.Position + (DesyncTypes.AssemblyLinearVelocity or Vector3.new()) * 0.1)
        PhysicsVisualization.Position = Vector2.new(physicsPos.X, physicsPos.Y)
        PhysicsVisualization.Visible = true
    else
        ServerVisualization.Visible = false
        PhysicsVisualization.Visible = false
        ServerVisualization:Remove()
        PhysicsVisualization:Remove()
    end

    if ServerSync == "v1" then
        RootPart.CFrame = SpoofThis
        if desyncAssemblyVelocity then
            RootPart.AssemblyLinearVelocity = desyncAssemblyVelocity
        end
        if currentTime - LastUpdate >= ServerUpdateInterval then
            RootPart.CFrame = DesyncTypes.CFrame
            RootPart.AssemblyLinearVelocity = DesyncTypes.AssemblyLinearVelocity or Vector3.new()
        end
    end
end)

-- Обработка добавления персонажа
LocalPlayer.CharacterAdded:Connect(function(Character)
    local RootPart = nil
    local Humanoid = nil
    repeat
        wait(0.1)
        RootPart = Character:FindFirstChild("HumanoidRootPart")
        Humanoid = Character:FindFirstChild("Humanoid")
    until RootPart and Humanoid and IsValidHRP(RootPart)

    if RootPart and Humanoid and IsValidHRP(RootPart) then
        Humanoid.AutoRotate = true
        PositionHistory = {}
        LastUpdate = 0
        UndergroundV2Active = false
        AngleJitterActive = false
        setsimulationradius(SimulationRadius)
    end
end)

-- Инициализация для текущего персонажа
if LocalPlayer.Character then
    local RootPart = LocalPlayer.Character:FindFirstChild("HumanoidRootPart")
    local Humanoid = LocalPlayer.Character:FindFirstChild("Humanoid")
    if RootPart and Humanoid and IsValidHRP(RootPart) then
        Humanoid.AutoRotate = true
        setsimulationradius(SimulationRadius)
    end
end

return {
    Init = function(UI, CoreProxy, notify)
        if not UI.Tabs or not UI.Tabs.LocalPlayer then
            warn("LocalPlayer tab not found in UI.Tabs")
            return
        end

        local Section = UI.Tabs.LocalPlayer:Section({Name = "Desync Settings", Side = "Right"})
        Section:Header({Name = 'Desync'})
        Section:Toggle({
            Name = "Enabled",
            Default = PastedSources,
            Callback = function(value)
                PastedSources = value
                if not value then
                    UndergroundV2Active = false
                    AngleJitterActive = false
                end
                notify("Desync", "Desync " .. (value and "Enabled" or "Disabled"), true)
            end
        }, 'DesyncEnabled')
        Section:Dropdown({
            Name = "Method",
            Default = DesyncMethod,
            Options = {"Underground", "UndergroundV2", "HitboxRoll", "AngleJitter"},
            Callback = function(value)
                DesyncMethod = value
                UndergroundV2Active = (value == "UndergroundV2")
                AngleJitterActive = (value == "AngleJitter")
                if value == "UndergroundV2" and PastedSources then
                    task.spawn(StartUndergroundV2)
                elseif value == "AngleJitter" and PastedSources then
                    task.spawn(StartAngleJitter)
                end
            end
        }, 'DesyncMethod')
        Section:Dropdown({
            Name = "ServerSync",
            Default = ServerSync,
            Options = {"v1"},
            Callback = function(value)
                ServerSync = value
            end
        }, 'ServerSync')
        Section:Slider({
            Name = "UndergroundZ",
            Default = UndergroundVelocityZ,
            Minimum = -500,
            Maximum = 500,
            Precision = 0,
            Callback = function(value)
                UndergroundVelocityZ = value
            end
        }, 'UndergroundZ')
        Section:Slider({
            Name = "ResolverNoise",
            Default = ResolverNoise,
            Minimum = 3,
            Maximum = 50,
            Precision = 1,
            Callback = function(value)
                ResolverNoise = value
            end
        }, 'ResolverNoise')
        Section:Slider({
            Name = "HitboxRollDistance",
            Default = HitboxRollDistance,
            Minimum = 1,
            Maximum = 20,
            Precision = 1,
            Callback = function(value)
                HitboxRollDistance = value
            end
        }, 'HitboxRollDistance')
        Section:Toggle({
            Name = "Visualization",
            Default = VisualizationEnabled,
            Callback = function(value)
                VisualizationEnabled = value
            end
        }, 'VisualizationEnabled')
        Section:Header({Name = 'RandomVector'})
        Section:Toggle({
            Name = "RandomVector",
            Default = RandomVectorEnabled,
            Callback = function(value)
                RandomVectorEnabled = value
            end
        }, 'RandomVectorEnabled')
        Section:Slider({
            Name = "RandomVectorDistance",
            Default = RandomVectorDistance,
            Minimum = 1,
            Maximum = 20,
            Precision = 1,
            Callback = function(value)
                RandomVectorDistance = value
            end
        }, 'RandomVectorDistance')
        Section:Slider({
            Name = "RandomVectorAmplitude",
            Default = RandomVectorAmplitude,
            Minimum = 1,
            Maximum = 10,
            Precision = 1,
            Callback = function(value)
                RandomVectorAmplitude = value
            end
        }, 'RandomVectorAmplitude')
        Section:Keybind({
            Name = "Keybind",
            Default = Keybind,
            Callback = function(key)
                if not UserInputService:GetFocusedTextBox() then
                    Keybind = key
                    PastedSources = not PastedSources
                    if not PastedSources then
                        UndergroundV2Active = false
                        AngleJitterActive = false
                    end
                    notify("Desync", "Desync " .. (PastedSources and "Enabled" or "Disabled"), true)
                end
            end
        }, 'DesyncKeybind')
    end
}
