local KillAura = {}

function KillAura.Init(UI, Core, notify)
    local Players = game:GetService("Players")
    local ReplicatedStorage = game:GetService("ReplicatedStorage")
    local RunService = game:GetService("RunService")
    local RemoteEvents = ReplicatedStorage:WaitForChild("RemoteEvents"):WaitForChild("ToServer")
    local ChangeStance = RemoteEvents:WaitForChild("ChangeStance")
    local Hit = RemoteEvents:WaitForChild("Hit")
    local Kick = RemoteEvents:WaitForChild("Kick")
    local Punch = RemoteEvents:WaitForChild("Punch")

    local LocalPlayer = Players.LocalPlayer

    -- Конфигурация
    local State = {
        Enabled = { Value = false, Default = false },
        Range = { Value = 10, Default = 10 },
        AttackCooldown = { Value = 0.24, Default = 0.24 },
        AntiBlock = { Value = true, Default = true },
        AntiParry = { Value = true, Default = true },
        HighlightBlock = { Value = true, Default = true },
        HighlightParry = { Value = true, Default = true },
        TeamCheck = { Value = true, Default = true },
        ParryColor = { Value = Color3.fromRGB(0, 162, 255), Default = Color3.fromRGB(0, 162, 255) },
        BlockColor = { Value = Color3.fromRGB(0, 255, 0), Default = Color3.fromRGB(0, 255, 0) },
        DefaultColor = { Value = Color3.fromRGB(255, 0, 0), Default = Color3.fromRGB(255, 0, 0) },
        MinusWindup = { Value = 0.9, Default = 0.9 },
        MinusRelease = { Value = 1.4, Default = 1.4 },
        KickDelay = { Value = 0.01, Default = 0.01 },
        KickStateDelay = { Value = 0, Default = 0 },
        DamagePlus = { Value = 0, Default = 0 }
    }

    local targetHighlight = nil -- Подсветка для одной цели
    local cachedSettings = nil -- Кэш для настроек
    local lastWeapon = nil -- Для отслеживания смены оружия
    local lastAttackTime = 0 -- Для отслеживания времени последней атаки
    local localCharacter = nil -- Кэш для персонажа локального игрока
    local localRootPart = nil -- Кэш для HumanoidRootPart
    local lastNotificationTime = 0
    local notificationDelay = 5

    -- Функция для проверки состояния игрока (Parrying, Riposte, Blocking)
    local function getPlayerStance(player)
        if player == LocalPlayer then
            return nil
        end
        local character = player.Character
        if character then
            local stanceValue = character:FindFirstChild("Stance", true)
            if stanceValue and stanceValue:IsA("StringValue") then
                return stanceValue.Value:lower()
            end
        end
        return nil
    end

    -- Функция для получения настроек оружия
    local function getWeaponSettings()
        if not localCharacter then return nil end
        
        local weapon
        for _, child in pairs(localCharacter:GetChildren()) do
            if child:IsA("Tool") then
                weapon = child
                break
            end
        end
        if not weapon then
            return nil
        end
        
        if weapon == lastWeapon and cachedSettings then
            return cachedSettings
        end
        
        local settingsModule = weapon:FindFirstChild("Settings")
        if not settingsModule then
            return nil
        end
        
        local success, settings = pcall(require, settingsModule)
        if not success or not settings or not settings.Windup or not settings.Release or not settings.Damage then
            return nil
        end
        
        settings.Windup = math.max(0, settings.Windup - State.MinusWindup.Value)
        settings.Release = math.max(0, settings.Release - State.MinusRelease.Value)
        settings.Damage = settings.Damage + State.DamagePlus.Value
        
        cachedSettings = {
            weapon = weapon,
            windupTime = settings.Windup,
            releaseTime = settings.Release,
            damage = settings.Damage
        }
        lastWeapon = weapon
        return cachedSettings
    end

    -- Функция для проверки расстояния и состояния игрока
    local function canTargetPlayer(targetPlayer)
        if not (localCharacter and localRootPart and targetPlayer.Character) then return false end
        
        local targetRootPart = targetPlayer.Character:FindFirstChild("HumanoidRootPart")
        local humanoid = targetPlayer.Character:FindFirstChild("Humanoid")
        if not (targetRootPart and humanoid) or humanoid.Health <= 0 or humanoid:GetState() ~= Enum.HumanoidStateType.Running then
            return false
        end
        
        local distance = (localRootPart.Position - targetRootPart.Position).Magnitude
        if distance > State.Range.Value then
            return false
        end
        
        if State.TeamCheck.Value and targetPlayer.Team and LocalPlayer.Team then
            local localTeamName = LocalPlayer.Team.Name
            local targetTeamName = targetPlayer.Team.Name
            if localTeamName == targetTeamName and localTeamName ~= "Spectators" then
                return false
            elseif localTeamName == "Spectators" then
                return true
            elseif localTeamName == "Guesmand" then
                return targetTeamName == "Spectators" or targetTeamName == "Sunderland"
            elseif localTeamName == "Sunderland" then
                return targetTeamName == "Guesmand" or targetTeamName == "Spectators"
            end
            return false
        end
        
        return true
    end

    -- Функция для создания/обновления подсветки для таргета
    local function updateTargetHighlight(player)
        if not player or not player.Character then
            if targetHighlight then
                targetHighlight:Destroy()
                targetHighlight = nil
            end
            return
        end
        
        local character = player.Character
        if not targetHighlight then
            targetHighlight = Instance.new("Highlight")
            targetHighlight.Name = "TargetHighlight"
            targetHighlight.Parent = character
            targetHighlight.Adornee = character
            targetHighlight.FillTransparency = 0.5
            targetHighlight.OutlineTransparency = 0
        end
        
        local stance = getPlayerStance(player)
        if stance and (stance == "parrying" or stance == "block" or stance == "blocking") and State.HighlightBlock.Value then
            targetHighlight.FillColor = State.BlockColor.Value
            targetHighlight.Enabled = true
        elseif stance and stance == "riposte" and State.HighlightParry.Value then
            targetHighlight.FillColor = State.ParryColor.Value
            targetHighlight.Enabled = true
        else
            targetHighlight.FillColor = State.DefaultColor.Value
            targetHighlight.Enabled = true
        end
    end

    -- Функция для удаления подсветки
    local function removeTargetHighlight()
        if targetHighlight then
            targetHighlight:Destroy()
            targetHighlight = nil
        end
    end

    -- Обработка ухода игрока
    Players.PlayerRemoving:Connect(function(player)
        if targetHighlight and targetHighlight.Adornee == player.Character then
            removeTargetHighlight()
        end
    end)

    -- Обработка появления нового персонажа и смерти
    local function onCharacterAdded(player)
        player.CharacterAdded:Connect(function(character)
            local humanoid = character:WaitForChild("Humanoid", 5)
            if humanoid then
                humanoid.Died:Connect(function()
                    if targetHighlight and targetHighlight.Adornee == character then
                        removeTargetHighlight()
                    end
                end)
            end
        end)
    end

    for _, player in pairs(Players:GetPlayers()) do
        onCharacterAdded(player)
    end
    Players.PlayerAdded:Connect(onCharacterAdded)

    -- Функция для получения расстояния до игрока
    local function getDistanceToPlayer(targetPlayer)
        local targetRootPart = targetPlayer.Character and targetPlayer.Character:FindFirstChild("HumanoidRootPart")
        if targetRootPart and localRootPart then
            return (localRootPart.Position - targetRootPart.Position).Magnitude
        end
        return math.huge
    end

    -- Функция для выполнения пинка
    local function performKick(targetPlayer, targetCharacter, weapon)
        local targetHumanoid = targetCharacter:FindFirstChild("Humanoid")
        if not targetHumanoid then return false end
        
        local stance = getPlayerStance(targetPlayer)
        if not stance or stance ~= "riposte" or not State.AntiParry.Value then return false end
        
        ChangeStance:FireServer("KickWindup")
        task.wait(State.KickDelay.Value)
        
        if not targetCharacter or not targetCharacter.Parent or not targetCharacter:FindFirstChild("Humanoid") then return false end
        stance = getPlayerStance(targetPlayer)
        if not stance or stance ~= "riposte" or not State.AntiParry.Value then return false end
        
        ChangeStance:FireServer("Kicking")
        task.wait(State.KickStateDelay.Value)
        
        if not targetCharacter or not targetCharacter.Parent or not targetCharacter:FindFirstChild("Humanoid") then return false end
        stance = getPlayerStance(targetPlayer)
        if not stance or stance ~= "riposte" or not State.AntiParry.Value then return false end
        
        local targetHandle = targetCharacter:FindFirstChild("CollisionBubble") or targetCharacter:FindFirstChild("HumanoidRootPart")
        if not targetHandle then return false end
        
        Kick:FireServer(weapon, targetHandle, targetHumanoid)
        return true
    end

    -- Функция для выполнения пунша
    local function performPunch(targetPlayer, targetCharacter, weapon)
        local targetHumanoid = targetCharacter:FindFirstChild("Humanoid")
        if not targetHumanoid then return false end
        
        local stance = getPlayerStance(targetPlayer)
        if not stance or not ((stance == "parrying" or stance == "block" or stance == "blocking") and State.AntiBlock.Value) then return false end
        
        ChangeStance:FireServer("Punching")
        task.wait(State.KickDelay.Value)
        
        if not targetCharacter or not targetCharacter.Parent or not targetCharacter:FindFirstChild("Humanoid") then return false end
        stance = getPlayerStance(targetPlayer)
        if not stance or not ((stance == "parrying" or stance == "block" or stance == "blocking") and State.AntiBlock.Value) then return false end
        
        local targetHandle = targetCharacter:FindFirstChild("HumanoidRootPart")
        if not (weapon and targetHandle) then return false end
        
        Punch:FireServer(weapon, targetHandle, targetHumanoid)
        return true
    end

    -- Основной цикл киллауры
    local function runKillAura()
        while true do
            RunService.Heartbeat:Wait()
            
            if not State.Enabled.Value then
                removeTargetHighlight()
                continue
            end
            
            localCharacter = LocalPlayer.Character
            localRootPart = localCharacter and localCharacter:FindFirstChild("HumanoidRootPart")
            if not (localCharacter and localRootPart) then
                removeTargetHighlight()
                continue
            end
            
            local settings = getWeaponSettings()
            if not settings then
                removeTargetHighlight()
                continue
            end
            
            if tick() - lastAttackTime < State.AttackCooldown.Value then
                continue
            end
            
            local closestTarget = nil
            local minDistance = math.huge
            for _, player in pairs(Players:GetPlayers()) do
                if player ~= LocalPlayer and canTargetPlayer(player) then
                    local distance = getDistanceToPlayer(player)
                    if distance < minDistance then
                        minDistance = distance
                        closestTarget = player
                    end
                end
            end
            
            if not closestTarget then
                removeTargetHighlight()
                continue
            end
            
            local targetCharacter = closestTarget.Character
            local targetHumanoid = targetCharacter and targetCharacter:FindFirstChild("Humanoid")
            if not (targetCharacter and targetHumanoid) then
                removeTargetHighlight()
                continue
            end
            
            updateTargetHighlight(closestTarget)
            local stance = getPlayerStance(closestTarget)
            
            local attacked = false
            if stance then
                if (stance == "parrying" or stance == "block" or stance == "blocking") and State.AntiBlock.Value then
                    attacked = performPunch(closestTarget, targetCharacter, settings.weapon)
                elseif stance == "riposte" and State.AntiParry.Value then
                    attacked = performKick(closestTarget, targetCharacter, settings.weapon)
                end
            end
            
            if not attacked then
                ChangeStance:FireServer("Windup")
                task.wait(settings.windupTime)
                
                if not targetCharacter or not targetCharacter.Parent or not targetCharacter:FindFirstChild("Humanoid") then
                    removeTargetHighlight()
                    continue
                end
                stance = getPlayerStance(closestTarget)
                if stance and ((stance == "parrying" or stance == "block" or stance == "blocking") and State.AntiBlock.Value or (stance == "riposte" and State.AntiParry.Value)) then
                    removeTargetHighlight()
                    continue
                end
                
                ChangeStance:FireServer("Release")
                task.wait(settings.releaseTime)
                
                if not targetCharacter or not targetCharacter.Parent or not targetCharacter:FindFirstChild("Humanoid") then
                    removeTargetHighlight()
                    continue
                end
                stance = getPlayerStance(closestTarget)
                if stance and ((stance == "parrying" or stance == "block" or stance == "blocking") and State.AntiBlock.Value or (stance == "riposte" and State.AntiParry.Value)) then
                    removeTargetHighlight()
                    continue
                end
                
                local targetHandle = targetCharacter:FindFirstChildOfClass("Accessory") and 
                    targetCharacter:FindFirstChildOfClass("Accessory"):FindFirstChild("Handle") or 
                    targetCharacter:FindFirstChild("HumanoidRootPart")
                if not targetHandle then
                    removeTargetHighlight()
                    continue
                end
                
                Hit:FireServer(settings.weapon, targetHandle, targetHumanoid)
                attacked = true
            end
            
            if attacked then
                lastAttackTime = tick()
            else
                removeTargetHighlight()
            end
        end
    end

    -- Запуск киллауры в отдельной задаче
    task.spawn(runKillAura)

    -- Инициализация UI
    if UI.Tabs and UI.Tabs.Combat then
        -- Создаем секцию KillAura на левой части
        UI.Sections.KillAura = UI.Sections.KillAura or UI.Tabs.Combat:Section({ Name = "KillAura", Side = "Left" })
        
        UI.Sections.KillAura:Header({ Name = "KillAura" })
        UI.Sections.KillAura:Toggle({
            Name = "Enabled",
            Default = State.Enabled.Default,
            Callback = function(value)
                State.Enabled.Value = value
                if tick() - lastNotificationTime >= notificationDelay then
                    lastNotificationTime = tick()
                    notify("KillAura", "KillAura " .. (value and "Enabled" or "Disabled"), true)
                end
            end
        }, 'EnabledKA')
        UI.Sections.KillAura:Slider({
            Name = "Range",
            Minimum = 4,
            Maximum = 20,
            Default = State.Range.Default,
            Precision = 0,
            Callback = function(value)
                State.Range.Value = value
                if tick() - lastNotificationTime >= notificationDelay then
                    lastNotificationTime = tick()
                    notify("KillAura", "Range set to: " .. value)
                end
            end
        }, 'RangeKA')
        UI.Sections.KillAura:Slider({
            Name = "Attack Cooldown",
            Minimum = 0.1,
            Maximum = 0.5,
            Default = State.AttackCooldown.Default,
            Precision = 2,
            Callback = function(value)
                State.AttackCooldown.Value = value
                if tick() - lastNotificationTime >= notificationDelay then
                    lastNotificationTime = tick()
                    notify("KillAura", "Attack Cooldown set to: " .. value)
                end
            end
        }, 'AttackCooldownKA')
        UI.Sections.KillAura:Divider()
        UI.Sections.KillAura:Toggle({
            Name = "Anti Block",
            Default = State.AntiBlock.Default,
            Callback = function(value)
                State.AntiBlock.Value = value
                if tick() - lastNotificationTime >= notificationDelay then
                    lastNotificationTime = tick()
                    notify("KillAura", "Anti Block " .. (value and "Enabled" or "Disabled"), true)
                end
            end
        }, 'AntiBlockKA')
        UI.Sections.KillAura:Toggle({
            Name = "Anti Parry",
            Default = State.AntiParry.Default,
            Callback = function(value)
                State.AntiParry.Value = value
                if tick() - lastNotificationTime >= notificationDelay then
                    lastNotificationTime = tick()
                    notify("KillAura", "Anti Parry " .. (value and "Enabled" or "Disabled"), true)
                end
            end
        }, 'AntiParryKA')
        UI.Sections.KillAura:Divider()
        UI.Sections.KillAura:Toggle({
            Name = "Highlight Block",
            Default = State.HighlightBlock.Default,
            Callback = function(value)
                State.HighlightBlock.Value = value
                if tick() - lastNotificationTime >= notificationDelay then
                    lastNotificationTime = tick()
                    notify("KillAura", "Highlight Block " .. (value and "Enabled" or "Disabled"), true)
                end
            end
        }, 'HighlightBlockKA')
        UI.Sections.KillAura:Toggle({
            Name = "Highlight Parry",
            Default = State.HighlightParry.Default,
            Callback = function(value)
                State.HighlightParry.Value = value
                if tick() - lastNotificationTime >= notificationDelay then
                    lastNotificationTime = tick()
                    notify("KillAura", "Highlight Parry " .. (value and "Enabled" or "Disabled"), true)
                end
            end
        }, 'HighlightParryKA')
        UI.Sections.KillAura:Colorpicker({
            Name = "Parry Color",
            Default = State.ParryColor.Default,
            Callback = function(value)
                State.ParryColor.Value = value
                if tick() - lastNotificationTime >= notificationDelay then
                    lastNotificationTime = tick()
                    notify("KillAura", "Parry Color set to: R=" .. math.floor(value.R * 255) .. ", G=" .. math.floor(value.G * 255) .. ", B=" .. math.floor(value.B * 255))
                end
            end
        }, 'ParryColorKA')
        UI.Sections.KillAura:Colorpicker({
            Name = "Block Color",
            Default = State.BlockColor.Default,
            Callback = function(value)
                State.BlockColor.Value = value
                if tick() - lastNotificationTime >= notificationDelay then
                    lastNotificationTime = tick()
                    notify("KillAura", "Block Color set to: R=" .. math.floor(value.R * 255) .. ", G=" .. math.floor(value.G * 255) .. ", B=" .. math.floor(value.B * 255))
                end
            end
        }, 'BlockColorKA')
        UI.Sections.KillAura:Divider()
        UI.Sections.KillAura:Toggle({
            Name = "Team Check",
            Default = State.TeamCheck.Default,
            Callback = function(value)
                State.TeamCheck.Value = value
                if tick() - lastNotificationTime >= notificationDelay then
                    lastNotificationTime = tick()
                    notify("KillAura", "Team Check " .. (value and "Enabled" or "Disabled"), true)
                end
            end
        }, 'TeamCheckKA')
        UI.Sections.KillAura:Colorpicker({
            Name = "Default Color",
            Default = State.DefaultColor.Default,
            Callback = function(value)
                State.DefaultColor.Value = value
                if tick() - lastNotificationTime >= notificationDelay then
                    lastNotificationTime = tick()
                    notify("KillAura", "Default Color set to: R=" .. math.floor(value.R * 255) .. ", G=" .. math.floor(value.G * 255) .. ", B=" .. math.floor(value.B * 255))
                end
            end
        }, 'DefaultColorKA')

        -- Создаем секцию ToolExploit на правой части
        UI.Sections.ToolExploit = UI.Sections.ToolExploit or UI.Tabs.Combat:Section({ Name = "ToolExploit", Side = "Right" })
        
        UI.Sections.ToolExploit:Header({ Name = "Tool Exploit" })
        UI.Sections.ToolExploit:Slider({
            Name = "Minus Windup",
            Minimum = 0.1,
            Maximum = 2,
            Default = State.MinusWindup.Default,
            Precision = 1,
            Callback = function(value)
                State.MinusWindup.Value = value
                if tick() - lastNotificationTime >= notificationDelay then
                    lastNotificationTime = tick()
                    notify("ToolExploit", "Minus Windup set to: " .. value)
                end
            end
        }, 'MinusWindupTE')
        UI.Sections.ToolExploit:Slider({
            Name = "Minus Release",
            Minimum = 0.1,
            Maximum = 2,
            Default = State.MinusRelease.Default,
            Precision = 1,
            Callback = function(value)
                State.MinusRelease.Value = value
                if tick() - lastNotificationTime >= notificationDelay then
                    lastNotificationTime = tick()
                    notify("ToolExploit", "Minus Release set to: " .. value)
                end
            end
        }, 'MinusReleaseTE')
        UI.Sections.ToolExploit:Slider({
            Name = "Damage Plus",
            Minimum = 0,
            Maximum = 50,
            Default = State.DamagePlus.Default,
            Precision = 0,
            Callback = function(value)
                State.DamagePlus.Value = value
                if tick() - lastNotificationTime >= notificationDelay then
                    lastNotificationTime = tick()
                    notify("ToolExploit", "Damage Plus set to: " .. value)
                end
            end
        }, 'DamagePlusTE')
        UI.Sections.ToolExploit:Divider()
        UI.Sections.ToolExploit:Slider({
            Name = "Kick Delay",
            Minimum = 0.01,
            Maximum = 0.2,
            Default = State.KickDelay.Default,
            Precision = 3,
            Callback = function(value)
                State.KickDelay.Value = value
                if tick() - lastNotificationTime >= notificationDelay then
                    lastNotificationTime = tick()
                    notify("ToolExploit", "Kick Delay set to: " .. value)
                end
            end
        }, 'KickDelayTE')
        UI.Sections.ToolExploit:Slider({
            Name = "Kick State Delay",
            Minimum = 0.01,
            Maximum = 0.2,
            Default = State.KickStateDelay.Default,
            Precision = 3,
            Callback = function(value)
                State.KickStateDelay.Value = value
                if tick() - lastNotificationTime >= notificationDelay then
                    lastNotificationTime = tick()
                    notify("ToolExploit", "Kick State Delay set to: " .. value)
                end
            end
        }, 'KickStateDelayTE')
    end
end

return KillAura
