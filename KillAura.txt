local KillAura = {}

function KillAura.Init(UI, Core, notify)
    local Players = game:GetService("Players")
    local ReplicatedStorage = game:GetService("ReplicatedStorage")
    local RunService = game:GetService("RunService")
    local ContextActionService = game:GetService("ContextActionService")
    local Animation = game:GetService("Animation")
    local StarterGui = game:GetService("StarterGui")
    local UserInputService = game:GetService("UserInputService")
    local RemoteEvents = ReplicatedStorage:WaitForChild("RemoteEvents"):WaitForChild("ToServer")
    local ChangeStance = RemoteEvents:WaitForChild("ChangeStance")
    local Hit = RemoteEvents:WaitForChild("Hit")
    local Kick = RemoteEvents:WaitForChild("Kick")
    local Punch = RemoteEvents:WaitForChild("Punch")

    local LocalPlayer = Players.LocalPlayer
    local ClientModule = require(ReplicatedStorage:WaitForChild("ClientModule"))

    local State = {
        KillAura = {
            Enabled = { Value = false, Default = false },
            Range = { Value = 10, Default = 10 },
            AttackCooldown = { Value = 0.24, Default = 0.24 },
            AntiBlock = { Value = true, Default = true },
            AntiParry = { Value = true, Default = true },
            HighlightBlock = { Value = true, Default = true },
            HighlightParry = { Value = true, Default = true },
            TeamCheck = { Value = true, Default = true },
            DynamicCooldown = { Value = false, Default = false },
            CooldownValues = { Value = {0.1, 0.15, 0.2, 0.3}, Default = {0.1, 0.15, 0.2, 0.3} },
            ParryColor = { Value = Color3.fromRGB(0, 162, 255), Default = Color3.fromRGB(0, 162, 255) },
            BlockColor = { Value = Color3.fromRGB(0, 255, 0), Default = Color3.fromRGB(0, 255, 0) },
            DefaultColor = { Value = Color3.fromRGB(255, 0, 0), Default = Color3.fromRGB(255, 0, 0) },
            MinusWindup = { Value = 0.9, Default = 0.9 },
            MinusRelease = { Value = 1.4, Default = 1.4 },
            KickDelay = { Value = 0.01, Default = 0.01 },
            KickStateDelay = { Value = 0, Default = 0 }
        },
        AutoDodge = {
            Enabled = { Value = false, Default = false },
            Range = { Value = 10, Default = 10 },
            PreRange = { Value = 20, Default = 20 },
            DodgeCooldown = { Value = 0.2, Default = 0.2 },
            TeamCheck = { Value = true, Default = true },
            KillAuraSync = { Value = false, Default = false },
            IdleSpoof = { Value = false, Default = false },
            UseClientIdle = { Value = false, Default = false },
            WarningText = { Value = false, Default = false },
            WarningTextScale = { Value = 1, Default = 1 },
            WarningTextPosition = { Value = UDim2.new(0.5, -100, 0.1, 0), Default = UDim2.new(0.5, -100, 0.1, 0) },
            BlockingMode = { Value = "Chance", Default = "Chance" },
            ParryingChance = { Value = 50, Default = 50 },
            RiposteChance = { Value = 50, Default = 50 },
            MissChance = { Value = 0, Default = 0 },
            LegitBlock = { Value = true, Default = true },
            LegitParry = { Value = true, Default = true },
            BaseMultiplier = { Value = 0.15, Default = 0.15 },
            DistanceFactor = { Value = 0.03, Default = 0.03 },
            Delay = { Value = 0.02, Default = 0.02 },
            Blocking = { Value = true, Default = true },
            BlockingAntiStun = { Value = true, Default = true },
            RiposteMouseLockDuration = { Value = 1.5, Default = 1.5 },
            MaxWaitTime = { Value = 2.0, Default = 2.0 }
        },
        LegitHelper = {
            Enabled = { Value = false, Default = false },
            AutoKick = { Value = false, Default = false },
            Range = { Value = 10, Default = 10 },
            TeamCheck = { Value = true, Default = true },
            AutoDodgeSync = { Value = false, Default = false },
            LegitKick = { Value = true, Default = true }
        }
    }

    local targetHighlight = nil
    local currentTarget = nil
    local cachedSettings = nil
    local lastWeapon = nil
    local lastAttackTime = 0
    local localCharacter = nil
    local localRootPart = nil
    local localHumanoid = nil
    local lastNotificationTime = 0
    local notificationDelay = 5
    local lastDodgeTime = 0
    local closestTarget = nil
    local lastStance = nil
    local lastTargetWeapon = nil
    local lastReleaseTime = nil
    local isPerformingAction = false
    local isRiposteActive = false
    local riposteEndTime = 0
    local isDodgePending = false
    local desiredDodgeAction = nil
    local lastKickTime = 0
    local kickCooldown = 0.3
    local warningTextLabel = nil
    local isDragging = false
    local dragStart = nil
    local startPos = nil

    local INVALID_STANCES = {"windup", "release", "parrying", "unparry", "punching", "kickwindup", "kicking", "flinch", "recovery"}
    local VALID_HUMANOID_STATES = {Enum.HumanoidStateType.Running, Enum.HumanoidStateType.None}

    local function getPlayerStance(player)
        local character = player.Character
        if not character then
            return nil
        end
        local stanceValue = character:FindFirstChild("Stance", true)
        if stanceValue and stanceValue:IsA("StringValue") then
            return stanceValue.Value:lower()
        end
        return nil
    end

    local function getTargetWeaponSettings(targetPlayer)
        local character = targetPlayer.Character
        if not character then
            return nil, nil
        end
        local weapon
        for _, child in pairs(character:GetChildren()) do
            if child:IsA("Tool") then
                weapon = child
                break
            end
        end
        if not weapon then
            return nil, nil
        end
        local settingsModule = weapon:FindFirstChild("Settings")
        if not settingsModule then
            return nil, nil
        end
        local settings = require(settingsModule)
        if not settings or type(settings) ~= "table" or not settings.Release or type(settings.Release) ~= "number" or settings.Release <= 0 then
            return nil, nil
        end
        return weapon, settings
    end

    local function getWeaponSettings()
        if not localCharacter then
            return nil
        end
        local weapon
        for _, child in pairs(localCharacter:GetChildren()) do
            if child:IsA("Tool") then
                weapon = child
                break
            end
        end
        if not weapon then
            cachedSettings = nil
            lastWeapon = nil
            return nil
        end
        if weapon == lastWeapon and cachedSettings then
            return cachedSettings
        end
        local settingsModule = weapon:FindFirstChild("Settings")
        if not settingsModule then
            cachedSettings = nil
            lastWeapon = nil
            return nil
        end
        local success, settings = pcall(require, settingsModule)
        if not success or not settings or not settings.Windup or not settings.Release then
            warn("Failed to load weapon settings")
            cachedSettings = nil
            lastWeapon = nil
            return nil
        end
        if State.KillAura.Enabled.Value then
            settings.Windup = math.max(0, settings.Windup - State.KillAura.MinusWindup.Value)
            settings.Release = math.max(0, settings.Release - State.KillAura.MinusRelease.Value)
        end
        cachedSettings = {
            weapon = weapon,
            windupTime = settings.Windup,
            releaseTime = settings.Release,
            Type = settings.Type or "Unknown"
        }
        lastWeapon = weapon
        return cachedSettings
    end

    local function getLocalWeaponSettings()
        if not localCharacter then
            return nil, nil
        end
        local weapon
        for _, child in pairs(localCharacter:GetChildren()) do
            if child:IsA("Tool") then
                weapon = child
                break
            end
        end
        if not weapon then
            return nil, nil
        end
        local settingsModule = weapon:FindFirstChild("Settings")
        if not settingsModule then
            return nil, nil
        end
        local settings = require(settingsModule)
        if not settings or type(settings) ~= "table" or not settings.Type then
            return nil, nil
        end
        return settings, weapon
    end

    local function getDistanceToPlayer(targetPlayer)
        local targetRootPart = targetPlayer.Character and targetPlayer.Character:FindFirstChild("HumanoidRootPart")
        if targetRootPart and localRootPart then
            local distance = (localRootPart.Position - targetRootPart.Position).Magnitude
            if distance == math.huge or distance ~= distance then
                return math.huge
            end
            return distance
        end
        return math.huge
    end

    local function getDmgPointDistance(targetPlayer, weapon)
        if not (weapon and targetPlayer.Character and localRootPart and localRootPart.Position) then
            return math.huge
        end
        local blade = weapon:FindFirstChild("Blade")
        if not blade or not blade:IsA("MeshPart") then
            return math.huge
        end
        local dmgPoint = blade:FindFirstChild("DmgPoint")
        if not dmgPoint or not dmgPoint:IsA("Attachment") then
            return math.huge
        end
        local distance = (localRootPart.Position - dmgPoint.WorldPosition).Magnitude
        if distance == math.huge or distance ~= distance then
            return math.huge
        end
        return distance
    end

    local function canTargetPlayer(targetPlayer, range, teamCheck)
        if not (localCharacter and localRootPart and localHumanoid and localHumanoid.Health > 0 and targetPlayer.Character) then
            return false
        end
        local targetRootPart = targetPlayer.Character:FindFirstChild("HumanoidRootPart")
        local targetHumanoid = targetPlayer.Character:FindFirstChild("Humanoid")
        if not (targetRootPart and targetHumanoid) or targetHumanoid.Health <= 0 or targetHumanoid:GetState() ~= Enum.HumanoidStateType.Running then
            return false
        end
        local distance = (localRootPart.Position - targetRootPart.Position).Magnitude
        if distance > range or distance == math.huge or distance ~= distance then
            return false
        end
        if teamCheck and targetPlayer.Team and LocalPlayer.Team then
            local localTeamName = LocalPlayer.Team.Name
            local targetTeamName = targetPlayer.Team.Name
            if localTeamName == targetTeamName and localTeamName ~= "Spectators" then
                return false
            elseif localTeamName == "Spectators" then
                return true
            elseif localTeamName == "Guesmand" then
                return targetTeamName == "Spectators" or targetTeamName == "Sunderland"
            elseif localTeamName == "Sunderland" then
                return targetTeamName == "Guesmand" or targetTeamName == "Spectators"
            end
            return false
        end
        return true
    end

    local function updateTargetHighlight(player)
        if not player or not player.Character then
            if targetHighlight then
                targetHighlight.Enabled = false
                currentTarget = nil
                Core.BulwarkTarget.CurrentTarget = nil
                Core.BulwarkTarget.UniversalTarget = nil
            end
            return
        end
        if player ~= currentTarget then
            if targetHighlight then
                targetHighlight:Destroy()
                targetHighlight = nil
            end
            currentTarget = player
            Core.BulwarkTarget.CurrentTarget = player.Name
            Core.BulwarkTarget.UniversalTarget = player.Name
            targetHighlight = Instance.new("Highlight")
            targetHighlight.Name = "TargetHighlight"
            targetHighlight.Parent = player.Character
            targetHighlight.Adornee = player.Character
            targetHighlight.FillTransparency = 0.5
            targetHighlight.OutlineTransparency = 0
        end
        local stance = getPlayerStance(player)
        if stance and (stance == "parrying" or stance == "block" or stance == "blocking") and State.KillAura.HighlightBlock.Value then
            targetHighlight.FillColor = State.KillAura.BlockColor.Value
            targetHighlight.Enabled = true
        elseif stance and stance == "riposte" and State.KillAura.HighlightParry.Value then
            targetHighlight.FillColor = State.KillAura.ParryColor.Value
            targetHighlight.Enabled = true
        else
            targetHighlight.FillColor = State.KillAura.DefaultColor.Value
            targetHighlight.Enabled = true
        end
    end

    local function removeTargetHighlight()
        if targetHighlight then
            targetHighlight.Enabled = false
            currentTarget = nil
            Core.BulwarkTarget.CurrentTarget = nil
            Core.BulwarkTarget.UniversalTarget = nil
        end
    end

    local function blockMouseButton1()
        ContextActionService:BindActionAtPriority("BlockMouseButton1", function()
            return Enum.ContextActionResult.Sink
        end, false, Enum.ContextActionPriority.High.Value, Enum.UserInputType.MouseButton1)
        warn("Blocking MouseButton1 for Riposte")
        task.spawn(function()
            while isRiposteActive and tick() <= riposteEndTime do
                task.wait()
            end
            isRiposteActive = false
            ContextActionService:UnbindAction("BlockMouseButton1")
            warn("MouseButton1 block ended")
        end)
    end

    local function updateWarningText(action, waitTime)
        if not State.AutoDodge.WarningText.Value or not warningTextLabel then
            warningTextLabel.Text = ""
            warningTextLabel.TextColor3 = Color3.fromRGB(255, 0, 0)
            return
        end
        local startTime = tick()
        local endTime = startTime + waitTime
        local riposteDuration = action == "Riposte" and State.AutoDodge.RiposteMouseLockDuration.Value or 0

        if action == "Parrying" then
            Core.BulwarkTarget.CombatState = "Parrying"
            warningTextLabel.TextColor3 = Color3.fromRGB(0, 255, 0)
            warningTextLabel.Text = string.format("Blocking | Start: %.2fs", waitTime)
            task.spawn(function()
                while tick() < endTime and warningTextLabel and State.AutoDodge.WarningText.Value do
                    local remaining = endTime - tick()
                    if remaining > 0 then
                        warningTextLabel.Text = string.format("Blocking | End: %.2fs", remaining)
                    end
                    task.wait()
                end
                if warningTextLabel and State.AutoDodge.WarningText.Value then
                    warningTextLabel.Text = "Nothing"
                    warningTextLabel.TextColor3 = Color3.fromRGB(255, 0, 0)
                    Core.BulwarkTarget.CombatState = nil
                end
            end)
        elseif action == "Riposte" then
            Core.BulwarkTarget.CombatState = "Riposte"
            warningTextLabel.TextColor3 = Color3.fromRGB(255, 165, 0)
            warningTextLabel.Text = string.format("Parrying | Start: %.2fs\nDONT PUNCH | %.2fs", waitTime, waitTime + riposteDuration)
            task.spawn(function()
                while tick() < endTime + riposteDuration and warningTextLabel and State.AutoDodge.WarningText.Value do
                    local remaining = endTime + riposteDuration - tick()
                    if remaining > 0 then
                        warningTextLabel.Text = string.format("Parrying | End: %.2fs\nDONT PUNCH | %.2fs", remaining, remaining)
                    end
                    task.wait()
                end
                if warningTextLabel and State.AutoDodge.WarningText.Value then
                    warningTextLabel.Text = "Nothing"
                    warningTextLabel.TextColor3 = Color3.fromRGB(255, 0, 0)
                    Core.BulwarkTarget.CombatState = nil
                end
            end)
        else
            warningTextLabel.Text = "Nothing"
            warningTextLabel.TextColor3 = Color3.fromRGB(255, 0, 0)
            Core.BulwarkTarget.CombatState = nil
        end
    end

    local function performDodgeAction(action, waitTime)
        if isPerformingAction or tick() - lastDodgeTime < State.AutoDodge.DodgeCooldown.Value then
            isDodgePending = false
            desiredDodgeAction = nil
            return false
        end
        isPerformingAction = true
        isDodgePending = true
        desiredDodgeAction = action
        if not (localHumanoid and localHumanoid.Health > 0) then
            isPerformingAction = false
            isDodgePending = false
            desiredDodgeAction = nil
            return false
        end
        if not table.find(VALID_HUMANOID_STATES, localHumanoid:GetState()) then
            isPerformingAction = false
            isDodgePending = false
            desiredDodgeAction = nil
            return false
        end
        local localWeapon
        for _, child in pairs(localCharacter:GetChildren()) do
            if child:IsA("Tool") then
                localWeapon = child
                break
            end
        end
        if not localWeapon then
            isPerformingAction = false
            isDodgePending = false
            desiredDodgeAction = nil
            return false
        end
        local localStance = getPlayerStance(LocalPlayer)
        if localStance and table.find(INVALID_STANCES, localStance) and not State.AutoDodge.IdleSpoof.Value then
            isPerformingAction = false
            isDodgePending = false
            desiredDodgeAction = nil
            return false
        end
        if waitTime == math.huge or waitTime ~= waitTime then
            waitTime = 0.3
            warn("Invalid waitTime, using fallback: 0.3")
        end
        if waitTime > State.AutoDodge.MaxWaitTime.Value then
            waitTime = 0.3
            warn("waitTime exceeded MaxWaitTime, using fallback: 0.3")
        end

        local animationTrack
        local settings, weapon = getLocalWeaponSettings()
        if settings then
            local animationsModule = ReplicatedStorage:FindFirstChild("ClientModule") and ReplicatedStorage.ClientModule:FindFirstChild("WeaponAnimations")
            if not animationsModule then
                warn("WeaponAnimations not found at ReplicatedStorage.ClientModule.WeaponAnimations")
            end
            local animations = animationsModule and require(animationsModule)[settings.Type]
            if not animations then
                warn("Animations not found for weapon type: " .. tostring(settings.Type))
            end
            if action == "Parrying" and State.AutoDodge.LegitBlock.Value and animations and animations.Parry then
                local animation = Instance.new("Animation")
                animation.AnimationId = "rbxassetid://" .. animations.Parry
                animationTrack = localHumanoid:LoadAnimation(animation)
                animationTrack:Play(0.1)
                animationTrack:AdjustSpeed(1)
                localHumanoid.WalkSpeed = 7
                print("Playing Parrying animation: " .. animations.Parry)
            elseif action == "Riposte" and State.AutoDodge.LegitParry.Value and animations and animations.Riposte then
                ChangeStance:FireServer("Riposte")
                blockMouseButton1()
                local animation = Instance.new("Animation")
                animation.AnimationId = "rbxassetid://" .. animations.Riposte
                animationTrack = localHumanoid:LoadAnimation(animation)
                animationTrack:Play(0.1)
                animationTrack:AdjustSpeed(0)
                localHumanoid.WalkSpeed = 1
                isRiposteActive = true
                riposteEndTime = tick() + waitTime + State.AutoDodge.RiposteMouseLockDuration.Value
                print("Playing Riposte animation: " .. animations.Riposte)
                task.spawn(function()
                    task.wait(0.5)
                    if animationTrack and animationTrack.IsPlaying and animationTrack.TimePosition == 0 then
                        animationTrack:Stop(0.7)
                    end
                end)
            end
        else
            warn("Settings or weapon not found for local player")
        end

        if action ~= "Riposte" then
            ChangeStance:FireServer(action)
        end
        updateWarningText(action, waitTime)
        task.wait(waitTime)
        if State.AutoDodge.IdleSpoof.Value then
            local currentStance = getPlayerStance(LocalPlayer)
            if currentStance and table.find(INVALID_STANCES, currentStance) then
                print("IdleSpoof: Restoring dodge action after stance change")
                ChangeStance:FireServer("Idle")
                if State.AutoDodge.UseClientIdle.Value and settings and settings.Type then
                    local animationsModule = ReplicatedStorage:FindFirstChild("ClientModule") and ReplicatedStorage.ClientModule:FindFirstChild("WeaponAnimations")
                    local animations = animationsModule and require(animationsModule)[settings.Type]
                    if animations and animations.Idle then
                        local idleAnimation = Instance.new("Animation")
                        idleAnimation.AnimationId = "rbxassetid://" .. animations.Idle
                        local idleAnimTrack = localHumanoid:LoadAnimation(idleAnimation)
                        idleAnimTrack:Play(0.1)
                        idleAnimTrack:AdjustSpeed(1)
                        print("Playing Client Idle animation: " .. animations.Idle)
                        task.spawn(function()
                            task.wait(0.5)
                            if idleAnimTrack and idleAnimTrack.IsPlaying then
                                idleAnimTrack:Stop(0.2)
                                idleAnimTrack:Destroy()
                            end
                        end)
                    end
                end
                task.wait(0.05)
                if desiredDodgeAction and not isPerformingAction then
                    ChangeStance:FireServer(desiredDodgeAction)
                end
            end
        end
        if action == "Riposte" then
            ChangeStance:FireServer("RiposteDelay")
            task.wait(0.7)
        else
            ChangeStance:FireServer("UnParry")
            task.wait(0.01)
        end

        if animationTrack then
            animationTrack:Stop(action == "Parrying" and 0.2 or 0.7)
            animationTrack:Destroy()
        end
        localHumanoid.WalkSpeed = 9

        ChangeStance:FireServer("Idle")
        if action == "Riposte" then
            task.wait(State.AutoDodge.RiposteMouseLockDuration.Value)
            isRiposteActive = false
        end
        lastDodgeTime = tick()
        isPerformingAction = false
        isDodgePending = false
        desiredDodgeAction = nil
        return true
    end

    local function collectDodgeData()
        while true do
            task.wait(State.AutoDodge.Delay.Value)
            localCharacter = LocalPlayer.Character
            localRootPart = localCharacter and localCharacter:FindFirstChild("HumanoidRootPart")
            localHumanoid = localCharacter and localCharacter:FindFirstChild("Humanoid")
            if not (localCharacter and localRootPart and localHumanoid and localHumanoid.Health > 0) then
                closestTarget = nil
                lastStance = nil
                lastTargetWeapon = nil
                lastReleaseTime = nil
                Core.BulwarkTarget.UniversalTarget = nil
                continue
            end
            closestTarget = nil
            local minDistance = math.huge
            for _, player in pairs(Players:GetPlayers()) do
                if player ~= LocalPlayer and canTargetPlayer(player, State.AutoDodge.PreRange.Value, State.AutoDodge.TeamCheck.Value) then
                    local distance = getDistanceToPlayer(player)
                    if distance < minDistance then
                        minDistance = distance
                        closestTarget = player
                    end
                end
            end
            if closestTarget then
                Core.BulwarkTarget.UniversalTarget = closestTarget.Name
                local weapon, settings = getTargetWeaponSettings(closestTarget)
                if weapon and settings and settings.Release then
                    lastTargetWeapon = weapon
                    lastReleaseTime = math.max(0.1, settings.Release - 0.1)
                else
                    lastTargetWeapon = nil
                    lastReleaseTime = nil
                end
            else
                lastTargetWeapon = nil
                lastReleaseTime = nil
                Core.BulwarkTarget.UniversalTarget = nil
            end
        end
    end

    local function runAutoDodge()
        while true do
            task.wait(State.AutoDodge.Delay.Value)
            if not State.AutoDodge.Enabled.Value then
                Core.BulwarkTarget.isAutoDodge = false
                isDodgePending = false
                desiredDodgeAction = nil
                Core.BulwarkTarget.CombatState = nil
                continue
            end
            Core.BulwarkTarget.isAutoDodge = true
            if not (localCharacter and localRootPart and localHumanoid and localHumanoid.Health > 0) then
                isDodgePending = false
                desiredDodgeAction = nil
                Core.BulwarkTarget.CombatState = nil
                continue
            end
            if tick() - lastDodgeTime < State.AutoDodge.DodgeCooldown.Value then
                isDodgePending = false
                desiredDodgeAction = nil
                continue
            end
            if not closestTarget or not canTargetPlayer(closestTarget, State.AutoDodge.Range.Value, State.AutoDodge.TeamCheck.Value) then
                lastStance = nil
                isDodgePending = false
                desiredDodgeAction = nil
                Core.BulwarkTarget.CombatState = nil
                continue
            end
            local targetCharacter = closestTarget.Character
            local targetHumanoid = targetCharacter and targetCharacter:FindFirstChild("Humanoid")
            if not (targetCharacter and targetHumanoid and targetHumanoid.Health > 0) then
                lastStance = nil
                isDodgePending = false
                desiredDodgeAction = nil
                Core.BulwarkTarget.CombatState = nil
                continue
            end
            local stance = getPlayerStance(closestTarget)
            if stance and stance ~= lastStance then
                if stance == "release" and State.AutoDodge.Blocking.Value then
                    if math.random() < State.AutoDodge.MissChance.Value then
                        print("Missed action due to MISS_CHANCE: " .. State.AutoDodge.MissChance.Value)
                        lastStance = stance
                        isDodgePending = false
                        desiredDodgeAction = nil
                        Core.BulwarkTarget.CombatState = nil
                        continue
                    end
                    local localStance = getPlayerStance(LocalPlayer)
                    if State.AutoDodge.IdleSpoof.Value and localStance and table.find(INVALID_STANCES, localStance) then
                        print("IdleSpoof activated, sent ChangeStance('Idle')")
                        ChangeStance:FireServer("Idle")
                        if State.AutoDodge.UseClientIdle.Value then
                            local settings, weapon = getLocalWeaponSettings()
                            if settings and settings.Type then
                                local animationsModule = ReplicatedStorage:FindFirstChild("ClientModule") and ReplicatedStorage.ClientModule:FindFirstChild("WeaponAnimations")
                                local animations = animationsModule and require(animationsModule)[settings.Type]
                                if animations and animations.Idle then
                                    local idleAnimation = Instance.new("Animation")
                                    idleAnimation.AnimationId = "rbxassetid://" .. animations.Idle
                                    local idleAnimTrack = localHumanoid:LoadAnimation(idleAnimation)
                                    idleAnimTrack:Play(0.1)
                                    idleAnimTrack:AdjustSpeed(1)
                                    print("Playing Client Idle animation: " .. animations.Idle)
                                    task.spawn(function()
                                        task.wait(0.5)
                                        if idleAnimTrack and idleAnimTrack.IsPlaying then
                                            idleAnimTrack:Stop(0.2)
                                            idleAnimTrack:Destroy()
                                        end
                                    end)
                                end
                            end
                        end
                        task.wait(0.05)
                    end
                    local releaseTime = lastReleaseTime or 0.3
                    local dmgPointDistance = lastTargetWeapon and getDmgPointDistance(closestTarget, lastTargetWeapon) or getDistanceToPlayer(closestTarget)
                    local waitTime
                    if type(releaseTime) == "number" and releaseTime > 0 and dmgPointDistance ~= math.huge and dmgPointDistance == dmgPointDistance then
                        waitTime = math.max(0.1, releaseTime * (State.AutoDodge.BaseMultiplier.Value + dmgPointDistance * State.AutoDodge.DistanceFactor.Value))
                        if waitTime > State.AutoDodge.MaxWaitTime.Value then
                            waitTime = releaseTime / 2
                            warn("Complex waitTime calculation failed, using fallback: releaseTime / 2 = " .. waitTime)
                        end
                    else
                        waitTime = releaseTime / 2
                        warn("Invalid releaseTime or dmgPointDistance, using fallback: releaseTime / 2 = " .. waitTime)
                    end
                    local action
                    if State.AutoDodge.BlockingMode.Value == "Riposte" then
                        if math.random() < State.AutoDodge.MissChance.Value then
                            print("Missed Riposte due to MISS_CHANCE: " .. State.AutoDodge.MissChance.Value)
                            lastStance = stance
                            isDodgePending = false
                            desiredDodgeAction = nil
                            Core.BulwarkTarget.CombatState = nil
                            continue
                        end
                        action = "Riposte"
                    elseif State.AutoDodge.BlockingMode.Value == "Parrying" then
                        if math.random() < State.AutoDodge.MissChance.Value then
                            print("Missed Parrying due to MISS_CHANCE: " .. State.AutoDodge.MissChance.Value)
                            lastStance = stance
                            isDodgePending = false
                            desiredDodgeAction = nil
                            Core.BulwarkTarget.CombatState = nil
                            continue
                        end
                        action = "Parrying"
                    elseif State.AutoDodge.BlockingMode.Value == "Chance" then
                        local totalChance = State.AutoDodge.ParryingChance.Value + State.AutoDodge.RiposteChance.Value
                        local normalizedParryChance = totalChance > 0 and (State.AutoDodge.ParryingChance.Value / totalChance) or 0.5
                        local rand = math.random()
                        if rand < State.AutoDodge.MissChance.Value then
                            print("Missed action due to MISS_CHANCE: " .. State.AutoDodge.MissChance.Value)
                            lastStance = stance
                            isDodgePending = false
                            desiredDodgeAction = nil
                            Core.BulwarkTarget.CombatState = nil
                            continue
                        elseif rand < normalizedParryChance * (1 - State.AutoDodge.MissChance.Value) then
                            action = "Parrying"
                        else
                            action = "Riposte"
                        end
                    end
                    if performDodgeAction(action, waitTime) then
                        lastDodgeTime = tick()
                    end
                elseif stance == "punching" and State.AutoDodge.Blocking.Value and State.AutoDodge.BlockingAntiStun.Value then
                    ChangeStance:FireServer("UnParry")
                    task.wait(0.01)
                    ChangeStance:FireServer("Idle")
                    if State.AutoDodge.UseClientIdle.Value then
                        local settings, weapon = getLocalWeaponSettings()
                        if settings and settings.Type then
                            local animationsModule = ReplicatedStorage:FindFirstChild("ClientModule") and ReplicatedStorage.ClientModule:FindFirstChild("WeaponAnimations")
                            local animations = animationsModule and require(animationsModule)[settings.Type]
                            if animations and animations.Idle then
                                local idleAnimation = Instance.new("Animation")
                                idleAnimation.AnimationId = "rbxassetid://" .. animations.Idle
                                local idleAnimTrack = localHumanoid:LoadAnimation(idleAnimation)
                                idleAnimTrack:Play(0.1)
                                idleAnimTrack:AdjustSpeed(1)
                                print("Playing Client Idle animation: " .. animations.Idle)
                                task.spawn(function()
                                    task.wait(0.5)
                                    if idleAnimTrack and idleAnimTrack.IsPlaying then
                                        idleAnimTrack:Stop(0.2)
                                        idleAnimTrack:Destroy()
                                    end
                                end)
                            end
                        end
                    end
                    localHumanoid.WalkSpeed = 9
                    lastDodgeTime = tick()
                    isDodgePending = false
                    desiredDodgeAction = nil
                    Core.BulwarkTarget.CombatState = nil
                end
            end
            lastStance = stance
        end
    end

    local function performPunch(targetPlayer, targetCharacter, weapon)
        local targetHumanoid = targetCharacter:FindFirstChild("Humanoid")
        if not targetHumanoid then
            return false
        end
        local stance = getPlayerStance(targetPlayer)
        if not stance or not ((stance == "parrying" or stance == "block" or stance == "blocking") and State.KillAura.AntiBlock.Value) then
            return false
        end
        Core.BulwarkTarget.CombatState = "KillAura"
        ChangeStance:FireServer("Punching")
        task.wait(State.KillAura.KickDelay.Value)
        if not targetCharacter or not targetCharacter.Parent or not targetCharacter:FindFirstChild("Humanoid") then
            Core.BulwarkTarget.CombatState = nil
            return false
        end
        stance = getPlayerStance(targetPlayer)
        if not stance or not ((stance == "parrying" or stance == "block" or stance == "blocking") and State.KillAura.AntiBlock.Value) then
            Core.BulwarkTarget.CombatState = nil
            return false
        end
        local targetHandle = targetCharacter:FindFirstChild("HumanoidRootPart")
        if not (weapon and targetHandle) then
            Core.BulwarkTarget.CombatState = nil
            return false
        end
        Punch:FireServer(weapon, targetHandle, targetHumanoid)
        Core.BulwarkTarget.CombatState = nil
        return true
    end

    local function performKick(targetPlayer, targetCharacter, weapon)
        local targetHumanoid = targetCharacter:FindFirstChild("Humanoid")
        if not targetHumanoid then
            return false
        end
        local stance = getPlayerStance(targetPlayer)
        if not stance or stance ~= "riposte" or not State.KillAura.AntiParry.Value then
            return false
        end
        Core.BulwarkTarget.CombatState = "KillAura"
        ChangeStance:FireServer("KickWindup")
        task.wait(State.KillAura.KickDelay.Value)
        if not targetCharacter or not targetCharacter.Parent or not targetCharacter:FindFirstChild("Humanoid") then
            Core.BulwarkTarget.CombatState = nil
            return false
        end
        stance = getPlayerStance(targetPlayer)
        if not stance or stance ~= "riposte" or not State.KillAura.AntiParry.Value then
            Core.BulwarkTarget.CombatState = nil
            return false
        end
        ChangeStance:FireServer("Kicking")
        task.wait(State.KillAura.KickStateDelay.Value)
        if not targetCharacter or not targetCharacter.Parent or not targetCharacter:FindFirstChild("Humanoid") then
            Core.BulwarkTarget.CombatState = nil
            return false
        end
        stance = getPlayerStance(targetPlayer)
        if not stance or stance ~= "riposte" or not State.KillAura.AntiParry.Value then
            Core.BulwarkTarget.CombatState = nil
            return false
        end
        local targetHandle = targetCharacter:FindFirstChild("CollisionBubble") or targetCharacter:FindFirstChild("HumanoidRootPart")
        if not targetHandle then
            Core.BulwarkTarget.CombatState = nil
            return false
        end
        Kick:FireServer(weapon, targetHandle, targetHumanoid)
        Core.BulwarkTarget.CombatState = nil
        return true
    end

    local function performAutoKick(targetPlayer, targetCharacter, weapon)
        if not State.LegitHelper.Enabled.Value or not State.LegitHelper.AutoKick.Value then
            return false
        end
        if tick() - lastKickTime < kickCooldown then
            return false
        end
        local targetHumanoid = targetCharacter:FindFirstChild("Humanoid")
        if not targetHumanoid or targetHumanoid.Health <= 0 then
            return false
        end
        local localStance = getPlayerStance(LocalPlayer)
        if localStance and table.find(INVALID_STANCES, localStance) then
            return false
        end
        local stance = getPlayerStance(targetPlayer)
        if not stance or stance ~= "windup" then
            return false
        end
        local settings = getWeaponSettings()
        if not settings or not settings.Type then
            return false
        end
        local animationsModule = ReplicatedStorage:FindFirstChild("ClientModule") and ReplicatedStorage.ClientModule:FindFirstChild("WeaponAnimations")
        if not animationsModule then
            warn("WeaponAnimations not found at ReplicatedStorage.ClientModule.WeaponAnimations")
            return false
        end
        local animations = animationsModule and require(animationsModule)[settings.Type]
        if not animations then
            warn("Animations not found for weapon type: " .. tostring(settings.Type))
            return false
        end

        Core.BulwarkTarget.CombatState = "AutoKick"
        Core.BulwarkTarget.UniversalTarget = targetPlayer.Name
        if State.LegitHelper.LegitKick.Value then
            localHumanoid.WalkSpeed = 1
            ChangeStance:FireServer("KickWindup")
            local kickAnimation = Instance.new("Animation")
            kickAnimation.AnimationId = "rbxassetid://" .. animations.Kick
            local kickAnimTrack = localHumanoid:LoadAnimation(kickAnimation)
            kickAnimTrack:Play(0.05, 1, kickAnimTrack.Length / 0.5)
            print("Playing Kick animation: " .. animations.Kick)
            kickAnimTrack:GetMarkerReachedSignal("Kick"):Wait()
            if not targetCharacter or not targetCharacter.Parent or not targetCharacter:FindFirstChild("Humanoid") then
                kickAnimTrack:Stop()
                kickAnimTrack:Destroy()
                localHumanoid.WalkSpeed = 9
                lastKickTime = tick()
                Core.BulwarkTarget.CombatState = nil
                return false
            end
            stance = getPlayerStance(targetPlayer)
            if not stance or stance ~= "windup" then
                kickAnimTrack:Stop()
                kickAnimTrack:Destroy()
                localHumanoid.WalkSpeed = 9
                lastKickTime = tick()
                Core.BulwarkTarget.CombatState = nil
                return false
            end
            ChangeStance:FireServer("Kicking")
            localHumanoid.WalkSpeed = 5
            local targetHandle = targetCharacter:FindFirstChild("CollisionBubble") or targetCharacter:FindFirstChild("HumanoidRootPart")
            if not targetHandle then
                kickAnimTrack:Stop()
                kickAnimTrack:Destroy()
                localHumanoid.WalkSpeed = 9
                lastKickTime = tick()
                Core.BulwarkTarget.CombatState = nil
                return false
            end
            Kick:FireServer(weapon, targetHandle, targetHumanoid)
            warn("AutoKick: Performed kick on target in Windup")
            kickAnimTrack.Stopped:Wait()
            task.wait(0.1)
            ChangeStance:FireServer("Idle")
            localHumanoid.WalkSpeed = 9
            kickAnimTrack:Destroy()
            lastKickTime = tick()
            Core.BulwarkTarget.CombatState = nil
            return true
        else
            ChangeStance:FireServer("KickWindup")
            task.wait(State.KillAura.KickDelay.Value / 2)
            if not targetCharacter or not targetCharacter.Parent or not targetCharacter:FindFirstChild("Humanoid") then
                localHumanoid.WalkSpeed = 9
                lastKickTime = tick()
                Core.BulwarkTarget.CombatState = nil
                return false
            end
            stance = getPlayerStance(targetPlayer)
            if not stance or stance ~= "windup" then
                localHumanoid.WalkSpeed = 9
                lastKickTime = tick()
                Core.BulwarkTarget.CombatState = nil
                return false
            end
            ChangeStance:FireServer("Kicking")
            task.wait(State.KillAura.KickStateDelay.Value / 2)
            if not targetCharacter or not targetCharacter.Parent or not targetCharacter:FindFirstChild("Humanoid") then
                localHumanoid.WalkSpeed = 9
                lastKickTime = tick()
                Core.BulwarkTarget.CombatState = nil
                return false
            end
            stance = getPlayerStance(targetPlayer)
            if not stance or stance ~= "windup" then
                localHumanoid.WalkSpeed = 9
                lastKickTime = tick()
                Core.BulwarkTarget.CombatState = nil
                return false
            end
            local targetHandle = targetCharacter:FindFirstChild("CollisionBubble") or targetCharacter:FindFirstChild("HumanoidRootPart")
            if not targetHandle then
                localHumanoid.WalkSpeed = 9
                lastKickTime = tick()
                Core.BulwarkTarget.CombatState = nil
                return false
            end
            Kick:FireServer(weapon, targetHandle, targetHumanoid)
            warn("AutoKick: Performed kick on target in Windup")
            localHumanoid.WalkSpeed = 9
            lastKickTime = tick()
            Core.BulwarkTarget.CombatState = nil
            return true
        end
    end

    local function runAutoKick()
        while true do
            RunService.Heartbeat:Wait()
            if not State.LegitHelper.Enabled.Value or not State.LegitHelper.AutoKick.Value then
                Core.BulwarkTarget.isAutoKick = false
                Core.BulwarkTarget.CombatState = nil
                continue
            end
            Core.BulwarkTarget.isAutoKick = true
            localCharacter = LocalPlayer.Character
            localRootPart = localCharacter and localCharacter:FindFirstChild("HumanoidRootPart")
            localHumanoid = localCharacter and localCharacter:FindFirstChild("Humanoid")
            if not (localCharacter and localRootPart and localHumanoid) then
                Core.BulwarkTarget.CombatState = nil
                continue
            end
            local settings = getWeaponSettings()
            if not settings or not settings.weapon then
                Core.BulwarkTarget.CombatState = nil
                continue
            end
            local closestTarget = nil
            local minDistance = math.huge
            for _, player in pairs(Players:GetPlayers()) do
                if player ~= LocalPlayer and canTargetPlayer(player, State.LegitHelper.Range.Value, State.LegitHelper.TeamCheck.Value) then
                    local distance = getDistanceToPlayer(player)
                    if distance < minDistance then
                        minDistance = distance
                        closestTarget = player
                    end
                end
            end
            if not closestTarget then
                Core.BulwarkTarget.CombatState = nil
                continue
            end
            local targetCharacter = closestTarget.Character
            local targetHumanoid = targetCharacter and targetCharacter:FindFirstChild("Humanoid")
            if not (targetCharacter and targetHumanoid) then
                Core.BulwarkTarget.CombatState = nil
                continue
            end
            if performAutoKick(closestTarget, targetCharacter, settings.weapon) then
                lastKickTime = tick()
            end
        end
    end

    local function runKillAura()
        task.spawn(collectDodgeData)
        task.spawn(runAutoDodge)
        task.spawn(runAutoKick)
        while true do
            RunService.Heartbeat:Wait()
            if not State.KillAura.Enabled.Value then
                Core.BulwarkTarget.isKillAura = false
                removeTargetHighlight()
                Core.BulwarkTarget.CombatState = nil
                continue
            end
            Core.BulwarkTarget.isKillAura = true
            localCharacter = LocalPlayer.Character
            localRootPart = localCharacter and localCharacter:FindFirstChild("HumanoidRootPart")
            localHumanoid = localCharacter and localCharacter:FindFirstChild("Humanoid")
            if not (localCharacter and localRootPart and localHumanoid) then
                removeTargetHighlight()
                Core.BulwarkTarget.CombatState = nil
                continue
            end
            local settings = getWeaponSettings()
            if not settings or not settings.weapon then
                removeTargetHighlight()
                Core.BulwarkTarget.CombatState = nil
                continue
            end
            if tick() - lastAttackTime < State.KillAura.AttackCooldown.Value then
                continue
            end
            local closestKillAuraTarget = nil
            local minDistance = math.huge
            for _, player in pairs(Players:GetPlayers()) do
                if player ~= LocalPlayer and canTargetPlayer(player, State.KillAura.Range.Value, State.KillAura.TeamCheck.Value) then
                    local distance = getDistanceToPlayer(player)
                    if distance < minDistance then
                        minDistance = distance
                        closestKillAuraTarget = player
                    end
                end
            end
            if not closestKillAuraTarget then
                removeTargetHighlight()
                Core.BulwarkTarget.CombatState = nil
                continue
            end
            local targetCharacter = closestKillAuraTarget.Character
            local targetHumanoid = targetCharacter and targetCharacter:FindFirstChild("Humanoid")
            if not (targetCharacter and targetHumanoid) then
                removeTargetHighlight()
                Core.BulwarkTarget.CombatState = nil
                continue
            end
            updateTargetHighlight(closestKillAuraTarget)
            local stance = getPlayerStance(closestKillAuraTarget)
            if State.AutoDodge.KillAuraSync.Value and stance == "release" and State.AutoDodge.Enabled.Value and isDodgePending then
                Core.BulwarkTarget.CombatState = nil
                continue
            end
            local attacked = false
            if stance then
                if (stance == "parrying" or stance == "block" or stance == "blocking") and State.KillAura.AntiBlock.Value then
                    attacked = performPunch(closestKillAuraTarget, targetCharacter, settings.weapon)
                elseif stance == "riposte" and State.KillAura.AntiParry.Value then
                    attacked = performKick(closestKillAuraTarget, targetCharacter, settings.weapon)
                end
            end
            if not attacked then
                if State.KillAura.DynamicCooldown.Value then
                    local cooldown = (stance == "riposte") and math.max(table.unpack(State.KillAura.CooldownValues.Value)) or State.KillAura.CooldownValues.Value[math.random(1, #State.KillAura.CooldownValues.Value)]
                    warn("Dynamic Cooldown: Waiting " .. cooldown .. " seconds before attack")
                    task.wait(cooldown)
                end
                Core.BulwarkTarget.CombatState = "KillAura"
                ChangeStance:FireServer("Windup")
                task.wait(settings.windupTime)
                if not targetCharacter or not targetCharacter.Parent or not targetCharacter:FindFirstChild("Humanoid") then
                    removeTargetHighlight()
                    warn("Attack cancelled due to Riposte")
                    Core.BulwarkTarget.CombatState = nil
                    continue
                end
                stance = getPlayerStance(closestKillAuraTarget)
                if State.AutoDodge.KillAuraSync.Value and stance == "release" and State.AutoDodge.Enabled.Value and isDodgePending then
                    Core.BulwarkTarget.CombatState = nil
                    continue
                end
                if stance and ((stance == "parrying" or stance == "block" or stance == "blocking") and State.KillAura.AntiBlock.Value or (stance == "riposte" and State.KillAura.AntiParry.Value)) then
                    removeTargetHighlight()
                    warn("Attack cancelled due to Riposte")
                    Core.BulwarkTarget.CombatState = nil
                    continue
                end
                ChangeStance:FireServer("Release")
                task.wait(settings.releaseTime)
                if not targetCharacter or not targetCharacter.Parent or not targetCharacter:FindFirstChild("Humanoid") then
                    removeTargetHighlight()
                    warn("Attack cancelled due to Riposte")
                    Core.BulwarkTarget.CombatState = nil
                    continue
                end
                stance = getPlayerStance(closestKillAuraTarget)
                if State.AutoDodge.KillAuraSync.Value and stance == "release" and State.AutoDodge.Enabled.Value and isDodgePending then
                    Core.BulwarkTarget.CombatState = nil
                    continue
                end
                if stance and ((stance == "parrying" or stance == "block" or stance == "blocking") and State.KillAura.AntiBlock.Value or (stance == "riposte" and State.KillAura.AntiParry.Value)) then
                    removeTargetHighlight()
                    warn("Attack cancelled due to Riposte")
                    Core.BulwarkTarget.CombatState = nil
                    continue
                end
                local targetHandle = targetCharacter:FindFirstChildOfClass("Accessory") and 
                    targetCharacter:FindFirstChildOfClass("Accessory"):FindFirstChild("Handle") or 
                    targetCharacter:FindFirstChild("HumanoidRootPart")
                if not targetHandle then
                    removeTargetHighlight()
                    warn("Attack cancelled due to Riposte")
                    Core.BulwarkTarget.CombatState = nil
                    continue
                end
                Hit:FireServer(settings.weapon, targetHandle, targetHumanoid)
                attacked = true
                Core.BulwarkTarget.CombatState = nil
            end
            if attacked then
                lastAttackTime = tick()
            else
                removeTargetHighlight()
                Core.BulwarkTarget.CombatState = nil
            end
        end
    end

    Players.PlayerRemoving:Connect(function(player)
        if currentTarget == player then
            removeTargetHighlight()
        end
        if closestTarget == player then
            closestTarget = nil
            lastStance = nil
            lastTargetWeapon = nil
            lastReleaseTime = nil
            isDodgePending = false
            desiredDodgeAction = nil
            Core.BulwarkTarget.UniversalTarget = nil
        end
    end)

    local function onCharacterAdded(player)
        player.CharacterAdded:Connect(function(character)
            local humanoid = character:WaitForChild("Humanoid", 5)
            if humanoid then
                humanoid.Died:Connect(function()
                    if currentTarget == player then
                        removeTargetHighlight()
                    end
                    if closestTarget == player then
                        closestTarget = nil
                        lastStance = nil
                        lastTargetWeapon = nil
                        lastReleaseTime = nil
                        isDodgePending = false
                        desiredDodgeAction = nil
                        Core.BulwarkTarget.UniversalTarget = nil
                    end
                end)
            end
        end)
    end

    for _, player in pairs(Players:GetPlayers()) do
        onCharacterAdded(player)
    end
    Players.PlayerAdded:Connect(onCharacterAdded)

    local function setupWarningText()
        local screenGui = Instance.new("ScreenGui")
        screenGui.Name = "AutoDodgeWarning"
        screenGui.Parent = game:GetService("CoreGui")
        screenGui.IgnoreGuiInset = true

        warningTextLabel = Instance.new("TextLabel")
        warningTextLabel.Name = "WarningText"
        warningTextLabel.Size = UDim2.new(0, 200 * State.AutoDodge.WarningTextScale.Value, 0, 100 * State.AutoDodge.WarningTextScale.Value)
        warningTextLabel.Position = State.AutoDodge.WarningTextPosition.Value
        warningTextLabel.BackgroundTransparency = 1
        warningTextLabel.TextColor3 = Color3.fromRGB(255, 0, 0)
        warningTextLabel.TextScaled = true
        warningTextLabel.TextTransparency = 0
        warningTextLabel.Font = Enum.Font.SourceSansBold
        warningTextLabel.Text = "Nothing"
        warningTextLabel.Parent = screenGui

        warningTextLabel.InputBegan:Connect(function(input)
            if input.UserInputType == Enum.UserInputType.MouseButton1 then
                isDragging = true
                dragStart = input.Position
                startPos = warningTextLabel.Position
            end
        end)

        warningTextLabel.InputChanged:Connect(function(input)
            if isDragging and input.UserInputType == Enum.UserInputType.MouseMovement then
                local delta = input.Position - dragStart
                local newPos = UDim2.new(
                    startPos.X.Scale,
                    startPos.X.Offset + delta.X,
                    startPos.Y.Scale,
                    startPos.Y.Offset + delta.Y
                )
                warningTextLabel.Position = newPos
                State.AutoDodge.WarningTextPosition.Value = newPos
            end
        end)

        warningTextLabel.InputEnded:Connect(function(input)
            if input.UserInputType == Enum.UserInputType.MouseButton1 then
                isDragging = false
            end
        end)
    end

    local function toggleWarningText(value)
        if value and not warningTextLabel then
            setupWarningText()
        elseif not value and warningTextLabel then
            warningTextLabel.Parent:Destroy()
            warningTextLabel = nil
        end
    end

    task.spawn(runKillAura)

    if UI.Tabs and UI.Tabs.Combat then
        UI.Sections.KillAura = UI.Sections.KillAura or UI.Tabs.Combat:Section({ Name = "KillAura", Side = "Left" })
        UI.Sections.KillAura:Header({ Name = "KillAura" })
        UI.Sections.KillAura:Toggle({
            Name = "Enabled",
            Default = State.KillAura.Enabled.Default,
            Callback = function(value)
                State.KillAura.Enabled.Value = value
                Core.BulwarkTarget.isKillAura = value
                if tick() - lastNotificationTime >= notificationDelay then
                    lastNotificationTime = tick()
                    notify("KillAura", "KillAura " .. (value and "Enabled" or "Disabled"), true)
                end
            end,
            'EnabledKA'
        })
        UI.Sections.KillAura:Slider({
            Name = "Range",
            Minimum = 4,
            Maximum = 20,
            Default = State.KillAura.Range.Default,
            Precision = 0,
            Callback = function(value)
                State.KillAura.Range.Value = value
                if tick() - lastNotificationTime >= notificationDelay then
                    lastNotificationTime = tick()
                    notify("KillAura", "Range set to: " .. value)
                end
            end,
            'RangeKA'
        })
        UI.Sections.KillAura:Slider({
            Name = "Attack Cooldown",
            Minimum = 0.1,
            Maximum = 0.5,
            Default = State.KillAura.AttackCooldown.Default,
            Precision = 2,
            Callback = function(value)
                State.KillAura.AttackCooldown.Value = value
                if tick() - lastNotificationTime >= notificationDelay then
                    lastNotificationTime = tick()
                    notify("KillAura", "Attack Cooldown set to: " .. value)
                end
            end,
            'AttackCooldownKA'
        })
        UI.Sections.KillAura:Divider()
        UI.Sections.KillAura:Toggle({
            Name = "Anti Block",
            Default = State.KillAura.AntiBlock.Default,
            Callback = function(value)
                State.KillAura.AntiBlock.Value = value
                if tick() - lastNotificationTime >= notificationDelay then
                    lastNotificationTime = tick()
                    notify("KillAura", "Anti Block " .. (value and "Enabled" or "Disabled"), true)
                end
            end,
            'AntiBlockKA'
        })
        UI.Sections.KillAura:Toggle({
            Name = "Anti Parry",
            Default = State.KillAura.AntiParry.Default,
            Callback = function(value)
                State.KillAura.AntiParry.Value = value
                if tick() - lastNotificationTime >= notificationDelay then
                    lastNotificationTime = tick()
                    notify("KillAura", "Anti Parry " .. (value and "Enabled" or "Disabled"), true)
                end
            end,
            'AntiParryKA'
        })
        UI.Sections.KillAura:Divider()

        UI.Sections.KillAura:Toggle({
            Name = "Highlight Block",
            Default = State.KillAura.HighlightBlock.Default,
            Callback = function(value)
                State.KillAura.HighlightBlock.Value = value
                if tick() - lastNotificationTime >= notificationDelay then
                    lastNotificationTime = tick()
                    notify("KillAura", "Highlight Block " .. (value and "Enabled" or "Disabled"), true)
                end
            end,
            'HighlightBlockKA'
        })
        UI.Sections.KillAura:Toggle({
            Name = "Highlight Parry",
            Default = State.KillAura.HighlightParry.Default,
            Callback = function(value)
                State.KillAura.HighlightParry.Value = value
                if tick() - lastNotificationTime >= notificationDelay then
                    lastNotificationTime = tick()
                    notify("KillAura", "Highlight Parry " .. (value and "Enabled" or "Disabled"), true)
                end
            end,
            'HighlightParryKA'
        })
        UI.Sections.KillAura:Divider()

        UI.Sections.KillAura:Colorpicker({
            Name = "Parry Color",
            Default = State.KillAura.ParryColor.Default,
            Callback = function(value)
                State.KillAura.ParryColor.Value = value
                if tick() - lastNotificationTime >= notificationDelay then
                    lastNotificationTime = tick()
                    notify("KillAura", "Parry Color set to: R=" .. math.floor(value.R * 255) .. ", G=" .. math.floor(value.G * 255) .. ", B=" .. math.floor(value.B * 255))
                end
            end,
            'ParryColorKA'
        })
        UI.Sections.KillAura:Colorpicker({
            Name = "Block Color",
            Default = State.KillAura.BlockColor.Default,
            Callback = function(value)
                State.KillAura.BlockColor.Value = value
                if tick() - lastNotificationTime >= notificationDelay then
                    lastNotificationTime = tick()
                    notify("KillAura", "Block Color set to: R=" .. math.floor(value.R * 255) .. ", G=" .. math.floor(value.G * 255) .. ", B=" .. math.floor(value.B * 255))
                end
            end,
            'BlockColorKA'
        })
        UI.Sections.KillAura:Colorpicker({
            Name = "Default Color",
            Default = State.KillAura.DefaultColor.Default,
            Callback = function(value)
                State.KillAura.DefaultColor.Value = value
                if tick() - lastNotificationTime >= notificationDelay then
                    lastNotificationTime = tick()
                    notify("KillAura", "Default Color set to: R=" .. math.floor(value.R * 255) .. ", G=" .. math.floor(value.G * 255) .. ", B=" .. math.floor(value.B * 255))
                end
            end,
            'DefaultColorKA'
        })

        UI.Sections.LegitHelper = UI.Sections.LegitHelper or UI.Tabs.Combat:Section({ Name = "LegitHelper", Side = "Left" })
        UI.Sections.LegitHelper:Header({ Name = "Legit Helper" })
        UI.Sections.LegitHelper:Toggle({
            Name = "Enabled",
            Default = State.LegitHelper.Enabled.Default,
            Callback = function(value)
                State.LegitHelper.Enabled.Value = value
                if tick() - lastNotificationTime >= notificationDelay then
                    lastNotificationTime = tick()
                    notify("LegitHelper", "LegitHelper " .. (value and "Enabled" or "Disabled"), true)
                end
            end,
            'EnabledLH'
        })
        UI.Sections.LegitHelper:Divider()
        UI.Sections.LegitHelper:Label({ Text = "Auto Kick"})
        UI.Sections.LegitHelper:Toggle({
            Name = "Enabled",
            Default = State.LegitHelper.AutoKick.Default,
            Callback = function(value)
                State.LegitHelper.AutoKick.Value = value
                Core.BulwarkTarget.isAutoKick = value
                if tick() - lastNotificationTime >= notificationDelay then
                    lastNotificationTime = tick()
                    notify("LegitHelper", "AutoKick " .. (value and "Enabled" or "Disabled"), true)
                end
            end,
            'AutoKickLH'
        })
        UI.Sections.LegitHelper:Slider({
            Name = "Range",
            Minimum = 2,
            Maximum = 20,
            Default = State.LegitHelper.Range.Default,
            Precision = 0,
            Callback = function(value)
                State.LegitHelper.Range.Value = value
                if tick() - lastNotificationTime >= notificationDelay then
                    lastNotificationTime = tick()
                    notify("LegitHelper", "Range set to: " .. value)
                end
            end,
            'RangeLH'
        })
        UI.Sections.LegitHelper:Toggle({
            Name = "Team Check",
            Default = State.LegitHelper.TeamCheck.Default,
            Callback = function(value)
                State.LegitHelper.TeamCheck.Value = value
                if tick() - lastNotificationTime >= notificationDelay then
                    lastNotificationTime = tick()
                    notify("LegitHelper", "Team Check " .. (value and "Enabled" or "Disabled"), true)
                end
            end,
            'TeamCheckLH'
        })
        UI.Sections.LegitHelper:Toggle({
            Name = "KillAura Sync",
            Default = State.LegitHelper.AutoDodgeSync.Default,
            Callback = function(value)
                State.LegitHelper.AutoDodgeSync.Value = value
                if tick() - lastNotificationTime >= notificationDelay then
                    lastNotificationTime = tick()
                    notify("LegitHelper", "KillAura Sync " .. (value and "Enabled" or "Disabled"), true)
                end
            end,
            'KillAuraSyncLH'
        })
        UI.Sections.LegitHelper:Toggle({
            Name = "Legit Kick",
            Default = State.LegitHelper.LegitKick.Default,
            Callback = function(value)
                State.LegitHelper.LegitKick.Value = value
                if tick() - lastNotificationTime >= notificationDelay then
                    lastNotificationTime = tick()
                    notify("LegitHelper", "Legit Kick " .. (value and "Enabled" or "Disabled"), true)
                end
            end,
            'LegitKickLH'
        })

        UI.Sections.ToolExploit = UI.Sections.ToolExploit or UI.Tabs.Combat:Section({ Name = "ToolExploit", Side = "Right" })
        UI.Sections.ToolExploit:Header({ Name = "Tool Exploit" })
        UI.Sections.ToolExploit:SubLabel({ Text = "Only for KillAura, reduces the preparation time for an attack"})
        UI.Sections.ToolExploit:Slider({
            Name = "Minus Windup",
            Minimum = 0.1,
            Maximum = 2,
            Default = State.KillAura.MinusWindup.Default,
            Precision = 1,
            Callback = function(value)
                State.KillAura.MinusWindup.Value = value
                if tick() - lastNotificationTime >= notificationDelay then
                    lastNotificationTime = tick()
                    notify("ToolExploit", "Minus Windup set to: " .. value)
                end
            end,
            'MinusWindupTE'
        })
        UI.Sections.ToolExploit:Slider({
            Name = "Minus Release",
            Minimum = 0.1,
            Maximum = 2,
            Default = State.KillAura.MinusRelease.Default,
            Precision = 1,
            Callback = function(value)
                State.KillAura.MinusRelease.Value = value
                if tick() - lastNotificationTime >= notificationDelay then
                    lastNotificationTime = tick()
                    notify("ToolExploit", "Minus Release set to: " .. value)
                end
            end,
            'MinusReleaseTE'
        })
        UI.Sections.ToolExploit:Divider()
        UI.Sections.ToolExploit:Slider({
            Name = "Kick Delay",
            Minimum = 0.01,
            Maximum = 0.2,
            Default = State.KillAura.KickDelay.Default,
            Precision = 3,
            Callback = function(value)
                State.KillAura.KickDelay.Value = value
                if tick() - lastNotificationTime >= notificationDelay then
                    lastNotificationTime = tick()
                    notify("ToolExploit", "Kick Delay set to: " .. value)
                end
            end,
            'KickDelayTE'
        })
        UI.Sections.ToolExploit:Slider({
            Name = "Kick State Delay",
            Minimum = 0.01,
            Maximum = 0.2,
            Default = State.KillAura.KickStateDelay.Default,
            Precision = 3,
            Callback = function(value)
                State.KillAura.KickStateDelay.Value = value
                if tick() - lastNotificationTime >= notificationDelay then
                    lastNotificationTime = tick()
                    notify("ToolExploit", "Kick State Delay set to: " .. value)
                end
            end,
            'KickStateDelayTE'
        })

        UI.Sections.AutoDodge = UI.Sections.AutoDodge or UI.Tabs.Combat:Section({ Name = "AutoDodge", Side = "Right" })
        UI.Sections.AutoDodge:Header({ Name = "Auto Dodge" })
        UI.Sections.AutoDodge:Toggle({
            Name = "Enabled",
            Default = State.AutoDodge.Enabled.Default,
            Callback = function(value)
                State.AutoDodge.Enabled.Value = value
                Core.BulwarkTarget.isAutoDodge = value
                if tick() - lastNotificationTime >= notificationDelay then
                    lastNotificationTime = tick()
                    notify("AutoDodge", "AutoDodge " .. (value and "Enabled" or "Disabled"), true)
                end
            end,
            'EnabledAD'
        })
        UI.Sections.AutoDodge:Slider({
            Name = "Range",
            Minimum = 4,
            Maximum = 16,
            Default = State.AutoDodge.Range.Default,
            Precision = 0,
            Callback = function(value)
                State.AutoDodge.Range.Value = value
                if tick() - lastNotificationTime >= notificationDelay then
                    lastNotificationTime = tick()
                    notify("AutoDodge", "Range set to: " .. value)
                end
            end,
            'RangeAD'
        })
        UI.Sections.AutoDodge:Slider({
            Name = "PreRange",
            Minimum = 8,
            Maximum = 32,
            Default = State.AutoDodge.PreRange.Default,
            Precision = 0,
            Callback = function(value)
                State.AutoDodge.PreRange.Value = value
                if tick() - lastNotificationTime >= notificationDelay then
                    lastNotificationTime = tick()
                    notify("AutoDodge", "PreRange set to: " .. value)
                end
            end,
            'PreRangeAD'
        })
        UI.Sections.AutoDodge:Slider({
            Name = "Dodge Cooldown",
            Minimum = 0.1,
            Maximum = 0.5,
            Default = State.AutoDodge.DodgeCooldown.Default,
            Precision = 1,
            Callback = function(value)
                State.AutoDodge.DodgeCooldown.Value = value
                if tick() - lastNotificationTime >= notificationDelay then
                    lastNotificationTime = tick()
                    notify("AutoDodge", "Dodge Cooldown set to: " .. value)
                end
            end,
            'DodgeCooldownAD'
        })
        UI.Sections.AutoDodge:Divider()
        UI.Sections.AutoDodge:Toggle({
            Name = "Team Check",
            Default = State.AutoDodge.TeamCheck.Default,
            Callback = function(value)
                State.AutoDodge.TeamCheck.Value = value
                if tick() - lastNotificationTime >= notificationDelay then
                    lastNotificationTime = tick()
                    notify("AutoDodge", "Team Check " .. (value and "Enabled" or "Disabled"), true)
                end
            end,
            'TeamCheckAD'
        })
        UI.Sections.AutoDodge:Toggle({
            Name = "KillAura Sync",
            Default = State.AutoDodge.KillAuraSync.Default,
            Callback = function(value)
                State.AutoDodge.KillAuraSync.Value = value
                if tick() - lastNotificationTime >= notificationDelay then
                    lastNotificationTime = tick()
                    notify("AutoDodge", "KillAura Sync " .. (value and "Enabled" or "Disabled"), true)
                end
            end,
            'KillAuraSyncAD'
        })
        UI.Sections.AutoDodge:Toggle({
            Name = "Idle Spoof",
            Default = State.AutoDodge.IdleSpoof.Default,
            Callback = function(value)
                State.AutoDodge.IdleSpoof.Value = value
                if tick() - lastNotificationTime >= notificationDelay then
                    lastNotificationTime = tick()
                    notify("AutoDodge", "Idle Spoof " .. (value and "Enabled" or "Disabled"), true)
                end
            end,
            'IdleSpoofAD'
        })
        UI.Sections.AutoDodge:SubLabel({ Text = "[❗] Recommend use Idle Spoof ONLY with Block mode, parry mode may cause crashes "})
        UI.Sections.AutoDodge:Toggle({
            Name = "Use Client Idle",
            Default = State.AutoDodge.UseClientIdle.Default,
            Callback = function(value)
                State.AutoDodge.UseClientIdle.Value = value
                if tick() - lastNotificationTime >= notificationDelay then
                    lastNotificationTime = tick()
                    notify("AutoDodge", "Use Client Idle " .. (value and "Enabled" or "Disabled"), true)
                end
            end,
            'UseClientIdleAD'
        })
        UI.Sections.AutoDodge:Divider()

        UI.Sections.AutoDodge:Toggle({
            Name = "Warning Text",
            Default = State.AutoDodge.WarningText.Default,
            Callback = function(value)
                State.AutoDodge.WarningText.Value = value
                toggleWarningText(value)
                if tick() - lastNotificationTime >= notificationDelay then
                    lastNotificationTime = tick()
                    notify("AutoDodge", "Warning Text " .. (value and "Enabled" or "Disabled"), true)
                end
            end,
            'WarningTextAD'
        })
        UI.Sections.AutoDodge:Slider({
            Name = "Warning Text Scale",
            Minimum = 0.1,
            Maximum = 1,
            Default = State.AutoDodge.WarningTextScale.Default,
            Precision = 2,
            Callback = function(value)
                State.AutoDodge.WarningTextScale.Value = value
                if warningTextLabel then
                    warningTextLabel.Size = UDim2.new(0, 200 * value, 0, 100 * value)
                end
                if tick() - lastNotificationTime >= notificationDelay then
                    lastNotificationTime = tick()
                    notify("AutoDodge", "Warning Text Scale set to: " .. value)
                end
            end,
            'WarningTextScaleAD'
        })
        UI.Sections.AutoDodge:Dropdown({
            Name = "Blocking Mode",
            Options = {"Block", "Parry", "Chance"},
            Default = State.AutoDodge.BlockingMode.Default,
            Callback = function(value)
                State.AutoDodge.BlockingMode.Value = value
                if tick() - lastNotificationTime >= notificationDelay then
                    lastNotificationTime = tick()
                    notify("AutoDodge", "Blocking Mode set to: " .. value)
                end
            end,
            'BlockingModeAD'
        })
        UI.Sections.AutoDodge:Divider()
        UI.Sections.AutoDodge:Slider({
            Name = "Block Chance",
            Minimum = 0,
            Maximum = 100,
            Precision = 0,
            Suffix = "%",
            Default = State.AutoDodge.ParryingChance.Default,
            Callback = function(value)
                State.AutoDodge.ParryingChance.Value = value
                if tick() - lastNotificationTime >= notificationDelay then
                    lastNotificationTime = tick()
                    notify("AutoDodge", "Parrying Chance set to: " .. value .. "%")
                end
            end,
            'ParryingChanceAD'
        })
        UI.Sections.AutoDodge:Slider({
            Name = "Parry Chance",
            Minimum = 0,
            Maximum = 100,
            Precision = 0,
            Suffix = "%",
            Default = State.AutoDodge.RiposteChance.Default,
            Callback = function(value)
                State.AutoDodge.RiposteChance.Value = value
                if tick() - lastNotificationTime >= notificationDelay then
                    lastNotificationTime = tick()
                    notify("AutoDodge", "Riposte Chance set to: " .. value .. "%")
                end
            end,
            'RiposteChanceAD'
        })
        UI.Sections.AutoDodge:Slider({
            Name = "Miss Chance",
            Minimum = 0,
            Maximum = 1,
            Default = State.AutoDodge.MissChance.Default,
            Precision = 1,
            Callback = function(value)
                State.AutoDodge.MissChance.Value = value
                if tick() - lastNotificationTime >= notificationDelay then
                    lastNotificationTime = tick()
                    notify("AutoDodge", "Miss Chance set to: " .. value)
                end
            end,
            'MissChanceAD'
        })
        UI.Sections.AutoDodge:Divider()
        UI.Sections.AutoDodge:Toggle({
            Name = "Legit Block",
            Default = State.AutoDodge.LegitBlock.Default,
            Callback = function(value)
                State.AutoDodge.LegitBlock.Value = value
                if tick() - lastNotificationTime >= notificationDelay then
                    lastNotificationTime = tick()
                    notify("AutoDodge", "Legit Block " .. (value and "Enabled" or "Disabled"), true)
                end
            end,
            'LegitBlockAD'
        })
        UI.Sections.AutoDodge:Toggle({
            Name = "Legit Parry",
            Default = State.AutoDodge.LegitParry.Default,
            Callback = function(value)
                State.AutoDodge.LegitParry.Value = value
                if tick() - lastNotificationTime >= notificationDelay then
                    lastNotificationTime = tick()
                    notify("AutoDodge", "Legit Parry " .. (value and "Enabled" or "Disabled"), true)
                end
            end,
            'LegitParryAD'
        })
    end
end

return KillAura
