local Players = game:GetService("Players")
local LocalPlayer = Players.LocalPlayer
local Camera = workspace.CurrentCamera
local RunService = game:GetService("RunService")
local UserInputService = game:GetService("UserInputService")

local Core = nil
local UI = nil
local notify = nil

-- Конфигурация Silent Aim
local Settings = {
    Enabled = false,
    FOV = 300,
    HitChance = 100,
    TargetPart = "Head",
    TeamCheck = true,
    VisibilityCheck = true,
    PrintDelay = 0.2,
    FireDelay = 0.5,
    Method = "Packet",
    SortMethod = "Auto",
    LogInterval = 0.05,
    DistanceLimit = 2000, -- 200 метров для игроков
    MobDistanceLimit = 400, -- 400 студов для мобов
    SmartHitbox = false,
    FOVColor = Color3.fromRGB(0, 255, 0),
    Keybind = nil,
    NPCSupport = false,
    SelectedTarget = "Entities"
}

local lastPrintTime = 0
local lastFireTime = 0
local currentTarget = nil
local isToolEquipped = false
local currentTool = nil
local lastLogTime = 0

-- Кэш для FriendsList и мобов
local Cache = {
    PlayerFriendCache = {},
    FriendsListVersion = 0,
    MobCache = setmetatable({}, { __mode = "v" }),
    LastCacheUpdate = 0,
    CacheInterval = 1.0
}

-- Создание FOV Circle с Drawing
local fovCircle = Drawing.new("Circle")
fovCircle.Thickness = 2
fovCircle.Color = Settings.FOVColor
fovCircle.Transparency = 0.7
fovCircle.Radius = Settings.FOV
fovCircle.Visible = Settings.Enabled
fovCircle.Filled = false

-- Функция для вывода сообщений с задержкой
local function DelayedPrint(message)
    local currentTime = tick()
    if currentTime - lastPrintTime >= Settings.PrintDelay then
        print("[SilentAim Debug] " .. os.date("%H:%M:%S", os.time()) .. ": " .. message)
        lastPrintTime = currentTime
    end
end

-- Функция для поиска скрытых объектов
local getNil = function(name, class)
    for _, v in next, getnilinstances() do
        if v.ClassName == class and v.Name == name then
            return v
        end
    end
end

-- Функция проверки видимости
local function IsVisible(targetPart)
    if not Settings.VisibilityCheck then
        return true
    end
    
    local character = LocalPlayer.Character
    local rootPart = character and character:FindFirstChild("HumanoidRootPart")
    if not rootPart then
        return false
    end
    
    local rayOrigin = rootPart.Position
    local rayDirection = (targetPart.Position - rayOrigin).Unit * 1000
    local raycastParams = RaycastParams.new()
    raycastParams.FilterDescendantsInstances = {character}
    raycastParams.FilterType = Enum.RaycastFilterType.Blacklist
    
    local raycastResult = workspace:Raycast(rayOrigin, rayDirection, raycastParams)
    if raycastResult and raycastResult.Instance:IsDescendantOf(targetPart.Parent) then
        return true
    end
    return false
end

-- Функция проверки нахождения в сейфзоне
local function IsInSafezone(position)
    local safezone = workspace:FindFirstChild("MapProps") and workspace.MapProps:FindFirstChild("Police") and workspace.MapProps.Police:FindFirstChild("Safezone")
    if not safezone then
        return false
    end
    
    local safezonePos = safezone.Position
    local safezoneSize = safezone.Size / 2
    
    local relativePos = position - safezonePos
    return math.abs(relativePos.X) <= safezoneSize.X and
           math.abs(relativePos.Y) <= safezoneSize.Y and
           math.abs(relativePos.Z) <= safezoneSize.Z
end

-- Функция проверки щита
local function HasProtectionBubble(player)
    if not player or not player.Character then
        return false
    end
    
    local protectionBubble = workspace:FindFirstChild("Entities") and workspace.Entities:FindFirstChild("ProtectionBubble")
    if not protectionBubble then
        return false
    end
    
    local targetPart = player.Character:FindFirstChild(Settings.TargetPart)
    if not targetPart then
        return false
    end
    
    local distance = (protectionBubble.Position - targetPart.Position).Magnitude
    return distance < 10
end

-- Функция проверки Lasso
local function HasLasso(player)
    if not player then
        return false
    end

    local charactersFolder = workspace:FindFirstChild("Characters")
    if not charactersFolder then
        return false
    end

    local playerName = player.Name
    if not playerName then
        return false
    end

    local playerContainer = charactersFolder:FindFirstChild(playerName)
    if not playerContainer then
        return false
    end

    local fakeLimbs = playerContainer:FindFirstChild("FakeLimbs")
    return fakeLimbs ~= nil
end

-- Функция проверки возможности атаки
local function CanAttack(player)
    if not player then
        return false
    end
    
    if HasLasso(player) then
        return false
    end
    
    if not Settings.TeamCheck then
        return true
    end
    
    local myTeam = LocalPlayer.Team and LocalPlayer.Team.Name
    local theirTeam = player.Team and player.Team.Name
    
    if not myTeam or not theirTeam then
        return true
    end
    
    if HasProtectionBubble(player) then
        return false
    end
    
    local targetPart = player.Character and player.Character:FindFirstChild(Settings.TargetPart)
    if targetPart and IsInSafezone(targetPart.Position) then
        if theirTeam == "Wizards" or theirTeam == "Royal Wizards" then
            return false
        end
        return true
    end
    
    if myTeam == "Shadow Wizards" then
        return true
    elseif myTeam == "Wizards" or myTeam == "Royal Wizards" then
        if theirTeam == "Wizards" or theirTeam == "Royal Wizards" then
            return false
        end
        return true
    end
    return true
end

-- Функция поиска ToolListener и PistolConfig
local function GetToolListener()
    local toolListener = nil
    local wand = nil
    
    local character = LocalPlayer.Character
    if not character then
        return nil, nil
    end

    for _, item in pairs(character:GetChildren()) do
        if item.ClassName == "Tool" then
            wand = item
            toolListener = wand:FindFirstChild("ToolListnerEvent")
            break
        end
    end
    
    if not toolListener or not wand then
        return nil, nil
    end
    
    local playerContainer = workspace:FindFirstChild("Characters") and workspace.Characters:FindFirstChild(LocalPlayer.Name)
    local pistolConfig = playerContainer and playerContainer:FindFirstChild(wand.Name) and playerContainer[wand.Name]:FindFirstChild("PistolConfig")
    if not pistolConfig then
        return toolListener, nil
    end
    return toolListener, pistolConfig
end

-- Функция поиска ближайшего моба с кэшированием
local function GetMissionTarget()
    if not Settings.NPCSupport then
        return nil, nil, nil
    end

    local currentTime = tick()
    if currentTime - Cache.LastCacheUpdate < Cache.CacheInterval then
        for mobName, mobData in pairs(Cache.MobCache) do
            local mob = mobData.Mob
            if mob and mob.Parent and mob:FindFirstChild("Humanoid") and mob:FindFirstChild("Humanoid").Health > 0 then
                local targetPart = mob:FindFirstChild("HumanoidRootPart") or mob:FindFirstChild("UpperTorso")
                if targetPart then
                    return mob, targetPart, mob:FindFirstChild("Humanoid")
                end
            end
        end
    end

    local missions = workspace:FindFirstChild("Missions")
    if not missions then
        return nil, nil, nil
    end

    local targetMission = missions:GetChildren()[4]
    if not targetMission then
        return nil, nil, nil
    end

    local aiSpawners = targetMission:FindFirstChild("AISpawners")
    if not aiSpawners then
        return nil, nil, nil
    end

    local targetSpawner = aiSpawners:GetChildren()[2]
    if not targetSpawner then
        return nil, nil, nil
    end

    local targetMob = nil
    local targetPart = nil
    local targetHumanoid = nil
    local minDistance = math.huge
    local origin = Camera.CFrame.Position

    local mobTypes = {
        "Poacher", "Poacher Mage", "Poacher Gunner", "Poacher Rifleman", "Imperial",
        "Nightfall Spitter Spider", "Nightfall Blink Spider"
    }

    for _, mobType in pairs(mobTypes) do
        local mob = targetSpawner:FindFirstChild(mobType)
        if not mob then
            mob = getNil(mobType, "Model")
        end
        if mob and mob.Parent then
            local humanoidRoot = mob:FindFirstChild("HumanoidRootPart") or mob:FindFirstChild("UpperTorso")
            local humanoid = mob:FindFirstChild("Humanoid")
            if humanoidRoot and humanoid and humanoid.Health > 0 then
                local distance = (origin - humanoidRoot.Position).Magnitude
                if distance < minDistance and distance <= Settings.MobDistanceLimit then
                    minDistance = distance
                    targetMob = mob
                    targetPart = humanoidRoot
                    targetHumanoid = humanoid
                end
            end
        end
    end

    if targetMob then
        Cache.MobCache[targetMob.Name] = { Mob = targetMob, LastSeen = currentTime }
        Cache.LastCacheUpdate = currentTime
        return targetMob, targetPart, targetHumanoid
    end
    return nil, nil, nil
end

-- Функция отправки remote event
local function SilentShot(target, targetPart)
    if not target or not targetPart then
        return
    end

    if not Settings.Enabled then
        return
    end
    
    local currentTime = tick()
    if currentTime - lastFireTime < Settings.FireDelay then
        return
    end
    
    if math.random(1, 100) > Settings.HitChance then
        return
    end
    
    local toolListener, pistolConfig = GetToolListener()
    if not toolListener then
        return
    end
    
    if not IsVisible(targetPart) then
        return
    end
    
    local originPosition = Camera.CFrame.Position
    local targetPosition = targetPart.Position
    local direction = (targetPosition - originPosition).Unit
    local hitPosition = targetPosition - direction * 1
    
    local args = {
        [1] = "Activate",
        [2] = originPosition,
        [3] = targetPosition,
        [4] = pistolConfig or game:GetService("Players").LocalPlayer:WaitForChild("PistolConfig"),
        [5] = { hitPosition },
        [6] = {
            [1] = {
                [1] = targetPart,
                [2] = hitPosition,
                [3] = direction,
                [4] = "Humanoid"
            }
        },
        [7] = { target:FindFirstChild("Humanoid") },
        [8] = {}
    }
    
    local success, err = pcall(function()
        toolListener:FireServer(unpack(args))
    end)
    
    if success then
        lastFireTime = currentTime
        Core.GunSilentTarget.CurrentTarget = target.Name
    end
end

-- Функция проверки экипировки инструмента
local function CheckToolEquipped()
    local character = LocalPlayer.Character
    if not character then
        if isToolEquipped then
            isToolEquipped = false
            currentTool = nil
        end
        return false
    end

    for _, item in pairs(character:GetChildren()) do
        if item.ClassName == "Tool" then
            if not isToolEquipped then
                isToolEquipped = true
                currentTool = item
            end
            return true
        end
    end

    if isToolEquipped then
        isToolEquipped = false
        currentTool = nil
    end
    return false
end

-- Функция для проверки и логирования FriendsList
local function UpdateFriendsCheck()
    local currentTime = tick()
    if currentTime - lastLogTime >= Settings.LogInterval then
        if Core and Core.Services and Core.Services.FriendsList then
            local count = 0
            for _, isFriend in pairs(Core.Services.FriendsList) do
                if isFriend then count = count + 1 end
            end
        end
        lastLogTime = currentTime
    end
end

-- Асинхронное обновление кэша
local function UpdateCache()
    while wait(Cache.CacheInterval) do
        local currentTime = tick()
        Cache.LastCacheUpdate = currentTime
        for mobName, mobData in pairs(Cache.MobCache) do
            if not (mobData.Mob and mobData.Mob.Parent and mobData.Mob:FindFirstChild("Humanoid") and mobData.Mob:FindFirstChild("Humanoid").Health > 0) then
                Cache.MobCache[mobName] = nil
            end
        end
    end
end
coroutine.wrap(UpdateCache)()

-- Инициализация модуля
function Init(ui, core, notification)
    UI = ui
    Core = core
    notify = notification

    if not UI or not Core or not notify then
        return
    end

    if Core and Core.Services then
        Core.Services.FriendsList = Core.Services.FriendsList or {}
        Cache.FriendsListVersion = Cache.FriendsListVersion + 1
        Cache.PlayerFriendCache = {}
    end

    UI.TabGroups = UI.TabGroups or { Main = UI.Window:TabGroup() }
    UI.Tabs = UI.Tabs or {}
    UI.Tabs.Combat = UI.TabGroups.Main:Tab({ Name = "Combat", Image = "rbxassetid://4391741881" })

    UI.Sections = UI.Sections or {}
    UI.Sections.SilentAim = UI.Tabs.Combat:Section({ Name = "Silent Aim", Side = "Left" })

    UI.Sections.SilentAim:Header({ Name = "Silent Aim" })

    UI.Sections.SilentAim:Toggle({
        Name = "Enabled",
        Default = Settings.Enabled,
        Callback = function(value)
            Settings.Enabled = value
            fovCircle.Visible = value
            notify("Silent Aim", "Toggled " .. (value and "ON" or "OFF"), false)
        end
    }, "SilentEnabled")

    UI.Sections.SilentAim:Keybind({
        Name = "Toggle Keybind",
        Default = Settings.Keybind,
        Callback = function(key)
            Settings.Keybind = key
            notify("Silent Aim", "Keybind set to: " .. (key and key.Name or "None"), false)
        end
    }, "SilentKeybind")

    UI.Sections.SilentAim:Slider({
        Name = "FOV",
        Minimum = 50,
        Maximum = 500,
        Default = Settings.FOV,
        Precision = 0,
        Suffix = "s",
        Callback = function(value)
            Settings.FOV = value
            fovCircle.Radius = value
            notify("Silent Aim", "FOV set to: " .. value .. " studs", false)
        end
    }, "SilentFOV")

    UI.Sections.SilentAim:Colorpicker({
        Name = "FOV Circle Color",
        Default = Settings.FOVColor,
        Callback = function(value)
            Settings.FOVColor = value
            fovCircle.Color = value
            notify("Silent Aim", "FOV Circle color updated", false)
        end
    }, "SilentFOVColor")

    UI.Sections.SilentAim:Slider({
        Name = "Hit Chance",
        Minimum = 0,
        Maximum = 100,
        Default = Settings.HitChance,
        Precision = 0,
        Suffix = "%",
        Callback = function(value)
            Settings.HitChance = value
            notify("Silent Aim", "Hit Chance set to: " .. value .. "%", false)
        end
    }, "SilentHitChance")

    UI.Sections.SilentAim:Dropdown({
        Name = "Target Part",
        Options = {"Head", "Torso", "LeftLeg", "RightLeg"},
        Default = Settings.TargetPart,
        MultiSelection = false,
        Callback = function(value)
            Settings.TargetPart = value
            notify("Silent Aim", "Target Part set to: " .. value, false)
        end
    }, "SilentTargetPart")

    UI.Sections.SilentAim:Toggle({
        Name = "Smart Hitbox",
        Default = Settings.SmartHitbox,
        Callback = function(value)
            Settings.SmartHitbox = value
            notify("Silent Aim", "Smart Hitbox " .. (value and "ON" or "OFF"), false)
        end
    }, "SilentSmartHitbox")

    UI.Sections.SilentAim:Toggle({
        Name = "Team Check",
        Default = Settings.TeamCheck,
        Callback = function(value)
            Settings.TeamCheck = value
            notify("Silent Aim", "Team Check " .. (value and "ON" or "OFF"), false)
        end
    }, "SilentTeamCheck")

    UI.Sections.SilentAim:Toggle({
        Name = "Visibility Check",
        Default = Settings.VisibilityCheck,
        Callback = function(value)
            Settings.VisibilityCheck = value
            notify("Silent Aim", "Visibility Check " .. (value and "ON" or "OFF"), false)
        end
    }, "SilentVisibilityCheck")

    UI.Sections.SilentAim:Slider({
        Name = "Distance Limit",
        Minimum = 50,
        Maximum = 2000,
        Default = Settings.DistanceLimit,
        Precision = 0,
        Suffix = "s",
        Callback = function(value)
            Settings.DistanceLimit = value
            notify("Silent Aim", "Distance Limit set to: " .. value .. " studs", false)
        end
    }, "SilentDistanceLimit")

    UI.Sections.SilentAim:Slider({
        Name = "Fire Delay",
        Minimum = 0.001,
        Maximum = 2,
        Default = Settings.FireDelay,
        Precision = 2,
        Suffix = "s",
        Callback = function(value)
            Settings.FireDelay = value
            notify("Silent Aim", "Fire Delay set to: " .. value .. "s", false)
        end
    }, "SilentFireDelay")

    UI.Sections.SilentAim:Dropdown({
        Name = "Sort Method",
        Options = {"Distance", "Health", "Crosshair", "Auto"},
        Default = Settings.SortMethod,
        MultiSelection = false,
        Callback = function(value)
            Settings.SortMethod = value
            notify("Silent Aim", "Sort Method set to: " .. value, false)
        end
    }, "SilentSortMethod")

    UI.Sections.SilentAim:Toggle({
        Name = "NPC Support",
        Default = Settings.NPCSupport,
        Callback = function(value)
            Settings.NPCSupport = value
            notify("Silent Aim", "NPC Support " .. (value and "ON" or "OFF"), false)
        end
    }, "SilentNPCSupport")

    UI.Sections.SilentAim:Dropdown({
        Name = "Entities",
        Options = {"Entities"},
        Default = Settings.SelectedTarget,
        MultiSelection = false,
        Callback = function(value)
            Settings.SelectedTarget = value
            notify("Silent Aim", "Selected Target set to: " .. value, false)
        end
    }, "SilentEntities")

    UserInputService.InputBegan:Connect(function(input)
        if Settings.Keybind and input.KeyCode == Settings.Keybind then
            Settings.Enabled = not Settings.Enabled
            fovCircle.Visible = Settings.Enabled
            notify("Silent Aim", "Toggled " .. (Settings.Enabled and "ON" or "OFF"), false)
        end
    end)
end

-- Обновление позиции FOV Circle и логика Silent Aim
RunService.RenderStepped:Connect(function()
    if not UI or not Core then
        return
    end

    local mousePos = UserInputService:GetMouseLocation()
    fovCircle.Position = Vector2.new(mousePos.X, mousePos.Y)

    if not CheckToolEquipped() then
        currentTarget = nil
        Core.GunSilentTarget.CurrentTarget = nil
        return
    end

    UpdateFriendsCheck()

    local target, targetPart = nil, nil
    -- Приоритет на игроков
    local validTargets = {}
    local possibleParts = {"Head", "Torso", "LeftLeg", "RightLeg"}
    for _, player in pairs(Players:GetPlayers()) do
        if player == LocalPlayer or not player.Character then continue end
        local playerNameLower = player.Name:lower()
        local isFriend = Cache.PlayerFriendCache[playerNameLower]
        if isFriend == nil and Core and Core.Services and Core.Services.FriendsList then
            isFriend = Core.Services.FriendsList[playerNameLower] == true
            Cache.PlayerFriendCache[playerNameLower] = isFriend
        end
        if isFriend then continue end
        local humanoid = player.Character:FindFirstChild("Humanoid")
        local humanoidRoot = player.Character:FindFirstChild("HumanoidRootPart")
        if not humanoid or not humanoidRoot or humanoid.Health <= 0 then continue end
        local distance = (Camera.CFrame.Position - humanoidRoot.Position).Magnitude
        if distance > Settings.DistanceLimit then continue end
        local targetPart = nil
        if Settings.SmartHitbox then
            for _, partName in ipairs(possibleParts) do
                local part = player.Character:FindFirstChild(partName)
                if part then
                    targetPart = part
                    break
                end
            end
        else
            targetPart = player.Character:FindFirstChild(Settings.TargetPart)
        end
        if targetPart and CanAttack(player) and not (IsInSafezone(targetPart.Position) and (player.Team and (player.Team.Name == "Wizards" or player.Team.Name == "Royal Wizards"))) then
            local screenPos = Camera:WorldToViewportPoint(targetPart.Position)
            local mouseDistance = (Vector2.new(screenPos.X, screenPos.Y) - mousePos).Magnitude
            if mouseDistance <= Settings.FOV then
                table.insert(validTargets, {Player = player, MouseDistance = mouseDistance, Health = humanoid.Health, TargetPart = targetPart})
            end
        end
    end
    table.sort(validTargets, function(a, b)
        if Settings.SortMethod == "Distance" then
            return (Camera.CFrame.Position - a.Player.Character[Settings.TargetPart].Position).Magnitude <
                   (Camera.CFrame.Position - b.Player.Character[Settings.TargetPart].Position).Magnitude
        elseif Settings.SortMethod == "Health" then
            return a.Health < b.Health
        elseif Settings.SortMethod == "Crosshair" then
            return a.MouseDistance < b.MouseDistance
        elseif Settings.SortMethod == "Auto" then
            local aScore = a.Health * 0.7 + a.MouseDistance * 0.3
            local bScore = b.Health * 0.7 + b.MouseDistance * 0.3
            return aScore < bScore
        end
        return a.MouseDistance < b.MouseDistance
    end)
    if #validTargets > 0 then
        target = validTargets[1].Player
        targetPart = validTargets[1].TargetPart
    elseif Settings.NPCSupport and Settings.SelectedTarget == "Entities" then
        local mob, mobPart, mobHumanoid = GetMissionTarget()
        if mob and mobPart and mobHumanoid and IsVisible(mobPart) and not IsInSafezone(mobPart.Position) then
            target = mob
            targetPart = mobPart
        end
    end

    currentTarget = target
    
    if target and targetPart then
        SilentShot(target, targetPart)
    else
        Core.GunSilentTarget.CurrentTarget = nil
    end
end)

-- Очистка при телепортации
game:GetService("Players").LocalPlayer.OnTeleport:Connect(function()
    fovCircle:Remove()
end)

return {
    Init = Init
}
