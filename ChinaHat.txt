local ChinaHat = {}

function ChinaHat.Init(UI, Core, notify)
    local Players = Core.Services.Players
    local RunService = Core.Services.RunService
    local UserInputService = Core.Services.UserInputService
    local Workspace = Core.Services.Workspace
    local camera = Workspace.CurrentCamera

    local LocalPlayer = Core.PlayerData.LocalPlayer
    local localCharacter = LocalPlayer.Character
    local localHumanoid = localCharacter and localCharacter:FindFirstChild("Humanoid")

    local State = {
        ChinaHat = {
            HatActive = { Value = false, Default = false },
            HatScale = { Value = 0.75, Default = 0.75 },
            HatParts = { Value = 50, Default = 50 },
            HatGradientSpeed = { Value = 4, Default = 4 },
            HatGradient = { Value = true, Default = true },
            HatColor = { Value = Color3.fromRGB(0, 0, 255), Default = Color3.fromRGB(0, 0, 255) },
            HatYOffset = { Value = 1.6, Default = 1.6 },
            OutlineCircle = { Value = false, Default = false }
        },
        Circle = {
            CircleActive = { Value = false, Default = false },
            CircleRadius = { Value = 1.7, Default = 1.7 },
            CircleParts = { Value = 30, Default = 30 },
            CircleGradientSpeed = { Value = 4, Default = 4 },
            CircleGradient = { Value = true, Default = true },
            CircleColor = { Value = Color3.fromRGB(0, 0, 255), Default = Color3.fromRGB(0, 0, 255) },
            JumpAnimate = { Value = false, Default = false }
        },
        Nimb = {
            NimbActive = { Value = false, Default = false },
            NimbRadius = { Value = 1.7, Default = 1.7 },
            NimbParts = { Value = 30, Default = 30 },
            NimbGradientSpeed = { Value = 4, Default = 4 },
            NimbGradient = { Value = true, Default = true },
            NimbColor = { Value = Color3.fromRGB(0, 0, 255), Default = Color3.fromRGB(0, 0, 255) },
            NimbYOffset = { Value = 1.5, Default = 1.5 }
        },
        TargetESP = {
            TargetESPActive = { Value = false, Default = false },
            TargetESPRadius = { Value = 1.7, Default = 1.7 },
            TargetESPParts = { Value = 30, Default = 30 },
            TargetESPGradientSpeed = { Value = 4, Default = 4 },
            TargetESPGradient = { Value = true, Default = true },
            TargetESPColor = { Value = Color3.fromRGB(0, 0, 255), Default = Color3.fromRGB(0, 0, 255) },
            TargetESPYOffset = { Value = 0, Default = 0 },
            TargetESPType = { Value = "All", Default = "All", Options = {"All", "KillAura", "AutoDodge"} }
        }
    }

    local hatLines = {} -- Для линий ChinaHat с Drawing.Line
    local hatCircleQuads = {} -- Для 3D-круга ChinaHat с Drawing.Quad
    local circleQuads = {} -- Для 3D-круга Circle с Drawing.Quad
    local nimbQuads = {} -- Для 3D-круга Nimb с Drawing.Quad
    local targetESPQuads = {} -- Для 3D-круга TargetESP с Drawing.Quad
    local jumpAnimationActive = false

    local function interpolateColor(color1, color2, factor)
        return Color3.new(
            color1.R + (color2.R - color1.R) * factor,
            color1.G + (color2.G - color1.G) * factor,
            color1.B + (color2.B - color1.B) * factor
        )
    end

    local function createHat()
        if not localCharacter or not localCharacter:FindFirstChild("Head") then return end
        local head = localCharacter.Head
        for i = 1, State.ChinaHat.HatParts.Value do
            local line = Drawing.new("Line")
            line.Visible = false
            line.Thickness = 0.06
            line.Transparency = 0.5
            line.Color = State.ChinaHat.HatGradient.Value and interpolateColor(Core.GradientColors.Color1.Value, Core.GradientColors.Color2.Value, i / State.ChinaHat.HatParts.Value) or State.ChinaHat.HatColor.Value
            table.insert(hatLines, line)
        end
        if State.ChinaHat.OutlineCircle.Value and #hatCircleQuads == 0 then
            for i = 1, 40 do -- 40 сегментов для 3D-круга
                local quad = Drawing.new("Quad")
                quad.Visible = false
                quad.Thickness = 1
                quad.Filled = false
                quad.Color = State.ChinaHat.HatGradient.Value and interpolateColor(Core.GradientColors.Color1.Value, Core.GradientColors.Color2.Value, i / 40) or State.ChinaHat.HatColor.Value
                table.insert(hatCircleQuads, quad)
            end
        end
    end

    local function createCircle()
        if not localCharacter or not localCharacter:FindFirstChild("HumanoidRootPart") then return end
        for i = 1, State.Circle.CircleParts.Value do
            local quad = Drawing.new("Quad")
            quad.Visible = false
            quad.Thickness = 1
            quad.Filled = false
            quad.Color = State.Circle.CircleGradient.Value and interpolateColor(Core.GradientColors.Color1.Value, Core.GradientColors.Color2.Value, i / State.Circle.CircleParts.Value) or State.Circle.CircleColor.Value
            table.insert(circleQuads, quad)
        end
    end

    local function createNimb()
        if not localCharacter or not localCharacter:FindFirstChild("HumanoidRootPart") then return end
        for i = 1, State.Nimb.NimbParts.Value do
            local quad = Drawing.new("Quad")
            quad.Visible = false
            quad.Thickness = 1
            quad.Filled = false
            quad.Color = State.Nimb.NimbGradient.Value and interpolateColor(Core.GradientColors.Color1.Value, Core.GradientColors.Color2.Value, i / State.Nimb.NimbParts.Value) or State.Nimb.NimbColor.Value
            table.insert(nimbQuads, quad)
        end
    end

    local function createTargetESP()
        local targetName = nil
        if State.TargetESP.TargetESPType.Value == "All" and Core.BulwarkTarget.CurrentTarget then
            targetName = Core.BulwarkTarget.CurrentTarget
        elseif State.TargetESP.TargetESPType.Value == "KillAura" and Core.BulwarkTarget.KillAuraTarget then
            targetName = Core.BulwarkTarget.KillAuraTarget
        elseif State.TargetESP.TargetESPType.Value == "AutoDodge" and Core.BulwarkTarget.AutoDodgeTarget then
            targetName = Core.BulwarkTarget.AutoDodgeTarget
        end

        if targetName and Players:FindFirstChild(targetName) then
            local targetPlayer = Players:FindFirstChild(targetName)
            if targetPlayer.Character and targetPlayer.Character:FindFirstChild("HumanoidRootPart") then
                for i = 1, State.TargetESP.TargetESPParts.Value do
                    local quad = Drawing.new("Quad")
                    quad.Visible = false
                    quad.Thickness = 1
                    quad.Filled = false
                    quad.Color = State.TargetESP.TargetESPGradient.Value and interpolateColor(Core.GradientColors.Color1.Value, Core.GradientColors.Color2.Value, i / State.TargetESP.TargetESPParts.Value) or State.TargetESP.TargetESPColor.Value
                    table.insert(targetESPQuads, quad)
                end
            end
        end
    end

    local function removeParts(parts)
        for _, part in ipairs(parts) do
            part:Remove()
        end
        table.clear(parts)
    end

    local function updateHat()
        if not State.ChinaHat.HatActive.Value or #hatLines == 0 then return end
        if not localCharacter or not localCharacter:FindFirstChild("Head") then return end
        local head = localCharacter.Head
        local hatHeight = 2.15 * State.ChinaHat.HatScale.Value
        local hatRadius = 1.95 * State.ChinaHat.HatScale.Value
        local y = head.Position.Y + State.ChinaHat.HatYOffset.Value
        local t = tick()

        for i, line in ipairs(hatLines) do
            local angle = (i / State.ChinaHat.HatParts.Value) * 2 * math.pi
            local x = math.cos(angle) * hatRadius
            local z = math.sin(angle) * hatRadius
            local basePosition = Vector3.new(head.Position.X, y, head.Position.Z)
            local topPosition = Vector3.new(head.Position.X + x, y - hatHeight / 3, head.Position.Z + z)

            local offset = 0.03
            local direction = (topPosition - basePosition).Unit
            local startPoint = basePosition
            local endPoint = topPosition + direction * offset

            local screenStart, onScreenStart = camera:WorldToViewportPoint(startPoint)
            local screenEnd, onScreenEnd = camera:WorldToViewportPoint(endPoint)

            if onScreenStart and onScreenEnd and screenStart.Z > 0 and screenEnd.Z > 0 then
                line.From = Vector2.new(screenStart.X, screenStart.Y)
                line.To = Vector2.new(screenEnd.X, screenEnd.Y)
                line.Visible = true
                if State.ChinaHat.HatGradient.Value then
                    local factor = (math.sin(t * State.ChinaHat.HatGradientSpeed.Value + (i / State.ChinaHat.HatParts.Value) * 2 * math.pi) + 1) / 2
                    line.Color = interpolateColor(Core.GradientColors.Color1.Value, Core.GradientColors.Color2.Value, factor)
                else
                    line.Color = State.ChinaHat.HatColor.Value
                end
            else
                line.Visible = false
            end
        end

        if State.ChinaHat.OutlineCircle.Value and #hatCircleQuads > 0 then
            local center = Vector3.new(0, 0, 0)
            local visibleEnds = 0
            for i, line in ipairs(hatLines) do
                if line.Visible then
                    local angle = (i / State.ChinaHat.HatParts.Value) * 2 * math.pi
                    local x = math.cos(angle) * hatRadius
                    local z = math.sin(angle) * hatRadius
                    local topPosition = Vector3.new(head.Position.X + x, y - hatHeight / 3, head.Position.Z + z)
                    local offset = 0.03
                    local direction = (topPosition - Vector3.new(head.Position.X, y, head.Position.Z)).Unit
                    local endPoint = topPosition + direction * offset
                    center = center + endPoint
                    visibleEnds = visibleEnds + 1
                end
            end
            if visibleEnds > 0 then
                center = center / visibleEnds
            else
                center = Vector3.new(head.Position.X, y, head.Position.Z)
            end

            local screenCenter, onScreenCenter = camera:WorldToViewportPoint(center)
            if onScreenCenter and screenCenter.Z > 0 then
                local circleSegments = #hatCircleQuads
                local circleRadius = 2.0 * State.ChinaHat.HatScale.Value
                for i, quad in ipairs(hatCircleQuads) do
                    local angle1 = ((i - 1) / circleSegments) * 2 * math.pi
                    local angle2 = (i / circleSegments) * 2 * math.pi
                    local point1Bottom = center + Vector3.new(math.cos(angle1) * circleRadius, 0, math.sin(angle1) * circleRadius)
                    local point2Bottom = center + Vector3.new(math.cos(angle2) * circleRadius, 0, math.sin(angle2) * circleRadius)
                    local point1Top = point1Bottom + Vector3.new(0, 0, 0)
                    local point2Top = point2Bottom + Vector3.new(0, 0, 0)
                    local screenPoint1Bottom, onScreen1Bottom = camera:WorldToViewportPoint(point1Bottom)
                    local screenPoint2Bottom, onScreen2Bottom = camera:WorldToViewportPoint(point2Bottom)
                    local screenPoint1Top, onScreen1Top = camera:WorldToViewportPoint(point1Top)
                    local screenPoint2Top, onScreen2Top = camera:WorldToViewportPoint(point2Top)

                    if onScreen1Bottom and onScreen2Bottom and onScreen1Top and onScreen2Top and
                       screenPoint1Bottom.Z > 0 and screenPoint2Bottom.Z > 0 and
                       screenPoint1Top.Z > 0 and screenPoint2Top.Z > 0 then
                        quad.PointA = Vector2.new(screenPoint1Bottom.X, screenPoint1Bottom.Y)
                        quad.PointB = Vector2.new(screenPoint2Bottom.X, screenPoint2Bottom.Y)
                        quad.PointC = Vector2.new(screenPoint2Top.X, screenPoint2Top.Y)
                        quad.PointD = Vector2.new(screenPoint1Top.X, screenPoint1Top.Y)
                        quad.Visible = true
                        if State.ChinaHat.HatGradient.Value then
                            local factor = (math.sin(t * State.ChinaHat.HatGradientSpeed.Value + (i / circleSegments) * 2 * math.pi) + 1) / 2
                            quad.Color = interpolateColor(Core.GradientColors.Color1.Value, Core.GradientColors.Color2.Value, factor)
                        else
                            quad.Color = State.ChinaHat.HatColor.Value
                        end
                    else
                        quad.Visible = false
                    end
                end
            else
                for _, quad in ipairs(hatCircleQuads) do
                    quad.Visible = false
                end
            end
        end
    end

    local function updateCircle()
        if not State.Circle.CircleActive.Value or #circleQuads == 0 then return end
        if not localCharacter or not localCharacter:FindFirstChild("HumanoidRootPart") then return end
        local rootPart = localCharacter.HumanoidRootPart
        local t = tick()
        local center = Vector3.new(rootPart.Position.X, rootPart.Position.Y, rootPart.Position.Z)
        local screenCenter, onScreenCenter = camera:WorldToViewportPoint(center)
        if onScreenCenter and screenCenter.Z > 0 then
            local circleSegments = #circleQuads
            local circleRadius = State.Circle.CircleRadius.Value
            for i, quad in ipairs(circleQuads) do
                local angle1 = ((i - 1) / circleSegments) * 2 * math.pi
                local angle2 = (i / circleSegments) * 2 * math.pi
                local point1Bottom = center + Vector3.new(math.cos(angle1) * circleRadius, 0, math.sin(angle1) * circleRadius)
                local point2Bottom = center + Vector3.new(math.cos(angle2) * circleRadius, 0, math.sin(angle2) * circleRadius)
                local point1Top = point1Bottom + Vector3.new(0, 0, 0)
                local point2Top = point2Bottom + Vector3.new(0, 0, 0)
                local screenPoint1Bottom, onScreen1Bottom = camera:WorldToViewportPoint(point1Bottom)
                local screenPoint2Bottom, onScreen2Bottom = camera:WorldToViewportPoint(point2Bottom)
                local screenPoint1Top, onScreen1Top = camera:WorldToViewportPoint(point1Top)
                local screenPoint2Top, onScreen2Top = camera:WorldToViewportPoint(point2Top)

                if onScreen1Bottom and onScreen2Bottom and onScreen1Top and onScreen2Top and
                   screenPoint1Bottom.Z > 0 and screenPoint2Bottom.Z > 0 and
                   screenPoint1Top.Z > 0 and screenPoint2Top.Z > 0 then
                    quad.PointA = Vector2.new(screenPoint1Bottom.X, screenPoint1Bottom.Y)
                    quad.PointB = Vector2.new(screenPoint2Bottom.X, screenPoint2Bottom.Y)
                    quad.PointC = Vector2.new(screenPoint2Top.X, screenPoint2Top.Y)
                    quad.PointD = Vector2.new(screenPoint1Top.X, screenPoint1Top.Y)
                    quad.Visible = true
                    if State.Circle.CircleGradient.Value then
                        local factor = (math.sin(t * State.Circle.CircleGradientSpeed.Value + (i / circleSegments) * 2 * math.pi) + 1) / 2
                        quad.Color = interpolateColor(Core.GradientColors.Color1.Value, Core.GradientColors.Color2.Value, factor)
                    else
                        quad.Color = State.Circle.CircleColor.Value
                    end
                else
                    quad.Visible = false
                end
            end
        else
            for _, quad in ipairs(circleQuads) do
                quad.Visible = false
            end
        end
    end

    local function updateNimb()
        if not State.Nimb.NimbActive.Value or #nimbQuads == 0 then return end
        if not localCharacter or not localCharacter:FindFirstChild("HumanoidRootPart") then return end
        local rootPart = localCharacter.HumanoidRootPart
        local t = tick()
        local center = Vector3.new(rootPart.Position.X, rootPart.Position.Y + State.Nimb.NimbYOffset.Value, rootPart.Position.Z)
        local screenCenter, onScreenCenter = camera:WorldToViewportPoint(center)
        if onScreenCenter and screenCenter.Z > 0 then
            local nimbSegments = #nimbQuads
            local nimbRadius = State.Nimb.NimbRadius.Value
            for i, quad in ipairs(nimbQuads) do
                local angle1 = ((i - 1) / nimbSegments) * 2 * math.pi
                local angle2 = (i / nimbSegments) * 2 * math.pi
                local point1Bottom = center + Vector3.new(math.cos(angle1) * nimbRadius, 0, math.sin(angle1) * nimbRadius)
                local point2Bottom = center + Vector3.new(math.cos(angle2) * nimbRadius, 0, math.sin(angle2) * nimbRadius)
                local point1Top = point1Bottom + Vector3.new(0, 0, 0)
                local point2Top = point2Bottom + Vector3.new(0, 0, 0)
                local screenPoint1Bottom, onScreen1Bottom = camera:WorldToViewportPoint(point1Bottom)
                local screenPoint2Bottom, onScreen2Bottom = camera:WorldToViewportPoint(point2Bottom)
                local screenPoint1Top, onScreen1Top = camera:WorldToViewportPoint(point1Top)
                local screenPoint2Top, onScreen2Top = camera:WorldToViewportPoint(point2Top)

                if onScreen1Bottom and onScreen2Bottom and onScreen1Top and onScreen2Top and
                   screenPoint1Bottom.Z > 0 and screenPoint2Bottom.Z > 0 and
                   screenPoint1Top.Z > 0 and screenPoint2Top.Z > 0 then
                    quad.PointA = Vector2.new(screenPoint1Bottom.X, screenPoint1Bottom.Y)
                    quad.PointB = Vector2.new(screenPoint2Bottom.X, screenPoint2Bottom.Y)
                    quad.PointC = Vector2.new(screenPoint2Top.X, screenPoint2Top.Y)
                    quad.PointD = Vector2.new(screenPoint1Top.X, screenPoint1Top.Y)
                    quad.Visible = true
                    if State.Nimb.NimbGradient.Value then
                        local factor = (math.sin(t * State.Nimb.NimbGradientSpeed.Value + (i / nimbSegments) * 2 * math.pi) + 1) / 2
                        quad.Color = interpolateColor(Core.GradientColors.Color1.Value, Core.GradientColors.Color2.Value, factor)
                    else
                        quad.Color = State.Nimb.NimbColor.Value
                    end
                else
                    quad.Visible = false
                end
            end
        else
            for _, quad in ipairs(nimbQuads) do
                quad.Visible = false
            end
        end
    end

    local function updateTargetESP()
        if not State.TargetESP.TargetESPActive.Value or #targetESPQuads == 0 then return end
        local targetName = nil
        if State.TargetESP.TargetESPType.Value == "All" and Core.BulwarkTarget.CurrentTarget then
            targetName = Core.BulwarkTarget.CurrentTarget
        elseif State.TargetESP.TargetESPType.Value == "KillAura" and Core.BulwarkTarget.KillAuraTarget then
            targetName = Core.BulwarkTarget.KillAuraTarget
        elseif State.TargetESP.TargetESPType.Value == "AutoDodge" and Core.BulwarkTarget.AutoDodgeTarget then
            targetName = Core.BulwarkTarget.AutoDodgeTarget
        end

        if targetName and Players:FindFirstChild(targetName) then
            local targetPlayer = Players:FindFirstChild(targetName)
            if targetPlayer.Character and targetPlayer.Character:FindFirstChild("HumanoidRootPart") then
                local rootPart = targetPlayer.Character.HumanoidRootPart
                local t = tick()
                local center = Vector3.new(rootPart.Position.X, rootPart.Position.Y + State.TargetESP.TargetESPYOffset.Value, rootPart.Position.Z)
                local screenCenter, onScreenCenter = camera:WorldToViewportPoint(center)
                if onScreenCenter and screenCenter.Z > 0 then
                    local espSegments = #targetESPQuads
                    local espRadius = State.TargetESP.TargetESPRadius.Value
                    for i, quad in ipairs(targetESPQuads) do
                        local angle1 = ((i - 1) / espSegments) * 2 * math.pi
                        local angle2 = (i / espSegments) * 2 * math.pi
                        local point1Bottom = center + Vector3.new(math.cos(angle1) * espRadius, 0, math.sin(angle1) * espRadius)
                        local point2Bottom = center + Vector3.new(math.cos(angle2) * espRadius, 0, math.sin(angle2) * espRadius)
                        local point1Top = point1Bottom + Vector3.new(0, 0, 0)
                        local point2Top = point2Bottom + Vector3.new(0, 0, 0)
                        local screenPoint1Bottom, onScreen1Bottom = camera:WorldToViewportPoint(point1Bottom)
                        local screenPoint2Bottom, onScreen2Bottom = camera:WorldToViewportPoint(point2Bottom)
                        local screenPoint1Top, onScreen1Top = camera:WorldToViewportPoint(point1Top)
                        local screenPoint2Top, onScreen2Top = camera:WorldToViewportPoint(point2Top)

                        if onScreen1Bottom and onScreen2Bottom and onScreen1Top and onScreen2Top and
                           screenPoint1Bottom.Z > 0 and screenPoint2Bottom.Z > 0 and
                           screenPoint1Top.Z > 0 and screenPoint2Top.Z > 0 then
                            quad.PointA = Vector2.new(screenPoint1Bottom.X, screenPoint1Bottom.Y)
                            quad.PointB = Vector2.new(screenPoint2Bottom.X, screenPoint2Bottom.Y)
                            quad.PointC = Vector2.new(screenPoint2Top.X, screenPoint2Top.Y)
                            quad.PointD = Vector2.new(screenPoint1Top.X, screenPoint1Top.Y)
                            quad.Visible = true
                            if State.TargetESP.TargetESPGradient.Value then
                                local factor = (math.sin(t * State.TargetESP.TargetESPGradientSpeed.Value + (i / espSegments) * 2 * math.pi) + 1) / 2
                                quad.Color = interpolateColor(Core.GradientColors.Color1.Value, Core.GradientColors.Color2.Value, factor)
                            else
                                quad.Color = State.TargetESP.TargetESPColor.Value
                            end
                        else
                            quad.Visible = false
                        end
                    end
                else
                    for _, quad in ipairs(targetESPQuads) do
                        quad.Visible = false
                    end
                end
            else
                removeParts(targetESPQuads)
            end
        else
            removeParts(targetESPQuads)
        end
    end

    local function animateJump()
        if not State.Circle.JumpAnimate.Value or #circleQuads == 0 or jumpAnimationActive then return end
        jumpAnimationActive = true
        local t = 0
        local duration = 0.55
        local initialRadius = State.Circle.CircleRadius.Value
        local maxRadius = State.Circle.CircleRadius.Value * 1.6
        while t < duration do
            local dt = RunService.RenderStepped:Wait()
            t = t + dt
            local factor = t / duration
            State.Circle.CircleRadius.Value = initialRadius + (maxRadius - initialRadius) * math.sin(factor * math.pi)
            updateCircle()
        end
        State.Circle.CircleRadius.Value = initialRadius
        jumpAnimationActive = false
    end

    local function toggleHat(value)
        State.ChinaHat.HatActive.Value = value
        if value then
            createHat()
            notify("ChinaHat", "Hat Enabled", true)
        else
            removeParts(hatLines)
            removeParts(hatCircleQuads)
            notify("ChinaHat", "Hat Disabled", true)
        end
    end

    local function toggleCircle(value)
        State.Circle.CircleActive.Value = value
        if value then
            createCircle()
            notify("Circle", "Circle Enabled", true)
        else
            removeParts(circleQuads)
            notify("Circle", "Circle Disabled", true)
        end
    end

    local function toggleNimb(value)
        State.Nimb.NimbActive.Value = value
        if value then
            createNimb()
            notify("Nimb", "Nimb Enabled", true)
        else
            removeParts(nimbQuads)
            notify("Nimb", "Nimb Disabled", true)
        end
    end

    local function toggleTargetESP(value)
        State.TargetESP.TargetESPActive.Value = value
        if value then
            createTargetESP()
            notify("TargetESP", "Target ESP Enabled", true)
        else
            removeParts(targetESPQuads)
            notify("TargetESP", "Target ESP Disabled", true)
        end
    end

    RunService.Stepped:Connect(function(deltaTime)
        updateHat()
        updateCircle()
        updateNimb()
        updateTargetESP()
    end)

    local function onStateChanged(oldState, newState)
        if State.Circle.JumpAnimate.Value and newState == Enum.HumanoidStateType.Jumping and not jumpAnimationActive then
            animateJump()
        end
    end

    LocalPlayer.CharacterAdded:Connect(function(character)
        localCharacter = character
        localHumanoid = character:WaitForChild("Humanoid", 5)
        localHumanoid.StateChanged:Connect(onStateChanged)
    end)

    if localCharacter then
        localHumanoid = localCharacter:WaitForChild("Humanoid", 5)
        localHumanoid.StateChanged:Connect(onStateChanged)
    end

    if UI.Tabs and UI.Tabs.Visuals then
        local chinaHatSection = UI.Sections.ChinaHat or UI.Tabs.Visuals:Section({ Name = "ChinaHat", Side = "Left" })
        UI.Sections.ChinaHat = chinaHatSection
        chinaHatSection:Header({ Name = "China Hat" })
        chinaHatSection:SubLabel({ Text = "Displays a hat-like effect above the player's head" })
        chinaHatSection:Toggle({
            Name = "Hat Enabled",
            Default = State.ChinaHat.HatActive.Default,
            Callback = function(value)
                toggleHat(value)
            end,
            'HatEnabled'
        })
        chinaHatSection:Slider({
            Name = "Hat Scale",
            Minimum = 0.5,
            Maximum = 2.0,
            Default = State.ChinaHat.HatScale.Default,
            Precision = 2,
            Callback = function(value)
                if State.ChinaHat.HatActive.Value then
                    removeParts(hatLines)
                    removeParts(hatCircleQuads)
                    State.ChinaHat.HatScale.Value = value
                    createHat()
                else
                    State.ChinaHat.HatScale.Value = value
                end
                notify("ChinaHat", "Hat Scale set to: " .. value, false)
            end,
            'HatScale'
        })
        chinaHatSection:Slider({
            Name = "Hat Parts",
            Minimum = 20,
            Maximum = 150,
            Default = State.ChinaHat.HatParts.Default,
            Precision = 0,
            Callback = function(value)
                if State.ChinaHat.HatActive.Value then
                    removeParts(hatLines)
                    removeParts(hatCircleQuads)
                    State.ChinaHat.HatParts.Value = value
                    createHat()
                else
                    State.ChinaHat.HatParts.Value = value
                end
                notify("ChinaHat", "Hat Parts set to: " .. value, false)
            end,
            'HatParts'
        })
        chinaHatSection:Slider({
            Name = "Gradient Speed",
            Minimum = 1,
            Maximum = 10,
            Default = State.ChinaHat.HatGradientSpeed.Default,
            Precision = 1,
            Callback = function(value)
                State.ChinaHat.HatGradientSpeed.Value = value
                if State.ChinaHat.HatActive.Value then
                    updateHat()
                end
                notify("ChinaHat", "Hat Gradient Speed set to: " .. value, false)
            end,
            'HatGradientSpeed'
        })
        chinaHatSection:Toggle({
            Name = "Gradient",
            Default = State.ChinaHat.HatGradient.Default,
            Callback = function(value)
                State.ChinaHat.HatGradient.Value = value
                if State.ChinaHat.HatActive.Value then
                    removeParts(hatLines)
                    removeParts(hatCircleQuads)
                    createHat()
                end
                notify("ChinaHat", "Hat Gradient: " .. (value and "Enabled" or "Disabled"), true)
            end,
            'HatGradient'
        })
        chinaHatSection:Colorpicker({
            Name = "Color",
            Default = State.ChinaHat.HatColor.Default,
            Callback = function(value)
                State.ChinaHat.HatColor.Value = value
                if State.ChinaHat.HatActive.Value and not State.ChinaHat.HatGradient.Value then
                    removeParts(hatLines)
                    removeParts(hatCircleQuads)
                    createHat()
                end
                notify("ChinaHat", "Hat Color updated", false)
            end,
            'HatColor'
        })
        chinaHatSection:Slider({
            Name = "Y Offset",
            Minimum = -5,
            Maximum = 5,
            Default = State.ChinaHat.HatYOffset.Default,
            Precision = 2,
            Callback = function(value)
                if State.ChinaHat.HatActive.Value then
                    removeParts(hatLines)
                    removeParts(hatCircleQuads)
                    State.ChinaHat.HatYOffset.Value = value
                    createHat()
                else
                    State.ChinaHat.HatYOffset.Value = value
                end
                notify("ChinaHat", "Hat Y Offset set to: " .. value, false)
            end,
            'HatYOffset'
        })
        chinaHatSection:Toggle({
            Name = "Outline Circle",
            Default = State.ChinaHat.OutlineCircle.Default,
            Callback = function(value)
                State.ChinaHat.OutlineCircle.Value = value
                if State.ChinaHat.HatActive.Value then
                    removeParts(hatCircleQuads)
                    createHat()
                end
                notify("ChinaHat", "Outline Circle: " .. (value and "Enabled" or "Disabled"), true)
            end,
            'OutlineCircle'
        })

        local circleSection = UI.Sections.Circle or UI.Tabs.Visuals:Section({ Name = "Circle", Side = "Left" })
        UI.Sections.Circle = circleSection
        circleSection:Header({ Name = "Circle" })
        circleSection:SubLabel({ Text = "Displays a circle effect at the player's feet" })
        circleSection:Toggle({
            Name = "Circle Enabled",
            Default = State.Circle.CircleActive.Default,
            Callback = function(value)
                toggleCircle(value)
            end,
            'CircleEnabled'
        })
        circleSection:Slider({
            Name = "Circle Radius",
            Minimum = 1.0,
            Maximum = 3.0,
            Default = State.Circle.CircleRadius.Default,
            Precision = 1,
            Callback = function(value)
                if State.Circle.CircleActive.Value then
                    removeParts(circleQuads)
                    State.Circle.CircleRadius.Value = value
                    createCircle()
                else
                    State.Circle.CircleRadius.Value = value
                end
                notify("Circle", "Circle Radius set to: " .. value, false)
            end,
            'CircleRadius'
        })
        circleSection:Slider({
            Name = "Circle Parts",
            Minimum = 20,
            Maximum = 100,
            Default = State.Circle.CircleParts.Default,
            Precision = 0,
            Callback = function(value)
                if State.Circle.CircleActive.Value then
                    removeParts(circleQuads)
                    State.Circle.CircleParts.Value = value
                    createCircle()
                else
                    State.Circle.CircleParts.Value = value
                end
                notify("Circle", "Circle Parts set to: " .. value, false)
            end,
            'CircleParts'
        })
        circleSection:Slider({
            Name = "Gradient Speed",
            Minimum = 1,
            Maximum = 10,
            Default = State.Circle.CircleGradientSpeed.Default,
            Precision = 1,
            Callback = function(value)
                State.Circle.CircleGradientSpeed.Value = value
                if State.Circle.CircleActive.Value then
                    updateCircle()
                end
                notify("Circle", "Circle Gradient Speed set to: " .. value, false)
            end,
            'CircleGradientSpeed'
        })
        circleSection:Toggle({
            Name = "Gradient",
            Default = State.Circle.CircleGradient.Default,
            Callback = function(value)
                State.Circle.CircleGradient.Value = value
                if State.Circle.CircleActive.Value then
                    removeParts(circleQuads)
                    createCircle()
                end
                notify("Circle", "Circle Gradient: " .. (value and "Enabled" or "Disabled"), true)
            end,
            'CircleGradient'
        })
        circleSection:Colorpicker({
            Name = "Color",
            Default = State.Circle.CircleColor.Default,
            Callback = function(value)
                State.Circle.CircleColor.Value = value
                if State.Circle.CircleActive.Value and not State.Circle.CircleGradient.Value then
                    removeParts(circleQuads)
                    createCircle()
                end
                notify("Circle", "Circle Color updated", false)
            end,
            'CircleColor'
        })
        circleSection:Toggle({
            Name = "Jump Animate",
            Default = State.Circle.JumpAnimate.Default,
            Callback = function(value)
                State.Circle.JumpAnimate.Value = value
                notify("Circle", "Jump Animation: " .. (value and "Enabled" or "Disabled"), true)
            end,
            'JumpAnimate'
        })

        local nimbSection = UI.Sections.Nimb or UI.Tabs.Visuals:Section({ Name = "Nimb", Side = "Right" })
        UI.Sections.Nimb = nimbSection
        nimbSection:Header({ Name = "Nimb" })
        nimbSection:SubLabel({ Text = "Displays a circle effect above the player's head" })
        nimbSection:Toggle({
            Name = "Nimb Enabled",
            Default = State.Nimb.NimbActive.Default,
            Callback = function(value)
                toggleNimb(value)
            end,
            'NimbEnabled'
        })
        nimbSection:Slider({
            Name = "Nimb Radius",
            Minimum = 1.0,
            Maximum = 3.0,
            Default = State.Nimb.NimbRadius.Default,
            Precision = 1,
            Callback = function(value)
                if State.Nimb.NimbActive.Value then
                    removeParts(nimbQuads)
                    State.Nimb.NimbRadius.Value = value
                    createNimb()
                else
                    State.Nimb.NimbRadius.Value = value
                end
                notify("Nimb", "Nimb Radius set to: " .. value, false)
            end,
            'NimbRadius'
        })
        nimbSection:Slider({
            Name = "Nimb Parts",
            Minimum = 20,
            Maximum = 100,
            Default = State.Nimb.NimbParts.Default,
            Precision = 0,
            Callback = function(value)
                if State.Nimb.NimbActive.Value then
                    removeParts(nimbQuads)
                    State.Nimb.NimbParts.Value = value
                    createNimb()
                else
                    State.Nimb.NimbParts.Value = value
                end
                notify("Nimb", "Nimb Parts set to: " .. value, false)
            end,
            'NimbParts'
        })
        nimbSection:Slider({
            Name = "Gradient Speed",
            Minimum = 1,
            Maximum = 10,
            Default = State.Nimb.NimbGradientSpeed.Default,
            Precision = 1,
            Callback = function(value)
                State.Nimb.NimbGradientSpeed.Value = value
                if State.Nimb.NimbActive.Value then
                    updateNimb()
                end
                notify("Nimb", "Nimb Gradient Speed set to: " .. value, false)
            end,
            'NimbGradientSpeed'
        })
        nimbSection:Toggle({
            Name = "Gradient",
            Default = State.Nimb.NimbGradient.Default,
            Callback = function(value)
                State.Nimb.NimbGradient.Value = value
                if State.Nimb.NimbActive.Value then
                    removeParts(nimbQuads)
                    createNimb()
                end
                notify("Nimb", "Nimb Gradient: " .. (value and "Enabled" or "Disabled"), true)
            end,
            'NimbGradient'
        })
        nimbSection:Colorpicker({
            Name = "Color",
            Default = State.Nimb.NimbColor.Default,
            Callback = function(value)
                State.Nimb.NimbColor.Value = value
                if State.Nimb.NimbActive.Value and not State.Nimb.NimbGradient.Value then
                    removeParts(nimbQuads)
                    createNimb()
                end
                notify("Nimb", "Nimb Color updated", false)
            end,
            'NimbColor'
        })
        nimbSection:Slider({
            Name = "Y Offset",
            Minimum = 1,
            Maximum = 3,
            Default = State.Nimb.NimbYOffset.Default,
            Precision = 2,
            Callback = function(value)
                if State.Nimb.NimbActive.Value then
                    removeParts(nimbQuads)
                    State.Nimb.NimbYOffset.Value = value
                    createNimb()
                else
                    State.Nimb.NimbYOffset.Value = value
                end
                notify("Nimb", "Nimb Y Offset set to: " .. value, false)
            end,
            'NimbYOffset'
        })

        local targetESPSection = UI.Sections.TargetESP or UI.Tabs.Visuals:Section({ Name = "TargetESP", Side = "Right" })
        UI.Sections.TargetESP = targetESPSection
        targetESPSection:Header({ Name = "Target ESP" })
        targetESPSection:SubLabel({ Text = "Displays a circle effect above the target player" })
        targetESPSection:Toggle({
            Name = "Target ESP Enabled",
            Default = State.TargetESP.TargetESPActive.Default,
            Callback = function(value)
                toggleTargetESP(value)
            end,
            'TargetESPEnabled'
        })
        targetESPSection:Slider({
            Name = "Target ESP Radius",
            Minimum = 1.0,
            Maximum = 3.0,
            Default = State.TargetESP.TargetESPRadius.Default,
            Precision = 1,
            Callback = function(value)
                if State.TargetESP.TargetESPActive.Value then
                    removeParts(targetESPQuads)
                    State.TargetESP.TargetESPRadius.Value = value
                    createTargetESP()
                else
                    State.TargetESP.TargetESPRadius.Value = value
                end
                notify("TargetESP", "Target ESP Radius set to: " .. value, false)
            end,
            'TargetESPRadius'
        })
        targetESPSection:Slider({
            Name = "Target ESP Parts",
            Minimum = 20,
            Maximum = 100,
            Default = State.TargetESP.TargetESPParts.Default,
            Precision = 0,
            Callback = function(value)
                if State.TargetESP.TargetESPActive.Value then
                    removeParts(targetESPQuads)
                    State.TargetESP.TargetESPParts.Value = value
                    createTargetESP()
                else
                    State.TargetESP.TargetESPParts.Value = value
                end
                notify("TargetESP", "Target ESP Parts set to: " .. value, false)
            end,
            'TargetESPParts'
        })
        targetESPSection:Slider({
            Name = "Gradient Speed",
            Minimum = 1,
            Maximum = 10,
            Default = State.TargetESP.TargetESPGradientSpeed.Default,
            Precision = 1,
            Callback = function(value)
                State.TargetESP.TargetESPGradientSpeed.Value = value
                if State.TargetESP.TargetESPActive.Value then
                    updateTargetESP()
                end
                notify("TargetESP", "Target ESP Gradient Speed set to: " .. value, false)
            end,
            'TargetESPGradientSpeed'
        })
        targetESPSection:Toggle({
            Name = "Gradient",
            Default = State.TargetESP.TargetESPGradient.Default,
            Callback = function(value)
                State.TargetESP.TargetESPGradient.Value = value
                if State.TargetESP.TargetESPActive.Value then
                    removeParts(targetESPQuads)
                    createTargetESP()
                end
                notify("TargetESP", "Target ESP Gradient: " .. (value and "Enabled" or "Disabled"), true)
            end,
            'TargetESPGradient'
        })
        targetESPSection:Colorpicker({
            Name = "Color",
            Default = State.TargetESP.TargetESPColor.Default,
            Callback = function(value)
                State.TargetESP.TargetESPColor.Value = value
                if State.TargetESP.TargetESPActive.Value and not State.TargetESP.TargetESPGradient.Value then
                    removeParts(targetESPQuads)
                    createTargetESP()
                end
                notify("TargetESP", "Target ESP Color updated", false)
            end,
            'TargetESPColor'
        })
        targetESPSection:Slider({
            Name = "Y Offset",
            Minimum = -5,
            Maximum = 5,
            Default = State.TargetESP.TargetESPYOffset.Default,
            Precision = 2,
            Callback = function(value)
                if State.TargetESP.TargetESPActive.Value then
                    removeParts(targetESPQuads)
                    State.TargetESP.TargetESPYOffset.Value = value
                    createTargetESP()
                else
                    State.TargetESP.TargetESPYOffset.Value = value
                end
                notify("TargetESP", "Target ESP Y Offset set to: " .. value, false)
            end,
            'TargetESPYOffset'
        })
        targetESPSection:Dropdown({
            Name = "Target Type",
            Default = State.TargetESP.TargetESPType.Default,
            Options = State.TargetESP.TargetESPType.Options,
            Callback = function(value)
                State.TargetESP.TargetESPType.Value = value
                if State.TargetESP.TargetESPActive.Value then
                    removeParts(targetESPQuads)
                    createTargetESP()
                end
                notify("TargetESP", "Target Type set to: " .. value, false)
            end,
            'TargetESPType'
        })
    end

    return ChinaHat
end

return ChinaHat
