local BaitAttack = {}

function BaitAttack.Init(UI, Core, notify)
    local Players = game:GetService("Players")
    local ReplicatedStorage = game:GetService("ReplicatedStorage")
    local UserInputService = game:GetService("UserInputService")
    local Animation = game:GetService("Animation")
    local CoreGui = game:GetService("CoreGui")
    local RunService = game:GetService("RunService")

    local LocalPlayer = Players.LocalPlayer
    local localCharacter = LocalPlayer.Character
    local localHumanoid = localCharacter and localCharacter:FindFirstChild("Humanoid")
    local defaultWalkSpeed = game:GetService("StarterPlayer").StarterHumanoid.WalkSpeed
    local swingWalkSpeed = defaultWalkSpeed * 0.75

    local State = {
        BaitAttack = {
            Enabled = { Value = false, Default = false },
            FakeParry = { Value = false, Default = false },
            FakeRiposte = { Value = false, Default = false },
            FakeAttack = { Value = false, Default = false },
            FakeParryKey = { Value = nil, Default = nil },
            FakeRiposteKey = { Value = nil, Default = nil },
            FakeAttackKey = { Value = nil, Default = nil },
            ForceStopKey = { Value = nil, Default = nil },
            CheckStance = { Value = false, Default = false },
            ParryHold = { Value = false, Default = false },
            ParryAutoHold = { Value = 2, Default = 2 },
            AutoHoldEnabled = { Value = true, Default = true },
            ForceStopEnabled = { Value = false, Default = false },
            KeybindDisplayEnabled = { Value = true, Default = true },
            KeybindDisplayScale = { Value = 1, Default = 1 },
            FadeColor = { Value = Color3.fromRGB(100, 150, 255), Default = Color3.fromRGB(100, 150, 255) },
            ParryDisplayEnabled = { Value = true, Default = true },
            RiposteDisplayEnabled = { Value = true, Default = true },
            AttackDisplayEnabled = { Value = true, Default = true },
            ForceStopDisplayEnabled = { Value = true, Default = true }
        }
    }

    local isPerformingAction = false
    local parryAnimationTrack = nil
    local parryHoldConnection = nil
    local inputConnection = nil
    local keybindDisplays = {}
    local keybindPositions = {}
    local draggingFrame = nil
    local dragStartPos = nil
    local dragStartMousePos = nil
    local activeFades = {}

    local function getLocalWeaponSettings()
        if not localCharacter then
            notify("BaitAttack", "No character found", false)
            return nil, nil
        end
        local weapon
        for _, child in pairs(localCharacter:GetChildren()) do
            if child:IsA("Tool") then
                weapon = child
                break
            end
        end
        if not weapon then
            notify("BaitAttack", "No weapon equipped", false)
            return nil, nil
        end
        local settingsModule = weapon:FindFirstChild("Settings")
        if not settingsModule then
            notify("BaitAttack", "No settings module found", false)
            return nil, nil
        end
        local settings = require(settingsModule)
        if not settings or type(settings) ~= "table" or not settings.Type then
            notify("BaitAttack", "Invalid weapon settings", false)
            return nil, nil
        end
        return settings, weapon
    end

    local function getCurrentStance()
        if not localCharacter then
            return nil
        end
        local stanceValue = localCharacter:FindFirstChild("Stance", true)
        return stanceValue and stanceValue.Value or "Idle"
    end

    local function isInputFocused()
        return UserInputService:GetFocusedTextBox() ~= nil
    end

    local function lerpColor(startColor, endColor, alpha)
        return Color3.new(
            startColor.R + (endColor.R - startColor.R) * alpha,
            startColor.G + (endColor.G - startColor.G) * alpha,
            startColor.B + (endColor.B - startColor.B) * alpha
        )
    end

    local function startFade(label, keyName, toColor)
        if activeFades[keyName] then
            activeFades[keyName].Connection:Disconnect()
            activeFades[keyName] = nil
        end
        local startTime = tick()
        local duration = 0.3
        local startColor = label.TextColor3
        local connection
        connection = RunService.Heartbeat:Connect(function()
            local elapsed = tick() - startTime
            local alpha = math.clamp(elapsed / duration, 0, 1)
            label.TextColor3 = lerpColor(startColor, toColor, alpha)
            if alpha >= 1 then
                connection:Disconnect()
                activeFades[keyName] = nil
            end
        end)
        activeFades[keyName] = { Connection = connection }
    end

    local function stopFade(label, keyName)
        if activeFades[keyName] then
            activeFades[keyName].Connection:Disconnect()
            activeFades[keyName] = nil
        end
        local startTime = tick()
        local duration = 0.3
        local startColor = label.TextColor3
        local endColor = Color3.fromRGB(255, 255, 255)
        local connection
        connection = RunService.Heartbeat:Connect(function()
            local elapsed = tick() - startTime
            local alpha = math.clamp(elapsed / duration, 0, 1)
            label.TextColor3 = lerpColor(startColor, endColor, alpha)
            if alpha >= 1 then
                connection:Disconnect()
                activeFades[keyName] = nil
            end
        end)
        activeFades[keyName] = { Connection = connection }
    end

    local function playAnimation(action)
        if isPerformingAction then
            notify("BaitAttack", "Already performing an action", false)
            return false
        end
        if not (localCharacter and localHumanoid and localHumanoid.Health > 0) then
            notify("BaitAttack", "Character or Humanoid invalid", false)
            return false
        end
        if State.BaitAttack.CheckStance.Value then
            local currentStance = getCurrentStance()
            if currentStance ~= "Idle" and currentStance ~= "Recovery" then
                notify("BaitAttack", "Invalid stance: " .. tostring(currentStance), false)
                return false
            end
        end
        isPerformingAction = true
        local settings, weapon = getLocalWeaponSettings()
        if not settings or not settings.Type then
            isPerformingAction = false
            return false
        end
        local animationsModule = ReplicatedStorage:FindFirstChild("ClientModule") and ReplicatedStorage.ClientModule:FindFirstChild("WeaponAnimations")
        if not animationsModule then
            notify("BaitAttack", "WeaponAnimations module not found", false)
            isPerformingAction = false
            return false
        end
        local animations = require(animationsModule)[settings.Type]
        if not animations then
            notify("BaitAttack", "No animations for weapon type: " .. tostring(settings.Type), false)
            isPerformingAction = false
            return false
        end
        local animationId
        if action == "FakeAttack" then
            local swingAnimations = {animations.RightSwing, animations.LeftSwing}
            animationId = swingAnimations[math.random(1, #swingAnimations)]
        else
            animationId = animations[action]
        end
        if not animationId then
            notify("BaitAttack", "No animation ID for action: " .. action, false)
            isPerformingAction = false
            return false
        end
        local animation = Instance.new("Animation")
        animation.AnimationId = "rbxassetid://" .. animationId
        local success, animationTrack = pcall(function()
            return localHumanoid:LoadAnimation(animation)
        end)
        if not success or not animationTrack then
            notify("BaitAttack", "Failed to load animation for " .. action, false)
            animation:Destroy()
            isPerformingAction = false
            return false
        end
        
        if action == "Parry" then
            parryAnimationTrack = animationTrack
            animationTrack:Play(0.1)
            animationTrack:AdjustSpeed(1)
            if localHumanoid then
                localHumanoid.WalkSpeed = 7
            end
            if State.BaitAttack.ParryHold.Value then
                -- Handled in onInputBegan
            elseif State.BaitAttack.AutoHoldEnabled.Value then
                task.spawn(function()
                    task.wait(State.BaitAttack.ParryAutoHold.Value)
                    if animationTrack and animationTrack.IsPlaying then
                        animationTrack:Stop(0.2)
                        animationTrack:Destroy()
                        parryAnimationTrack = nil
                    end
                    if localHumanoid then
                        localHumanoid.WalkSpeed = defaultWalkSpeed
                    end
                    isPerformingAction = false
                    if keybindDisplays.Parry then
                        stopFade(keybindDisplays.Parry.KeyLabel, "Parry")
                    end
                end)
            else
                task.spawn(function()
                    task.wait(0.4)
                    if animationTrack and animationTrack.IsPlaying then
                        animationTrack:Stop(0.2)
                        animationTrack:Destroy()
                        parryAnimationTrack = nil
                    end
                    if localHumanoid then
                        localHumanoid.WalkSpeed = defaultWalkSpeed
                    end
                    isPerformingAction = false
                    if keybindDisplays.Parry then
                        stopFade(keybindDisplays.Parry.KeyLabel, "Parry")
                    end
                end)
            end
        elseif action == "Riposte" then
            animationTrack:Play(0.1)
            animationTrack:AdjustSpeed(0)
            if localHumanoid then
                localHumanoid.WalkSpeed = 1
            end
            task.spawn(function()
                task.wait(0.5)
                if animationTrack and animationTrack.IsPlaying and animationTrack.TimePosition == 0 then
                    animationTrack:Stop(0.7)
                    animationTrack:Destroy()
                end
                if localHumanoid then
                    localHumanoid.WalkSpeed = defaultWalkSpeed
                end
                isPerformingAction = false
                if keybindDisplays.Riposte then
                    stopFade(keybindDisplays.Riposte.KeyLabel, "Riposte")
                end
            end)
        elseif action == "FakeAttack" then
            animationTrack:Play(settings.Windup or 0.3)
            animationTrack:AdjustSpeed(0)
            if localHumanoid then
                localHumanoid.WalkSpeed = swingWalkSpeed
            end
            task.spawn(function()
                task.wait(settings.Windup or 0.3)
                if animationTrack and animationTrack.IsPlaying then
                    animationTrack:AdjustSpeed((animationTrack.Length / (settings.Release or 0.3)) * 2)
                    task.wait(settings.Release or 0.3)
                    if animationTrack and animationTrack.IsPlaying then
                        animationTrack:Stop(settings.Recovery or 0.45)
                        animationTrack:Destroy()
                    end
                    if localHumanoid then
                        localHumanoid.WalkSpeed = defaultWalkSpeed
                    end
                    isPerformingAction = false
                    if keybindDisplays.Attack then
                        stopFade(keybindDisplays.Attack.KeyLabel, "Attack")
                    end
                end
            end)
        end
        return true
    end

    local function forceStop()
        if not (localCharacter and localHumanoid and localHumanoid.Health > 0) then
            notify("BaitAttack", "Cannot force stop: invalid character", false)
            return false
        end
        isPerformingAction = false
        State.BaitAttack.FakeParry.Value = false
        State.BaitAttack.FakeRiposte.Value = false
        State.BaitAttack.FakeAttack.Value = false
        Core.BulwarkTarget.CombatState = nil

        local stanceValue = localCharacter:FindFirstChild("Stance", true)
        if stanceValue then
            stanceValue.Value = "Idle"
        end
        local args = { [1] = "Idle" }
        local changeStanceEvent = ReplicatedStorage:WaitForChild("RemoteEvents"):WaitForChild("ToServer"):WaitForChild("ChangeStance")
        if changeStanceEvent and changeStanceEvent:IsA("RemoteEvent") then
            changeStanceEvent:FireServer(unpack(args))
        end
        task.spawn(function()
            local startTime = tick()
            while tick() - startTime < 3 do
                if stanceValue and stanceValue.Value ~= "Idle" then
                    stanceValue.Value = "Idle"
                    if changeStanceEvent and changeStanceEvent:IsA("RemoteEvent") then
                        changeStanceEvent:FireServer(unpack(args))
                    end
                end
                task.wait(0.1)
            end
        end)
        if keybindDisplays.ForceStop then
            startFade(keybindDisplays.ForceStop.KeyLabel, "ForceStop", State.BaitAttack.FadeColor.Value)
            task.spawn(function()
                task.wait(0.3)
                if keybindDisplays.ForceStop then
                    stopFade(keybindDisplays.ForceStop.KeyLabel, "ForceStop")
                end
            end)
        end
        return true
    end

    local function updateKeybindDisplays()
        for _, display in pairs(keybindDisplays) do
            keybindPositions[display.Frame.Name] = display.Frame.Position
            display.Frame:Destroy()
        end
        keybindDisplays = {}
        activeFades = {}

        if not State.BaitAttack.Enabled.Value or not State.BaitAttack.KeybindDisplayEnabled.Value then
            return
        end

        local keybinds = {
            { Name = "Parry", Key = State.BaitAttack.FakeParryKey, Enabled = State.BaitAttack.ParryDisplayEnabled.Value },
            { Name = "Riposte", Key = State.BaitAttack.FakeRiposteKey, Enabled = State.BaitAttack.RiposteDisplayEnabled.Value },
            { Name = "Attack", Key = State.BaitAttack.FakeAttackKey, Enabled = State.BaitAttack.AttackDisplayEnabled.Value },
            { Name = "ForceStop", Key = State.BaitAttack.ForceStopKey, Enabled = State.BaitAttack.ForceStopDisplayEnabled.Value }
        }

        local screenGui = Instance.new("ScreenGui")
        screenGui.Name = "BaitAttackKeybinds"
        screenGui.Parent = CoreGui
        screenGui.ResetOnSpawn = false

        local visibleKeybinds = {}
        for _, keybind in ipairs(keybinds) do
            if keybind.Enabled then
                table.insert(visibleKeybinds, keybind)
            end
        end

        for i, keybind in ipairs(visibleKeybinds) do
            local frame = Instance.new("Frame")
            local scale = State.BaitAttack.KeybindDisplayScale.Value
            frame.Name = keybind.Name
            frame.Size = UDim2.new(0, 75 * scale, 0, 75 * scale)
            frame.Position = keybindPositions[keybind.Name] or UDim2.new(0, (i - 1) * (90 * scale) + 10, 0, 10)
            frame.BackgroundTransparency = 1
            frame.ClipsDescendants = true
            frame.Parent = screenGui

            local topFrame = Instance.new("Frame")
            topFrame.Size = UDim2.new(1, 0, 0.4, 0)
            topFrame.BackgroundColor3 = Color3.fromRGB(15, 25, 45)
            topFrame.BorderSizePixel = 0
            local uiCornerTop = Instance.new("UICorner")
            uiCornerTop.CornerRadius = UDim.new(0, 8 * scale)
            uiCornerTop.Parent = topFrame
            topFrame.Parent = frame

            local maskFrame = Instance.new("Frame")
            maskFrame.Size = UDim2.new(1, 0, 0.5, 0)
            maskFrame.Position = UDim2.new(0, 0, 0.5, 0)
            maskFrame.BackgroundColor3 = Color3.fromRGB(15, 25, 45)
            maskFrame.BorderSizePixel = 0
            maskFrame.Parent = topFrame

            local icon = Instance.new("ImageLabel")
            icon.Size = UDim2.new(0, 22 * scale, 0, 22 * scale)
            icon.Position = UDim2.new(0.5, 0, 0.01, 0)
            icon.AnchorPoint = Vector2.new(0.5, 0.01)
            icon.Image = "rbxassetid://11710306232"
            icon.ImageColor3 = Color3.fromRGB(150, 150, 150)
            icon.ImageTransparency = 0.5
            icon.BackgroundTransparency = 1
            icon.Parent = topFrame

            local nameLabel = Instance.new("TextLabel")
            nameLabel.Size = UDim2.new(1, 0, 0, 15 * scale)
            nameLabel.Position = UDim2.new(0, 0, 0.35, 0)
            nameLabel.Text = keybind.Name
            nameLabel.TextColor3 = Color3.fromRGB(255, 255, 255)
            nameLabel.TextScaled = false
            nameLabel.TextSize = 16 * scale
            nameLabel.Font = Enum.Font.Gotham
            nameLabel.BackgroundTransparency = 1
            nameLabel.Parent = topFrame

            local bottomFrameContainer = Instance.new("Frame")
            bottomFrameContainer.Size = UDim2.new(1, 0, 0.6, 0)
            bottomFrameContainer.Position = UDim2.new(0, 0, 0.4, 0)
            bottomFrameContainer.BackgroundTransparency = 1
            bottomFrameContainer.ClipsDescendants = true
            bottomFrameContainer.Parent = frame

            local bottomFrame = Instance.new("Frame")
            bottomFrame.Size = UDim2.new(1, 0, 1, 8 * scale)
            bottomFrame.Position = UDim2.new(0, 0, 0, -8 * scale)
            bottomFrame.BackgroundColor3 = Color3.fromRGB(20, 30, 50)
            bottomFrame.BackgroundTransparency = 0.3
            bottomFrame.BorderSizePixel = 0
            local uiCornerBottom = Instance.new("UICorner")
            uiCornerBottom.CornerRadius = UDim.new(0, 8 * scale)
            uiCornerBottom.Parent = bottomFrame
            bottomFrame.Parent = bottomFrameContainer

            local keyLabel = Instance.new("TextLabel")
            keyLabel.Size = UDim2.new(1, 0, 1, 0)
            keyLabel.Position = UDim2.new(0.5, 0, 0.5, 0)
            keyLabel.AnchorPoint = Vector2.new(0.5, 0.5)
            keyLabel.Text = keybind.Key.Value and tostring(keybind.Key.Value):match("Enum%.KeyCode%.(.+)") or ""
            keyLabel.TextColor3 = Color3.fromRGB(255, 255, 255)
            keyLabel.TextScaled = false
            keyLabel.TextSize = 22 * scale
            keyLabel.Font = Enum.Font.Gotham
            keyLabel.BackgroundTransparency = 1
            keyLabel.Parent = bottomFrameContainer

            local function startDragging(input)
                if input.UserInputType == Enum.UserInputType.MouseButton1 and not isInputFocused() then
                    draggingFrame = frame
                    dragStartPos = frame.Position
                    dragStartMousePos = input.Position
                end
            end

            local function stopDragging(input)
                if input.UserInputType == Enum.UserInputType.MouseButton1 then
                    draggingFrame = nil
                    dragStartPos = nil
                    dragStartMousePos = nil
                    keybindPositions[frame.Name] = frame.Position
                end
            end

            topFrame.InputBegan:Connect(startDragging)
            topFrame.InputEnded:Connect(stopDragging)
            bottomFrameContainer.InputBegan:Connect(startDragging)
            bottomFrameContainer.InputEnded:Connect(stopDragging)

            keybindDisplays[keybind.Name] = { Frame = frame, KeyLabel = keyLabel }
        end

        UserInputService.InputChanged:Connect(function(input)
            if input.UserInputType == Enum.UserInputType.MouseMovement and draggingFrame then
                local delta = input.Position - dragStartMousePos
                draggingFrame.Position = UDim2.new(
                    dragStartPos.X.Scale,
                    dragStartPos.X.Offset + delta.X,
                    dragStartPos.Y.Scale,
                    dragStartPos.Y.Offset + delta.Y
                )
            end
        end)
    end

    local function onInputBegan(input, gameProcessedEvent)
        if gameProcessedEvent or isInputFocused() or not localCharacter or not localHumanoid or localHumanoid.Health <= 0 or not State.BaitAttack.Enabled.Value then
            return
        end
        if input.KeyCode == State.BaitAttack.FakeParryKey.Value and not State.BaitAttack.FakeParry.Value then
            State.BaitAttack.FakeParry.Value = true
            if playAnimation("Parry") then
                notify("BaitAttack", "Fake Parry Activated", true)
                Core.BulwarkTarget.CombatState = "BaitAttack (FakeParry)"
                if keybindDisplays.Parry then
                    startFade(keybindDisplays.Parry.KeyLabel, "Parry", State.BaitAttack.FadeColor.Value)
                end
                if State.BaitAttack.ParryHold.Value then
                    parryHoldConnection = UserInputService.InputEnded:Connect(function(endInput)
                        if endInput.KeyCode == State.BaitAttack.FakeParryKey.Value then
                            if parryAnimationTrack and parryAnimationTrack.IsPlaying then
                                parryAnimationTrack:Stop(0.2)
                                parryAnimationTrack:Destroy()
                                parryAnimationTrack = nil
                            end
                            if localHumanoid then
                                localHumanoid.WalkSpeed = defaultWalkSpeed
                            end
                            isPerformingAction = false
                            State.BaitAttack.FakeParry.Value = false
                            Core.BulwarkTarget.CombatState = nil
                            if keybindDisplays.Parry then
                                stopFade(keybindDisplays.Parry.KeyLabel, "Parry")
                            end
                            if parryHoldConnection then
                                parryHoldConnection:Disconnect()
                                parryHoldConnection = nil
                            end
                        end
                    end)
                end
                if not State.BaitAttack.ParryHold.Value and State.BaitAttack.AutoHoldEnabled.Value then
                    task.spawn(function()
                        task.wait(State.BaitAttack.ParryAutoHold.Value)
                        State.BaitAttack.FakeParry.Value = false
                        Core.BulwarkTarget.CombatState = nil
                    end)
                end
            else
                State.BaitAttack.FakeParry.Value = false
                if keybindDisplays.Parry then
                    stopFade(keybindDisplays.Parry.KeyLabel, "Parry")
                end
            end
        elseif input.KeyCode == State.BaitAttack.FakeRiposteKey.Value and not State.BaitAttack.FakeRiposte.Value then
            State.BaitAttack.FakeRiposte.Value = true
            if playAnimation("Riposte") then
                notify("BaitAttack", "Fake Riposte Activated", true)
                Core.BulwarkTarget.CombatState = "BaitAttack (FakeRiposte)"
                if keybindDisplays.Riposte then
                    startFade(keybindDisplays.Riposte.KeyLabel, "Riposte", State.BaitAttack.FadeColor.Value)
                end
                task.spawn(function()
                    task.wait(0.5)
                    State.BaitAttack.FakeRiposte.Value = false
                    Core.BulwarkTarget.CombatState = nil
                end)
            else
                State.BaitAttack.FakeRiposte.Value = false
                if keybindDisplays.Riposte then
                    stopFade(keybindDisplays.Riposte.KeyLabel, "Riposte")
                end
            end
        elseif input.KeyCode == State.BaitAttack.FakeAttackKey.Value and not State.BaitAttack.FakeAttack.Value then
            State.BaitAttack.FakeAttack.Value = true
            if playAnimation("FakeAttack") then
                notify("BaitAttack", "Fake Attack Activated", true)
                Core.BulwarkTarget.CombatState = "BaitAttack (FakeAttack)"
                if keybindDisplays.Attack then
                    startFade(keybindDisplays.Attack.KeyLabel, "Attack", State.BaitAttack.FadeColor.Value)
                end
                task.spawn(function()
                    task.wait(0.5)
                    State.BaitAttack.FakeAttack.Value = false
                    Core.BulwarkTarget.CombatState = nil
                end)
            else
                State.BaitAttack.FakeAttack.Value = false
                if keybindDisplays.Attack then
                    stopFade(keybindDisplays.Attack.KeyLabel, "Attack")
                end
            end
        elseif input.KeyCode == State.BaitAttack.ForceStopKey.Value and State.BaitAttack.ForceStopEnabled.Value then
            if forceStop() then
                notify("BaitAttack", "Force Stop Activated", true)
            end
        end
    end

    local function start()
        if inputConnection then
            return
        end
        inputConnection = UserInputService.InputBegan:Connect(onInputBegan)
        updateKeybindDisplays()
    end

    local function stop()
        if inputConnection then
            inputConnection:Disconnect()
            inputConnection = nil
        end
        if parryAnimationTrack and parryAnimationTrack.IsPlaying then
            parryAnimationTrack:Stop(0.2)
            parryAnimationTrack:Destroy()
            parryAnimationTrack = nil
        end
        if parryHoldConnection then
            parryHoldConnection:Disconnect()
            parryHoldConnection = nil
        end
        if localHumanoid then
            for _, track in pairs(localHumanoid:GetPlayingAnimationTracks()) do
                track:Stop(0.2)
                track:Destroy()
            end
            localHumanoid.WalkSpeed = defaultWalkSpeed
        end
        isPerformingAction = false
        State.BaitAttack.FakeParry.Value = false
        State.BaitAttack.FakeRiposte.Value = false
        State.BaitAttack.FakeAttack.Value = false
        Core.BulwarkTarget.CombatState = nil
        for _, display in pairs(keybindDisplays) do
            display.Frame:Destroy()
        end
        keybindDisplays = {}
        activeFades = {}
        updateKeybindDisplays()
    end

    LocalPlayer.CharacterAdded:Connect(function(character)
        localCharacter = character
        localHumanoid = character:WaitForChild("Humanoid", 5)
        if State.BaitAttack.Enabled.Value then
            start()
        end
    end)

    if UI.Tabs and UI.Tabs.Combat then
        UI.Sections.BaitAttack = UI.Sections.BaitAttack or UI.Tabs.Combat:Section({ Name = "Bait Attack", Side = "Left" })
        UI.Sections.BaitAttack:Header({ Name = "Bait Attack" })
        UI.Sections.BaitAttack:SubLabel({ Text = "Plays fake Parry/Riposte/Attack animations without server interaction" })
        UI.Sections.BaitAttack:Toggle({
            Name = "Enabled",
            Default = State.BaitAttack.Enabled.Default,
            Callback = function(value)
                State.BaitAttack.Enabled.Value = value
                if value then
                    start()
                    notify("BaitAttack", "Enabled", true)
                else
                    stop()
                    notify("BaitAttack", "Disabled", true)
                end
            end,
            'BaitAttackEnabled'
        })
        UI.Sections.BaitAttack:Keybind({
            Name = "Fake Parry Key",
            Default = State.BaitAttack.FakeParryKey.Default,
            Callback = function(value)
                State.BaitAttack.FakeParryKey.Value = value
                updateKeybindDisplays()
                if keybindDisplays.Parry then
                    keybindDisplays.Parry.KeyLabel.Text = value and tostring(value):match("Enum%.KeyCode%.(.+)") or ""
                end
            end,
            'FakeParryKeyBA'
        })
        UI.Sections.BaitAttack:Keybind({
            Name = "Fake Riposte Key",
            Default = State.BaitAttack.FakeRiposteKey.Default,
            Callback = function(value)
                State.BaitAttack.FakeRiposteKey.Value = value
                updateKeybindDisplays()
                if keybindDisplays.Riposte then
                    keybindDisplays.Riposte.KeyLabel.Text = value and tostring(value):match("Enum%.KeyCode%.(.+)") or ""
                end
            end,
            'FakeRiposteKeyBA'
        })
        UI.Sections.BaitAttack:Keybind({
            Name = "Fake Attack Key",
            Default = State.BaitAttack.FakeAttackKey.Default,
            Callback = function(value)
                State.BaitAttack.FakeAttackKey.Value = value
                updateKeybindDisplays()
                if keybindDisplays.Attack then
                    keybindDisplays.Attack.KeyLabel.Text = value and tostring(value):match("Enum%.KeyCode%.(.+)") or ""
                end
            end,
            'FakeAttackKeyBA'
        })
        UI.Sections.BaitAttack:Divider()
        UI.Sections.BaitAttack:Toggle({
            Name = "Check Stance",
            Default = State.BaitAttack.CheckStance.Default,
            Callback = function(value)
                State.BaitAttack.CheckStance.Value = value
                notify("BaitAttack", "Check Stance: " .. (value and "Enabled" or "Disabled"), true)
            end,
            'CheckStanceBA'
        })
        UI.Sections.BaitAttack:SubLabel({ Text = "Prevents bait animations if player's Stance is not Idle or Recovery" })
        UI.Sections.BaitAttack:Divider()
        UI.Sections.BaitAttack:SubLabel({ Text = "Parry" })
        UI.Sections.BaitAttack:Toggle({
            Name = "Hold",
            Default = State.BaitAttack.ParryHold.Default,
            Callback = function(value)
                State.BaitAttack.ParryHold.Value = value
                notify("BaitAttack", "Parry Hold: " .. (value and "Enabled" or "Disabled"), true)
                if not value and parryAnimationTrack and parryAnimationTrack.IsPlaying then
                    parryAnimationTrack:Stop(0.2)
                    parryAnimationTrack:Destroy()
                    parryAnimationTrack = nil
                    if localHumanoid then
                        localHumanoid.WalkSpeed = defaultWalkSpeed
                    end
                    isPerformingAction = false
                    State.BaitAttack.FakeParry.Value = false
                    Core.BulwarkTarget.CombatState = nil
                    if keybindDisplays.Parry then
                        stopFade(keybindDisplays.Parry.KeyLabel, "Parry")
                    end
                end
            end,
            'ParryHoldBA'
        })
        UI.Sections.BaitAttack:Toggle({
            Name = "Auto Hold",
            Default = State.BaitAttack.AutoHoldEnabled.Default,
            Callback = function(value)
                State.BaitAttack.AutoHoldEnabled.Value = value
                notify("BaitAttack", "Auto Hold: " .. (value and "Enabled" or "Disabled"), true)
                if not value and parryAnimationTrack and parryAnimationTrack.IsPlaying and not State.BaitAttack.ParryHold.Value then
                    parryAnimationTrack:Stop(0.2)
                    parryAnimationTrack:Destroy()
                    parryAnimationTrack = nil
                    if localHumanoid then
                        localHumanoid.WalkSpeed = defaultWalkSpeed
                    end
                    isPerformingAction = false
                    State.BaitAttack.FakeParry.Value = false
                    Core.BulwarkTarget.CombatState = nil
                    if keybindDisplays.Parry then
                        stopFade(keybindDisplays.Parry.KeyLabel, "Parry")
                    end
                end
            end,
            'AutoHoldEnabledBA'
        })
        UI.Sections.BaitAttack:Slider({
            Name = "Auto Hold Duration",
            Minimum = 2,
            Maximum = 10,
            Default = State.BaitAttack.ParryAutoHold.Default,
            Precision = 1,
            Callback = function(value)
                State.BaitAttack.ParryAutoHold.Value = value
                notify("BaitAttack", "Parry Auto Hold set to: " .. value .. " seconds", false)
            end,
            'ParryAutoHoldBA'
        })
        UI.Sections.BaitAttack:Divider()
        UI.Sections.BaitAttack:SubLabel({ Text = "Force Stop" })
        UI.Sections.BaitAttack:Toggle({
            Name = "Enabled",
            Default = State.BaitAttack.ForceStopEnabled.Default,
            Callback = function(value)
                State.BaitAttack.ForceStopEnabled.Value = value
                notify("BaitAttack", "Force Stop: " .. (value and "Enabled" or "Disabled"), true)
            end,
            'ForceStopEnabledBA'
        })
        UI.Sections.BaitAttack:SubLabel({ Text = "Sets Stance to Idle without stopping animations" })
        UI.Sections.BaitAttack:Keybind({
            Name = "Force Stop Key",
            Default = State.BaitAttack.ForceStopKey.Default,
            Callback = function(value)
                State.BaitAttack.ForceStopKey.Value = value
                updateKeybindDisplays()
                if keybindDisplays.ForceStop then
                    keybindDisplays.ForceStop.KeyLabel.Text = value and tostring(value):match("Enum%.KeyCode%.(.+)") or ""
                end
            end,
            'ForceStopKeyBA'
        })

        UI.Sections.BaitAttackKeybinds = UI.Tabs.Visuals:Section({ Name = "BaitAttackKeybinds", Side = "Left" })
        UI.Sections.BaitAttackKeybinds:Header({ Name = "BaitAttack KeyBind" })
        UI.Sections.BaitAttackKeybinds:SubLabel({ Text = "Displays keybinds for BaitAttack actions on screen" })
        UI.Sections.BaitAttackKeybinds:Toggle({
            Name = "Enabled",
            Default = State.BaitAttack.KeybindDisplayEnabled.Default,
            Callback = function(value)
                State.BaitAttack.KeybindDisplayEnabled.Value = value
                if value then
                    updateKeybindDisplays()
                    notify("BaitAttack", "Keybind Displays Enabled", true)
                else
                    for _, display in pairs(keybindDisplays) do
                        display.Frame:Destroy()
                    end
                    keybindDisplays = {}
                    activeFades = {}
                    notify("BaitAttack", "Keybind Displays Disabled", true)
                end
            end,
            'KeybindDisplayEnabledBA'
        })
        UI.Sections.BaitAttackKeybinds:Slider({
            Name = "Scale",
            Minimum = 0.5,
            Maximum = 2.0,
            Default = State.BaitAttack.KeybindDisplayScale.Default,
            Precision = 1,
            Callback = function(value)
                State.BaitAttack.KeybindDisplayScale.Value = value
                updateKeybindDisplays()
                notify("BaitAttack", "Keybind Display Scale set to: " .. value, false)
            end,
            'KeybindDisplayScaleBA'
        })
        UI.Sections.BaitAttackKeybinds:Divider()
        UI.Sections.BaitAttackKeybinds:Toggle({
            Name = "Parry",
            Default = State.BaitAttack.ParryDisplayEnabled.Default,
            Callback = function(value)
                State.BaitAttack.ParryDisplayEnabled.Value = value
                updateKeybindDisplays()
                notify("BaitAttack", "Parry Keybind Display: " .. (value and "Enabled" or "Disabled"), true)
            end,
            'ParryDisplayEnabledBA'
        })
        UI.Sections.BaitAttackKeybinds:Toggle({
            Name = "Riposte",
            Default = State.BaitAttack.RiposteDisplayEnabled.Default,
            Callback = function(value)
                State.BaitAttack.RiposteDisplayEnabled.Value = value
                updateKeybindDisplays()
                notify("BaitAttack", "Riposte Keybind Display: " .. (value and "Enabled" or "Disabled"), true)
            end,
            'RiposteDisplayEnabledBA'
        })
        UI.Sections.BaitAttackKeybinds:Toggle({
            Name = "Attack",
            Default = State.BaitAttack.AttackDisplayEnabled.Default,
            Callback = function(value)
                State.BaitAttack.AttackDisplayEnabled.Value = value
                updateKeybindDisplays()
                notify("BaitAttack", "Attack Keybind Display: " .. (value and "Enabled" or "Disabled"), true)
            end,
            'AttackDisplayEnabledBA'
        })
        UI.Sections.BaitAttackKeybinds:Toggle({
            Name = "ForceStop",
            Default = State.BaitAttack.ForceStopDisplayEnabled.Default,
            Callback = function(value)
                State.BaitAttack.ForceStopDisplayEnabled.Value = value
                updateKeybindDisplays()
                notify("BaitAttack", "ForceStop Keybind Display: " .. (value and "Enabled" or "Disabled"), true)
            end,
            'ForceStopDisplayEnabledBA'
        })
        UI.Sections.BaitAttackKeybinds:Divider()
        UI.Sections.BaitAttackKeybinds:Colorpicker({
            Name = "Fade Color",
            Default = State.BaitAttack.FadeColor.Default,
            Callback = function(value)
                State.BaitAttack.FadeColor.Value = value
                notify("BaitAttack", "Fade Color Updated", true)
            end,
            'FadeColorBA'
        })

        updateKeybindDisplays()
    end

    return BaitAttack
end

return BaitAttack
