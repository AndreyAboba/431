local EntityX = {}
local workspace = game:GetService("Workspace")
local Camera = workspace.CurrentCamera
local Players = game:GetService("Players")
local LocalPlayer = Players.LocalPlayer

-- –ö—Ä–∞—Å–∏–≤–æ–µ –ª–æ–≥–∏—Ä–æ–≤–∞–Ω–∏–µ
local function Log(message, emoji)
    print("{" .. emoji .. "} EntityX | " .. message)
end

-- –ü—Ä–æ–≤–µ—Ä–∫–∞ –æ—à–∏–±–æ–∫ –∏ –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è
local function Initialize()
    local hasErrors = false
    if not workspace or not Camera then
        Log("Failed to initialize: Workspace or Camera not found.", "‚ùå")
        hasErrors = true
    end
    if hasErrors then
        Log("Loaded with errors, some features may be unavailable.", "üü†")
    else
        Log("Lightweight NPC interactions.", "üß†")
        Log("Loaded successfully!", "üü¢")
    end
end
Initialize()

-- Internal cache –¥–ª—è –æ–ø—Ç–∏–º–∏–∑–∞—Ü–∏–∏
local npcCache = {}
local lastUpdate = 0
local updateInterval = 0.3 -- –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ –∫—ç—à–∞ –∫–∞–∂–¥—ã–µ 0.3 —Å–µ–∫—É–Ω–¥—ã
local lastLog = 0
local logInterval = 2.0

-- –ö—ç—à –¥–ª—è –æ—Ç–¥–µ–ª—å–Ω—ã—Ö –ª–æ–∫–∞—Ü–∏–π
local locationCaches = {
    Missions = { cache = {}, lastUpdate = 0 },
    SpiderCave = { cache = {}, lastUpdate = 0 }
}

-- –ö–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—è –ø–æ–∏—Å–∫–∞ NPC
local npcConfig = {
    DistanceLimit = 120,
    TargetPart = "Head",
    MaxHealth = 100 -- –î–ª—è –Ω–æ—Ä–º–∞–ª–∏–∑–∞—Ü–∏–∏ –∑–¥–æ—Ä–æ–≤—å—è –≤ —Å–æ—Ä—Ç–∏—Ä–æ–≤–∫–µ
}

-- –ü—Ä–æ–≤–µ—Ä–∫–∞ –≤–∏–¥–∏–º–æ—Å—Ç–∏ NPC
local function IsVisible(targetPart)
    local character = LocalPlayer.Character
    local rootPart = character and character:FindFirstChild("HumanoidRootPart")
    if not rootPart then
        return false
    end
    
    local rayOrigin = rootPart.Position
    local rayDirection = (targetPart.Position - rayOrigin).Unit * 1000
    local raycastParams = RaycastParams.new()
    raycastParams.FilterDescendantsInstances = {character}
    raycastParams.FilterType = Enum.RaycastFilterType.Blacklist
    
    local raycastResult = workspace:Raycast(rayOrigin, rayDirection, raycastParams)
    if raycastResult and raycastResult.Instance:IsDescendantOf(targetPart.Parent) then
        return true
    end
    
    local offsetDirections = {
        rayDirection + Vector3.new(0.1, 0, 0),
        rayDirection + Vector3.new(-0.1, 0, 0),
        rayDirection + Vector3.new(0, 0.1, 0),
        rayDirection + Vector3.new(0, -0.1, 0)
    }
    for _, offsetDir in pairs(offsetDirections) do
        local offsetRay = workspace:Raycast(rayOrigin, offsetDir.Unit * 1000, raycastParams)
        if offsetRay and offsetRay.Instance:IsDescendantOf(targetPart.Parent) then
            return true
        end
    end
    return false
end

-- –í—Å–ø–æ–º–æ–≥–∞—Ç–µ–ª—å–Ω–∞—è —Ñ—É–Ω–∫—Ü–∏—è –¥–ª—è –ø—Ä–æ–≤–µ—Ä–∫–∏ Summon NPC
function EntityX.checkSummonNPC(mob)
    if mob and mob.Parent then
        local humanoid = mob:FindFirstChild("Humanoid")
        if humanoid and humanoid.Health > 0 then
            local targetPart = mob:FindFirstChild(npcConfig.TargetPart) or mob:FindFirstChild("HumanoidRootPart")
            if targetPart then
                local distance = (Camera.CFrame.Position - targetPart.Position).Magnitude
                if distance <= npcConfig.DistanceLimit and IsVisible(targetPart) then
                    return {
                        Mob = mob,
                        TargetPart = targetPart,
                        Distance = distance,
                        Health = humanoid.Health
                    }
                end
            end
        end
    end
    return nil
end

-- –ü–æ–∏—Å–∫ NPC –≤ –æ–¥–Ω–æ–π –ª–æ–∫–∞—Ü–∏–∏
local function SearchNPCsInLocation(location, mobTypes, cacheKey)
    local validTargets = {}
    if not location then
        return validTargets
    end

    local currentTime = tick()
    if currentTime - locationCaches[cacheKey].lastUpdate < updateInterval and #locationCaches[cacheKey].cache > 0 then
        return locationCaches[cacheKey].cache
    end

    for _, container in pairs(location:GetChildren()) do
        for _, mobType in pairs(mobTypes or {}) do
            local mob = container:FindFirstChild(mobType)
            if mob and mob.Parent then
                local humanoid = mob:FindFirstChild("Humanoid")
                if humanoid and humanoid.Health > 0 then
                    local targetPart = mob:FindFirstChild(npcConfig.TargetPart) or mob:FindFirstChild("HumanoidRootPart")
                    if targetPart then
                        local distance = (Camera.CFrame.Position - targetPart.Position).Magnitude
                        if distance <= npcConfig.DistanceLimit and IsVisible(targetPart) then
                            table.insert(validTargets, {
                                Mob = mob,
                                TargetPart = targetPart,
                                Distance = distance,
                                Health = humanoid.Health
                            })
                        end
                    end
                end
            end
        end
    end

    locationCaches[cacheKey].cache = validTargets
    locationCaches[cacheKey].lastUpdate = currentTime
    return validTargets
end

-- –ü–æ–∏—Å–∫ –≤—Å–µ—Ö NPC —Å –º—É–ª—å—Ç–∏–ø–æ—Ç–æ—á–Ω–æ—Å—Ç—å—é
local function FindAllNPCs()
    local currentTime = tick()
    if currentTime - lastUpdate < updateInterval and #npcCache > 0 then
        return npcCache
    end

    npcCache = {}
    local completed = { Missions = false, SpiderCave = false }
    local tasks = {}

    -- –ü–æ–∏—Å–∫ –≤ Missions
    local function searchMissions()
        local missions = workspace:FindFirstChild("Missions")
        if missions then
            local mobTypes = {
                "Poacher", "Poacher Mage", "Poacher Gunner", "Poacher Rifleman", "Imperial",
                "Imperial Mage", "Nightfall Spitter Spider", "Nightfall Blink Spider",
                "Poacher Apprentice", "Nightfall Spider"
            }
            local missionNPCs = SearchNPCsInLocation(missions:FindFirstChild("AISpawners") or missions, mobTypes, "Missions")
            for _, npc in pairs(missionNPCs) do
                table.insert(npcCache, npc)
            end
        end
        completed.Missions = true
    end

    -- –ü–æ–∏—Å–∫ –≤ SpiderCave
    local function searchSpiderCave()
        local spiderCave = workspace:FindFirstChild("MapProps") and workspace.MapProps:FindFirstChild("SpiderCave")
        if spiderCave then
            local spiderTypes = {"Spider", "Cave Spider"}
            local caveNPCs = SearchNPCsInLocation(spiderCave, spiderTypes, "SpiderCave")
            for _, npc in pairs(caveNPCs) do
                table.insert(npcCache, npc)
            end
        end
        completed.SpiderCave = true
    end

    -- –ó–∞–ø—É—Å–∫ –∑–∞–¥–∞—á –≤ –ø–∞—Ä–∞–ª–ª–µ–ª—å
    table.insert(tasks, task.spawn(searchMissions))
    table.insert(tasks, task.spawn(searchSpiderCave))

    -- –û–∂–∏–¥–∞–Ω–∏–µ –∑–∞–≤–µ—Ä—à–µ–Ω–∏—è –≤—Å–µ—Ö –∑–∞–¥–∞—á
    local startTime = tick()
    while not (completed.Missions and completed.SpiderCave) and tick() - startTime < 0.1 do
        task.wait()
    end

    lastUpdate = currentTime
    if currentTime - lastLog >= logInterval and #npcCache > 0 then
        Log("Found entities! (" .. #npcCache .. ")", "üõ°")
        lastLog = currentTime
    end
    return npcCache
end

-- –ü–æ–ª—É—á–µ–Ω–∏–µ –±–ª–∏–∂–∞–π—à–µ–≥–æ NPC
function EntityX:GetClosestNPC()
    local npcs = FindAllNPCs()
    if #npcs == 0 then
        return nil, nil
    end

    table.sort(npcs, function(a, b)
        local aScore = (a.Distance / npcConfig.DistanceLimit) * 0.5 + (a.Health / npcConfig.MaxHealth) * 0.5
        local bScore = (b.Distance / npcConfig.DistanceLimit) * 0.5 + (b.Health / npcConfig.MaxHealth) * 0.5
        return aScore < bScore
    end)

    return npcs[1].Mob, npcs[1].TargetPart
end

-- –ü–æ–ª—É—á–µ–Ω–∏–µ –≤—Å–µ—Ö NPC
function EntityX:GetAllNPCs()
    return FindAllNPCs()
end

-- –ü–æ–ª—É—á–µ–Ω–∏–µ DistanceLimit
function EntityX:GetDistanceLimit()
    local limit = npcConfig.DistanceLimit
    Log("Returning DistanceLimit: " .. tostring(limit), "‚öôÔ∏è")
    return limit
end

-- –£—Å—Ç–∞–Ω–æ–≤–∫–∞ –ø—Ä–µ–¥–µ–ª–∞ –¥–∏—Å—Ç–∞–Ω—Ü–∏–∏
function EntityX:SetDistanceLimit(limit)
    npcConfig.DistanceLimit = limit or 120
    Log("Distance limit set to " .. npcConfig.DistanceLimit .. ".", "‚öôÔ∏è")
end

-- –£—Å—Ç–∞–Ω–æ–≤–∫–∞ —Ü–µ–ª–µ–≤–æ–π —á–∞—Å—Ç–∏ —Ç–µ–ª–∞
function EntityX:SetTargetPart(part)
    npcConfig.TargetPart = part or "Head"
    Log("Target part set to " .. npcConfig.TargetPart .. ".", "‚öôÔ∏è")
end

-- –ö–∞—Å—Ç–æ–º–Ω—ã–π –ø–æ–∏—Å–∫ NPC –≤ –∑–∞–¥–∞–Ω–Ω–æ–π –ª–æ–∫–∞—Ü–∏–∏
function EntityX:FindNPCsInLocation(location, mobTypes)
    return SearchNPCsInLocation(location, mobTypes, "Custom")
end

-- –ü—Ä–æ–≤–µ—Ä–∫–∞ —Å–æ—Å—Ç–æ—è–Ω–∏—è NPC (–∂–∏–≤/–º—ë—Ä—Ç–≤)
function EntityX:IsNPCAlive(mob)
    if not mob or not mob:FindFirstChild("Humanoid") then return false end
    return mob.Humanoid.Health > 0
end

-- –ü–æ–ª—É—á–µ–Ω–∏–µ —Ä–∞—Å—Å—Ç–æ—è–Ω–∏—è –¥–æ NPC
function EntityX:GetDistanceToNPC(mob)
    if not mob or not mob:FindFirstChild(npcConfig.TargetPart) then return math.huge end
    return (Camera.CFrame.Position - mob[npcConfig.TargetPart].Position).Magnitude
end

return EntityX
