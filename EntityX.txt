-- EntityX Library for NPC and Player Interaction
local EntityX = {}
local workspace = game:GetService("Workspace")
local Camera = workspace.CurrentCamera
local Players = game:GetService("Players")
local LocalPlayer = Players.LocalPlayer
local UserInputService = game:GetService("UserInputService")

-- –ö—Ä–∞—Å–∏–≤–æ–µ –ª–æ–≥–∏—Ä–æ–≤–∞–Ω–∏–µ
local function Log(message, emoji)
    print("{" .. emoji .. "} EntityX | " .. message)
end

-- –í—Å–ø–æ–º–æ–≥–∞—Ç–µ–ª—å–Ω—ã–µ —Ñ—É–Ω–∫—Ü–∏–∏
local function waitForChildOfType(obj, name, timeout, prop)
    local checktick = tick() + (timeout or 10)
    local returned
    repeat
        returned = prop and obj[name] or obj:FindFirstChildOfClass(name)
        if returned or checktick < tick() then break end
        task.wait()
    until false
    return returned
end

local function getMousePosition()
    if UserInputService.TouchEnabled then
        return Camera.ViewportSize / 2
    end
    return UserInputService:GetMouseLocation()
end

local function loopClean(tbl)
    for i, v in pairs(tbl) do
        if type(v) == 'table' then
            loopClean(v)
        end
        tbl[i] = nil
    end
end

-- –ü—Ä–æ–≤–µ—Ä–∫–∞ –æ—à–∏–±–æ–∫ –∏ –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è
local function Initialize()
    local hasErrors = false
    if not workspace or not Camera then
        Log("Failed to initialize: Workspace or Camera not found.", "‚ùå")
        hasErrors = true
    end
    if hasErrors then
        Log("Loaded with errors, some features may be unavailable.", "üü†")
    else
        Log("Lightweight NPC and Player interactions.", "üß†")
        Log("Loaded successfully!", "üü¢")
    end
end
Initialize()

-- Internal cache and state
local npcCache = {}
local entityList = {}
local lastUpdate = 0
local lastLog = 0
local updateInterval = 0.5 -- –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ –∫—ç—à–∞ –∫–∞–∂–¥—ã–µ 0.5 —Å–µ–∫—É–Ω–¥—ã
local logInterval = 2.0 -- –õ–æ–≥–∏ –∫–∞–∂–¥—ã–µ 2 —Å–µ–∫—É–Ω–¥—ã

-- –ö–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—è –ø–æ–∏—Å–∫–∞ —Å—É—â–Ω–æ—Å—Ç–µ–π
local entityConfig = {
    DistanceLimit = 120,
    TargetPart = "Head"
}

-- –í—Å–ø–æ–º–æ–≥–∞—Ç–µ–ª—å–Ω–∞—è —Ñ—É–Ω–∫—Ü–∏—è –¥–ª—è –ø—Ä–æ–≤–µ—Ä–∫–∏ Summon NPC
function EntityX.checkSummonNPC(mob)
    if mob and mob.Parent then
        local humanoid = mob:FindFirstChild("Humanoid")
        if humanoid and humanoid.Health > 0 then
            local targetPart = mob:FindFirstChild(entityConfig.TargetPart) or mob:FindFirstChild("HumanoidRootPart")
            if targetPart then
                local distance = (Camera.CFrame.Position - targetPart.Position).Magnitude
                if distance <= entityConfig.DistanceLimit then
                    return {
                        Mob = mob,
                        TargetPart = targetPart,
                        Distance = distance,
                        Health = humanoid.Health,
                        NPC = true
                    }
                end
            end
        end
    end
    return nil
end

-- –ü–æ–∏—Å–∫ –≤—Å–µ—Ö NPC –≤ —É–∫–∞–∑–∞–Ω–Ω—ã—Ö –ª–æ–∫–∞—Ü–∏—è—Ö
local function FindAllNPCs()
    local currentTime = tick()
    if currentTime - lastUpdate < updateInterval and #npcCache > 0 then
        return npcCache
    end

    local spiderCave = workspace:FindFirstChild("MapProps") and workspace.MapProps:FindFirstChild("SpiderCave")
    local missions = workspace:FindFirstChild("Missions")
    npcCache = {}

    if missions then
        for _, mission in pairs(missions:GetChildren()) do
            local aiSpawners = mission:FindFirstChild("AISpawners")
            if aiSpawners then
                for _, spawner in pairs(aiSpawners:GetChildren()) do
                    local mobTypes = {
                        "Poacher", "Poacher Mage", "Poacher Gunner", "Poacher Rifleman", "Imperial",
                        "Imperial Mage", "Nightfall Spitter Spider", "Nightfall Blink Spider",
                        "Poacher Apprentice", "Nightfall Spider"
                    }
                    for _, mobType in pairs(mobTypes) do
                        local mob = spawner:FindFirstChild(mobType)
                        if mob and mob.Parent then
                            local humanoid = mob:FindFirstChild("Humanoid")
                            if humanoid and humanoid.Health > 0 then
                                local targetPart = mob:FindFirstChild(entityConfig.TargetPart) or mob:FindFirstChild("HumanoidRootPart")
                                if targetPart then
                                    local distance = (Camera.CFrame.Position - targetPart.Position).Magnitude
                                    if distance <= entityConfig.DistanceLimit then
                                        table.insert(npcCache, {
                                            Mob = mob,
                                            TargetPart = targetPart,
                                            Distance = distance,
                                            Health = humanoid.Health,
                                            NPC = true
                                        })
                                    end
                                end
                            end
                        end
                    end
                end
            end
        end
    end

    if spiderCave then
        for _, container in pairs(spiderCave:GetChildren()) do
            local spiderTypes = {"Spider", "Cave Spider"}
            for _, spiderType in pairs(spiderTypes) do
                local mob = container:FindFirstChild(spiderType)
                if mob and mob.Parent then
                    local humanoid = mob:FindFirstChild("Humanoid")
                    if humanoid and humanoid.Health > 0 then
                        local targetPart = mob:FindFirstChild(entityConfig.TargetPart) or mob:FindFirstChild("HumanoidRootPart")
                        if targetPart then
                            local distance = (Camera.CFrame.Position - targetPart.Position).Magnitude
                            if distance <= entityConfig.DistanceLimit then
                                table.insert(npcCache, {
                                    Mob = mob,
                                    TargetPart = targetPart,
                                    Distance = distance,
                                    Health = humanoid.Health,
                                    NPC = true
                                })
                            end
                        end
                    end
                end
            end
        end
    end

    lastUpdate = currentTime
    if currentTime - lastLog >= logInterval and #npcCache > 0 then
        Log("Found entities! (" .. #npcCache .. ")", "üõ°")
        lastLog = currentTime
    end
    return npcCache
end

-- –°–æ–±—ã—Ç–∏—è
EntityX.Events = setmetatable({}, {
    __index = function(self, ind)
        self[ind] = {
            Connections = {},
            Connect = function(rself, func)
                table.insert(rself.Connections, func)
                return {
                    Disconnect = function()
                        local rind = table.find(rself.Connections, func)
                        if rind then
                            table.remove(rself.Connections, rind)
                        end
                    end
                }
            end,
            Fire = function(rself, ...)
                for _, v in rself.Connections do
                    task.spawn(v, ...)
                end
            end,
            Destroy = function(rself)
                table.clear(rself.Connections)
                table.clear(rself)
            end
        }
        return self[ind]
    end
})

-- –ü—Ä–æ–≤–µ—Ä–∫–∞ —É—è–∑–≤–∏–º–æ—Å—Ç–∏
function EntityX.isVulnerable(ent)
    return ent.Health > 0 and not ent.Character:FindFirstChildWhichIsA("ForceField")
end

-- –ü—Ä–æ–≤–µ—Ä–∫–∞ –∫–æ–º–∞–Ω–¥—ã
function EntityX.targetCheck(ent)
    if ent.TeamCheck then
        return ent:TeamCheck()
    end
    if ent.NPC then return true end
    if not LocalPlayer.Team then return true end
    if not ent.Player.Team then return true end
    if ent.Player.Team ~= LocalPlayer.Team then return true end
    return #ent.Player.Team:GetPlayers() == #Players:GetPlayers()
end

-- –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ —Å–æ–µ–¥–∏–Ω–µ–Ω–∏–π —Å—É—â–Ω–æ—Å—Ç–∏
function EntityX.getUpdateConnections(ent)
    local hum = ent.Humanoid
    return {
        hum:GetPropertyChangedSignal('Health'),
        hum:GetPropertyChangedSignal('MaxHealth')
    }
end

-- –ü—Ä–æ–≤–µ—Ä–∫–∞ —Å—Ç–µ–Ω—ã
EntityX.IgnoreObject = RaycastParams.new()
EntityX.IgnoreObject.RespectCanCollide = true
function EntityX.Wallcheck(origin, position, ignoreobject)
    if typeof(ignoreobject) ~= 'Instance' then
        local ignorelist = {Camera, LocalPlayer.Character}
        for _, v in entityList do
            if v.Targetable then
                table.insert(ignorelist, v.Character)
            end
        end
        if typeof(ignoreobject) == 'table' then
            for _, v in ignoreobject do
                table.insert(ignorelist, v)
            end
        end
        ignoreobject = EntityX.IgnoreObject
        ignoreobject.FilterDescendantsInstances = ignorelist
    end
    return workspace:Raycast(origin, position - origin, ignoreobject)
end

-- –î–æ–±–∞–≤–ª–µ–Ω–∏–µ —Å—É—â–Ω–æ—Å—Ç–∏ (–∏–≥—Ä–æ–∫ –∏–ª–∏ NPC)
function EntityX.addEntity(char, plr, teamfunc)
    if not char then return end
    EntityX.EntityThreads[char] = task.spawn(function()
        local hum = waitForChildOfType(char, 'Humanoid', 10)
        local humrootpart = hum and waitForChildOfType(hum, 'RootPart', workspace.StreamingEnabled and 9e9 or 10, true)
        local head = char:WaitForChild('Head', 10) or humrootpart

        if hum and humrootpart then
            local entity = {
                Connections = {},
                Character = char,
                Health = hum.Health,
                Head = head,
                Humanoid = hum,
                HumanoidRootPart = humrootpart,
                HipHeight = hum.HipHeight + (humrootpart.Size.Y / 2) + (hum.RigType == Enum.HumanoidRigType.R6 and 2 or 0),
                MaxHealth = hum.MaxHealth,
                NPC = plr == nil,
                Player = plr,
                RootPart = humrootpart,
                TeamCheck = teamfunc
            }

            if plr == LocalPlayer then
                EntityX.character = entity
                EntityX.isAlive = true
                EntityX.Events.LocalAdded:Fire(entity)
                Log("Local player entity added.", "üü¢")
            else
                entity.Targetable = EntityX.targetCheck(entity)

                for _, v in EntityX.getUpdateConnections(entity) do
                    table.insert(entity.Connections, v:Connect(function()
                        entity.Health = hum.Health
                        entity.MaxHealth = hum.MaxHealth
                        EntityX.Events.EntityUpdated:Fire(entity)
                        Log("Entity " .. (entity.NPC and "NPC" or entity.Player.Name) .. " updated.", "üîÑ")
                    end))
                end

                table.insert(entityList, entity)
                EntityX.Events.EntityAdded:Fire(entity)
                Log("Entity " .. (entity.NPC and "NPC" or entity.Player.Name) .. " added.", "üü¢")
            end
        else
            Log("Failed to create entity for " .. (plr and plr.Name or "NPC") .. ": Humanoid or RootPart not found.", "‚ùå")
        end
    end)
end

-- –£–¥–∞–ª–µ–Ω–∏–µ —Å—É—â–Ω–æ—Å—Ç–∏
function EntityX.removeEntity(char, localcheck)
    if localcheck then
        if EntityX.isAlive then
            EntityX.isAlive = false
            for _, v in EntityX.character.Connections do
                if v and typeof(v) == "RBXScriptConnection" then v:Disconnect() end
            end
            table.clear(EntityX.character.Connections)
            EntityX.Events.LocalRemoved:Fire(EntityX.character)
            EntityX.character = nil
            Log("Local player entity removed.", "üî¥")
        end
        return
    end

    if char then
        if EntityX.EntityThreads[char] then
            task.cancel(EntityX.EntityThreads[char])
            EntityX.EntityThreads[char] = nil
        end
        local entity, ind = EntityX.getEntity(char)
        if entity and ind then
            for _, v in entity.Connections do
                if v and typeof(v) == "RBXScriptConnection" then v:Disconnect() end
            end
            table.clear(entity.Connections)
            table.remove(entityList, ind)
            EntityX.Events.EntityRemoved:Fire(entity)
            Log("Entity " .. (entity.NPC and "NPC" or entity.Player.Name) .. " removed.", "üî¥")
        else
            Log("No entity found to remove for character.", "‚ö†Ô∏è")
        end
    end
end

-- –ü–æ–ª—É—á–µ–Ω–∏–µ —Å—É—â–Ω–æ—Å—Ç–∏ –ø–æ –ø–µ—Ä—Å–æ–Ω–∞–∂—É
function EntityX.getEntity(char)
    for i, v in ipairs(entityList) do
        if v.Player == char or v.Character == char then
            return v, i
        end
    end
    return nil, nil
end

-- –ü–æ–∏—Å–∫ –±–ª–∏–∂–∞–π—à–µ–π —Å—É—â–Ω–æ—Å—Ç–∏ –ø–æ –ø–æ–∑–∏—Ü–∏–∏
function EntityX.EntityPosition(entitysettings)
    Log("EntityPosition called with settings: " .. (entitysettings and table.concat({"Range=" .. (entitysettings.Range or entityConfig.DistanceLimit), "Origin=" .. tostring(entitysettings.Origin)}, ", ") or "default"), "üîç")
    if EntityX.isAlive then
        local localPosition = entitysettings.Origin or (EntityX.character and EntityX.character.HumanoidRootPart and EntityX.character.HumanoidRootPart.Position) or Camera.CFrame.Position
        local sortingTable = {}
        for _, v in ipairs(entityList) do
            if (not entitysettings.Players and v.Player) or (not entitysettings.NPCs and v.NPC) then continue end
            if not v.Targetable then continue end
            local mag = (v[entitysettings.Part or entityConfig.TargetPart].Position - localPosition).Magnitude
            if mag > (entitysettings.Range or entityConfig.DistanceLimit) then continue end
            if EntityX.isVulnerable(v) then
                table.insert(sortingTable, {Entity = v, Magnitude = v.Target and -1 or mag})
                Log("Found entity " .. (v.NPC and "NPC" or v.Player.Name) .. " at distance " .. mag, "üó∫Ô∏è")
            end
        end

        if #sortingTable == 0 then
            Log("No entities found in range.", "‚ö†Ô∏è")
            table.clear(entitysettings)
            table.clear(sortingTable)
            return nil
        end

        table.sort(sortingTable, entitysettings.Sort or function(a, b)
            return a.Magnitude < b.Magnitude
        end)

        for _, v in ipairs(sortingTable) do
            if entitysettings.Wallcheck then
                if EntityX.Wallcheck(localPosition, v.Entity[entitysettings.Part or entityConfig.TargetPart].Position, entitysettings.Wallcheck) then
                    Log("Wallcheck blocked target " .. (v.Entity.NPC and "NPC" or v.Entity.Player.Name), "üö´")
                    continue
                end
            end
            local target = v.Entity
            table.clear(entitysettings)
            table.clear(sortingTable)
            Log("Returning target: " .. (target.NPC and "NPC" or target.Player.Name), "‚úÖ")
            return target
        end
        table.clear(sortingTable)
    end
    table.clear(entitysettings)
    Log("No valid target returned (isAlive=false or no entities).", "‚ö†Ô∏è")
    return nil
end

-- –ü–æ–ª—É—á–µ–Ω–∏–µ –±–ª–∏–∂–∞–π—à–µ–≥–æ NPC
function EntityX:GetClosestNPC()
    local npcs = FindAllNPCs()
    if #npcs == 0 then
        Log("No NPCs found.", "‚ö†Ô∏è")
        return nil, nil
    end

    table.sort(npcs, function(a, b)
        local aScore = (a.Distance / entityConfig.DistanceLimit) * 0.5 + (a.Health / 100) * 0.5
        local bScore = (b.Distance / entityConfig.DistanceLimit) * 0.5 + (b.Health / 100) * 0.5
        return aScore < bScore
    end)

    Log("Closest NPC found at distance " .. npcs[1].Distance, "üõ°")
    return npcs[1].Mob, npcs[1].TargetPart
end

-- –ü–æ–ª—É—á–µ–Ω–∏–µ –≤—Å–µ—Ö NPC
function EntityX:GetAllNPCs()
    return FindAllNPCs()
end

-- –ü–æ–ª—É—á–µ–Ω–∏–µ DistanceLimit
function EntityX:GetDistanceLimit()
    local limit = entityConfig.DistanceLimit
    Log("Returning DistanceLimit: " .. tostring(limit), "‚öôÔ∏è")
    return limit
end

-- –£—Å—Ç–∞–Ω–æ–≤–∫–∞ –ø—Ä–µ–¥–µ–ª–∞ –¥–∏—Å—Ç–∞–Ω—Ü–∏–∏
function EntityX:SetDistanceLimit(limit)
    entityConfig.DistanceLimit = limit or 120
    Log("Distance limit set to " .. entityConfig.DistanceLimit .. ".", "‚öôÔ∏è")
end

-- –£—Å—Ç–∞–Ω–æ–≤–∫–∞ —Ü–µ–ª–µ–≤–æ–π —á–∞—Å—Ç–∏ —Ç–µ–ª–∞
function EntityX:SetTargetPart(part)
    entityConfig.TargetPart = part or "Head"
    Log("Target part set to " .. entityConfig.TargetPart .. ".", "‚öôÔ∏è")
end

-- –ö–∞—Å—Ç–æ–º–Ω—ã–π –ø–æ–∏—Å–∫ NPC –≤ –∑–∞–¥–∞–Ω–Ω–æ–π –ª–æ–∫–∞—Ü–∏–∏
function EntityX:FindNPCsInLocation(location, mobTypes)
    local validTargets = {}
    if not location or not location:IsA("Instance") then
        Log("Invalid location provided.", "‚ùå")
        return validTargets
    end

    for _, container in pairs(location:GetChildren()) do
        for _, mobType in pairs(mobTypes or {}) do
            local mob = container:FindFirstChild(mobType)
            if mob and mob.Parent then
                local humanoid = mob:FindFirstChild("Humanoid")
                if humanoid and humanoid.Health > 0 then
                    local targetPart = mob:FindFirstChild(entityConfig.TargetPart) or mob:FindFirstChild("HumanoidRootPart")
                    if targetPart then
                        local distance = (Camera.CFrame.Position - targetPart.Position).Magnitude
                        if distance <= entityConfig.DistanceLimit then
                            table.insert(validTargets, {
                                Mob = mob,
                                TargetPart = targetPart,
                                Distance = distance,
                                Health = humanoid.Health
                            })
                        end
                    end
                end
            end
        end
    end

    if #validTargets > 0 and tick() - lastLog >= logInterval then
        Log("Found entities! (" .. #validTargets .. ")", "üõ°")
        lastLog = tick()
    end
    return validTargets
end

-- –ü—Ä–æ–≤–µ—Ä–∫–∞ —Å–æ—Å—Ç–æ—è–Ω–∏—è NPC (–∂–∏–≤/–º—ë—Ä—Ç–≤)
function EntityX:IsNPCAlive(mob)
    if not mob or not mob:FindFirstChild("Humanoid") then return false end
    return mob.Humanoid.Health > 0
end

-- –ü–æ–ª—É—á–µ–Ω–∏–µ —Ä–∞—Å—Å—Ç–æ—è–Ω–∏—è –¥–æ NPC
function EntityX:GetDistanceToNPC(mob)
    if not mob or not mob:FindFirstChild(entityConfig.TargetPart) then return math.huge end
    return (Camera.CFrame.Position - mob[entityConfig.TargetPart].Position).Magnitude
end

-- –ó–∞–ø—É—Å–∫ —Å–∏—Å—Ç–µ–º—ã
function EntityX.start()
    if EntityX.Running then EntityX.stop() end
    EntityX.Connections = EntityX.Connections or {}
    EntityX.PlayerConnections = EntityX.PlayerConnections or {}
    EntityX.EntityThreads = EntityX.EntityThreads or {}
    table.insert(EntityX.Connections, Players.PlayerAdded:Connect(function(v)
        EntityX.addPlayer(v)
    end))
    table.insert(EntityX.Connections, Players.PlayerRemoving:Connect(function(v)
        EntityX.removePlayer(v)
    end))
    for _, v in Players:GetPlayers() do
        EntityX.addPlayer(v)
    end
    table.insert(EntityX.Connections, workspace:GetPropertyChangedSignal('CurrentCamera'):Connect(function()
        Camera = workspace.CurrentCamera or workspace:FindFirstChildWhichIsA('Camera')
        Log("Camera updated.", "üì∑")
    end))
    EntityX.Running = true
    Log("System started.", "‚ñ∂Ô∏è")
end

-- –û—Å—Ç–∞–Ω–æ–≤–∫–∞ —Å–∏—Å—Ç–µ–º—ã
function EntityX.stop()
    if not EntityX.Running then return end
    for _, v in (EntityX.Connections or {}) do
        if v and typeof(v) == "RBXScriptConnection" then v:Disconnect() end
    end
    for _, v in (EntityX.PlayerConnections or {}) do
        for _, v2 in v do
            if v2 and typeof(v2) == "RBXScriptConnection" then v2:Disconnect() end
        end
        table.clear(v)
    end
    EntityX.removeEntity(nil, true)
    local cloned = table.clone(entityList)
    for _, v in cloned do
        EntityX.removeEntity(v.Character)
    end
    for _, v in (EntityX.EntityThreads or {}) do
        task.cancel(v)
    end
    table.clear(EntityX.PlayerConnections or {})
    table.clear(EntityX.EntityThreads or {})
    table.clear(EntityX.Connections or {})
    table.clear(cloned)
    EntityX.Running = false
    EntityX.isAlive = false
    EntityX.character = nil
    Log("System stopped.", "‚èπÔ∏è")
end

-- –î–æ–±–∞–≤–ª–µ–Ω–∏–µ –∏–≥—Ä–æ–∫–∞
function EntityX.addPlayer(plr)
    if not plr or EntityX.PlayerConnections[plr] then return end
    EntityX.PlayerConnections[plr] = EntityX.PlayerConnections[plr] or {}
    if plr.Character then
        EntityX.addEntity(plr.Character, plr, function()
            return plr.Team and plr.Team == LocalPlayer.Team
        end)
    end
    EntityX.PlayerConnections[plr] = {
        plr.CharacterAdded:Connect(function(char)
            EntityX.addEntity(char, plr, function()
                return plr.Team and plr.Team == LocalPlayer.Team
            end)
            Log("Player " .. plr.Name .. " character added.", "üü¢")
        end),
        plr.CharacterRemoving:Connect(function(char)
            EntityX.removeEntity(char, plr == LocalPlayer)
            Log("Player " .. plr.Name .. " character removed.", "üî¥")
        end),
        plr:GetPropertyChangedSignal('Team'):Connect(function()
            for _, v in entityList do
                if v.Targetable ~= EntityX.targetCheck(v) then
                    EntityX.removeEntity(v.Character)
                    EntityX.addEntity(v.Character, v.Player, function()
                        return v.Player.Team and v.Player.Team == LocalPlayer.Team
                    end)
                end
            end
            if plr == LocalPlayer then
                EntityX.start()
            else
                EntityX.addEntity(plr.Character, plr, function()
                    return plr.Team and plr.Team == LocalPlayer.Team
                end)
            end
            Log("Player " .. plr.Name .. " team updated.", "üîÑ")
        end)
    }
end

-- –£–¥–∞–ª–µ–Ω–∏–µ –∏–≥—Ä–æ–∫–∞
function EntityX.removePlayer(plr)
    if not EntityX.PlayerConnections or not EntityX.PlayerConnections[plr] then return end
    for _, v in EntityX.PlayerConnections[plr] do
        if v and typeof(v) == "RBXScriptConnection" then v:Disconnect() end
    end
    table.clear(EntityX.PlayerConnections[plr])
    EntityX.PlayerConnections[plr] = nil
    EntityX.removeEntity(plr.Character)
    Log("Player " .. (plr and plr.Name or "unknown") .. " removed.", "üî¥")
end

-- –°—Ç–∞—Ç—É—Å —Å–∏—Å—Ç–µ–º—ã
EntityX.isAlive = false
EntityX.character = {}
EntityX.List = entityList
EntityX.Connections = {}
EntityX.PlayerConnections = {}
EntityX.EntityThreads = {}
EntityX.Running = false

EntityX.start()

return EntityX
