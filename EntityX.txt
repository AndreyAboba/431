-- EntityX Library for NPC and Player Interaction
local EntityX = {}
local workspace = game:GetService("Workspace")
local Camera = workspace.CurrentCamera
local Players = game:GetService("Players")
local LocalPlayer = Players.LocalPlayer
local UserInputService = game:GetService("UserInputService")

-- –ö—Ä–∞—Å–∏–≤–æ–µ –ª–æ–≥–∏—Ä–æ–≤–∞–Ω–∏–µ
local function Log(message, emoji)
    print("{" .. emoji .. "} EntityX | " .. message)
end

-- –ü—Ä–æ–≤–µ—Ä–∫–∞ –æ—à–∏–±–æ–∫ –∏ –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è
local function Initialize()
    local hasErrors = false
    if not workspace or not Camera then
        Log("Failed to initialize: Workspace or Camera not found.", "‚ùå")
        hasErrors = true
    end
    if hasErrors then
        Log("Loaded with errors, some features may be unavailable.", "üü†")
    else
        Log("Lightweight NPC and Player interactions.", "üß†")
        Log("Loaded successfully!", "üü¢")
    end
end
Initialize()

-- Internal cache for performance
local npcCache = {}
local entityList = {}
local lastUpdate = 0
local lastLog = 0
local updateInterval = 0.5 -- –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ –∫—ç—à–∞ –∫–∞–∂–¥—ã–µ 0.5 —Å–µ–∫—É–Ω–¥—ã
local logInterval = 2.0 -- –õ–æ–≥–∏ –∫–∞–∂–¥—ã–µ 2 —Å–µ–∫—É–Ω–¥—ã

-- –ö–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—è –ø–æ–∏—Å–∫–∞ —Å—É—â–Ω–æ—Å—Ç–µ–π
local entityConfig = {
    DistanceLimit = 120,
    TargetPart = "Head"
}

-- –í—Å–ø–æ–º–æ–≥–∞—Ç–µ–ª—å–Ω–∞—è —Ñ—É–Ω–∫—Ü–∏—è –¥–ª—è –ø—Ä–æ–≤–µ—Ä–∫–∏ Summon NPC
function EntityX.checkSummonNPC(mob)
    if mob and mob.Parent then
        local humanoid = mob:FindFirstChild("Humanoid")
        if humanoid and humanoid.Health > 0 then
            local targetPart = mob:FindFirstChild(entityConfig.TargetPart) or mob:FindFirstChild("HumanoidRootPart")
            if targetPart then
                local distance = (Camera.CFrame.Position - targetPart.Position).Magnitude
                if distance <= entityConfig.DistanceLimit then
                    return {
                        Mob = mob,
                        TargetPart = targetPart,
                        Distance = distance,
                        Health = humanoid.Health
                    }
                end
            end
        end
    end
    return nil
end

-- –ü–æ–∏—Å–∫ –≤—Å–µ—Ö NPC –≤ —É–∫–∞–∑–∞–Ω–Ω—ã—Ö –ª–æ–∫–∞—Ü–∏—è—Ö
local function FindAllNPCs()
    local currentTime = tick()
    if currentTime - lastUpdate < updateInterval and #npcCache > 0 then
        return npcCache
    end

    local spiderCave = workspace:FindFirstChild("MapProps") and workspace.MapProps:FindFirstChild("SpiderCave")
    local missions = workspace:FindFirstChild("Missions")
    npcCache = {}

    if missions then
        for _, mission in pairs(missions:GetChildren()) do
            local aiSpawners = mission:FindFirstChild("AISpawners")
            if aiSpawners then
                for _, spawner in pairs(aiSpawners:GetChildren()) do
                    local mobTypes = {
                        "Poacher", "Poacher Mage", "Poacher Gunner", "Poacher Rifleman", "Imperial",
                        "Imperial Mage", "Nightfall Spitter Spider", "Nightfall Blink Spider",
                        "Poacher Apprentice", "Nightfall Spider"
                    }
                    for _, mobType in pairs(mobTypes) do
                        local mob = spawner:FindFirstChild(mobType)
                        if mob and mob.Parent then
                            local humanoid = mob:FindFirstChild("Humanoid")
                            if humanoid and humanoid.Health > 0 then
                                local targetPart = mob:FindFirstChild(entityConfig.TargetPart) or mob:FindFirstChild("HumanoidRootPart")
                                if targetPart then
                                    local distance = (Camera.CFrame.Position - targetPart.Position).Magnitude
                                    if distance <= entityConfig.DistanceLimit then
                                        table.insert(npcCache, {
                                            Mob = mob,
                                            TargetPart = targetPart,
                                            Distance = distance,
                                            Health = humanoid.Health,
                                            NPC = true
                                        })
                                    end
                                end
                            end
                        end
                    end
                end
            end
        end
    end

    if spiderCave then
        for _, container in pairs(spiderCave:GetChildren()) do
            local spiderTypes = {"Spider", "Cave Spider"}
            for _, spiderType in pairs(spiderTypes) do
                local mob = container:FindFirstChild(spiderType)
                if mob and mob.Parent then
                    local humanoid = mob:FindFirstChild("Humanoid")
                    if humanoid and humanoid.Health > 0 then
                        local targetPart = mob:FindFirstChild(entityConfig.TargetPart) or mob:FindFirstChild("HumanoidRootPart")
                        if targetPart then
                            local distance = (Camera.CFrame.Position - targetPart.Position).Magnitude
                            if distance <= entityConfig.DistanceLimit then
                                table.insert(npcCache, {
                                    Mob = mob,
                                    TargetPart = targetPart,
                                    Distance = distance,
                                    Health = humanoid.Health,
                                    NPC = true
                                })
                            end
                        end
                    end
                end
            end
        end
    end

    lastUpdate = currentTime
    if currentTime - lastLog >= logInterval and #npcCache > 0 then
        Log("Found entities! (" .. #npcCache .. ")", "üõ°")
        lastLog = currentTime
    end
    return npcCache
end

-- –°–æ–±—ã—Ç–∏—è
EntityX.Events = setmetatable({}, {
    __index = function(self, ind)
        self[ind] = {
            Connections = {},
            Connect = function(rself, func)
                table.insert(rself.Connections, func)
                return {
                    Disconnect = function()
                        local rind = table.find(rself.Connections, func)
                        if rind then
                            table.remove(rself.Connections, rind)
                        end
                    end
                }
            end,
            Fire = function(rself, ...)
                for _, v in rself.Connections do
                    task.spawn(v, ...)
                end
            end,
            Destroy = function(rself)
                table.clear(rself.Connections)
                table.clear(rself)
            end
        }
        return self[ind]
    end
})

-- –î–æ–±–∞–≤–ª–µ–Ω–∏–µ —Å—É—â–Ω–æ—Å—Ç–∏ (–∏–≥—Ä–æ–∫ –∏–ª–∏ NPC)
function EntityX.addEntity(char, plr, teamfunc)
    if not char then return end
    local entityThread = task.spawn(function()
        local hum = char:FindFirstChild("Humanoid") or char:WaitForChild("Humanoid", 10)
        local humrootpart = hum and (hum:FindFirstChild("RootPart") or char:WaitForChild("HumanoidRootPart", 10))
        local head = char:FindFirstChild("Head") or humrootpart

        if hum and humrootpart then
            local entity = {
                Connections = {},
                Character = char,
                Health = hum.Health,
                Head = head,
                Humanoid = hum,
                HumanoidRootPart = humrootpart,
                HipHeight = hum.HipHeight + (humrootpart.Size.Y / 2) + (hum.RigType == Enum.HumanoidRigType.R6 and 2 or 0),
                MaxHealth = hum.MaxHealth,
                NPC = plr == nil,
                Player = plr,
                RootPart = humrootpart,
                Targetable = plr == nil or (teamfunc and not teamfunc()) or (plr ~= LocalPlayer and (not plr.Team or plr.Team ~= LocalPlayer.Team))
            }

            if plr == LocalPlayer then
                EntityX.character = entity
                EntityX.isAlive = true
                EntityX.Events.LocalAdded:Fire(entity)
            else
                for _, v in EntityX.getUpdateConnections(entity) do
                    table.insert(entity.Connections, v:Connect(function()
                        entity.Health = hum.Health
                        entity.MaxHealth = hum.MaxHealth
                        EntityX.Events.EntityUpdated:Fire(entity)
                    end))
                end
                table.insert(entityList, entity)
                EntityX.Events.EntityAdded:Fire(entity)
            end
        end
    end)
end

-- –£–¥–∞–ª–µ–Ω–∏–µ —Å—É—â–Ω–æ—Å—Ç–∏
function EntityX.removeEntity(char, localcheck)
    if localcheck then
        if EntityX.isAlive then
            EntityX.isAlive = false
            for _, v in EntityX.character.Connections do
                v:Disconnect()
            end
            table.clear(EntityX.character.Connections)
            EntityX.Events.LocalRemoved:Fire(EntityX.character)
        end
        return
    end

    if char then
        local entity, ind = EntityX.getEntity(char)
        if ind then
            for _, v in entity.Connections do
                v:Disconnect()
            end
            table.clear(entity.Connections)
            table.remove(entityList, ind)
            EntityX.Events.EntityRemoved:Fire(entity)
        end
    end
end

-- –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ —Å–æ–µ–¥–∏–Ω–µ–Ω–∏–π —Å—É—â–Ω–æ—Å—Ç–∏
function EntityX.getUpdateConnections(ent)
    local hum = ent.Humanoid
    return {
        hum:GetPropertyChangedSignal('Health'),
        hum:GetPropertyChangedSignal('MaxHealth')
    }
end

-- –ü–æ–ª—É—á–µ–Ω–∏–µ —Å—É—â–Ω–æ—Å—Ç–∏ –ø–æ –ø–µ—Ä—Å–æ–Ω–∞–∂—É
function EntityX.getEntity(char)
    for i, v in ipairs(entityList) do
        if v.Player == char or v.Character == char then
            return v, i
        end
    end
    return nil, nil
end

-- –ü–æ–∏—Å–∫ –±–ª–∏–∂–∞–π—à–µ–π —Å—É—â–Ω–æ—Å—Ç–∏ –ø–æ –ø–æ–∑–∏—Ü–∏–∏
function EntityX.EntityPosition(entitysettings)
    if EntityX.isAlive then
        local localPosition = entitysettings.Origin or (EntityX.character and EntityX.character.HumanoidRootPart and EntityX.character.HumanoidRootPart.Position) or Camera.CFrame.Position
        local sortingTable = {}
        for _, v in ipairs(entityList) do
            if not entitysettings.Players and v.Player then continue end
            if not entitysettings.NPCs and v.NPC then continue end
            if not v.Targetable then continue end
            local mag = (v[entitysettings.Part or entityConfig.TargetPart].Position - localPosition).Magnitude
            if mag > (entitysettings.Range or entityConfig.DistanceLimit) then continue end
            if v.Health > 0 and not v.Character:FindFirstChildWhichIsA("ForceField") then
                table.insert(sortingTable, {Entity = v, Magnitude = mag})
            end
        end

        table.sort(sortingTable, function(a, b)
            return a.Magnitude < b.Magnitude
        end)

        for _, v in ipairs(sortingTable) do
            if entitysettings.Wallcheck then
                local ignorelist = {Camera, LocalPlayer.Character}
                for _, e in ipairs(entityList) do
                    if e.Targetable then table.insert(ignorelist, e.Character) end
                end
                local rayParams = RaycastParams.new()
                rayParams.FilterDescendantsInstances = ignorelist
                if workspace.Raycast(workspace, localPosition, (v.Entity[entitysettings.Part or entityConfig.TargetPart].Position - localPosition), rayParams) then continue end
            end
            table.clear(entitysettings)
            table.clear(sortingTable)
            return v.Entity
        end
        table.clear(sortingTable)
    end
    table.clear(entitysettings)
    return nil
end

-- –ü–æ–ª—É—á–µ–Ω–∏–µ –±–ª–∏–∂–∞–π—à–µ–≥–æ NPC
function EntityX:GetClosestNPC()
    local npcs = FindAllNPCs()
    if #npcs == 0 then
        return nil, nil
    end

    table.sort(npcs, function(a, b)
        local aScore = (a.Distance / entityConfig.DistanceLimit) * 0.5 + (a.Health / 100) * 0.5
        local bScore = (b.Distance / entityConfig.DistanceLimit) * 0.5 + (b.Health / 100) * 0.5
        return aScore < bScore
    end)

    return npcs[1].Mob, npcs[1].TargetPart
end

-- –ü–æ–ª—É—á–µ–Ω–∏–µ –≤—Å–µ—Ö NPC
function EntityX:GetAllNPCs()
    return FindAllNPCs()
end

-- –ü–æ–ª—É—á–µ–Ω–∏–µ DistanceLimit
function EntityX:GetDistanceLimit()
    local limit = entityConfig.DistanceLimit
    Log("Returning DistanceLimit: " .. tostring(limit), "‚öôÔ∏è")
    return limit
end

-- –£—Å—Ç–∞–Ω–æ–≤–∫–∞ –ø—Ä–µ–¥–µ–ª–∞ –¥–∏—Å—Ç–∞–Ω—Ü–∏–∏
function EntityX:SetDistanceLimit(limit)
    entityConfig.DistanceLimit = limit or 120
    Log("Distance limit set to " .. entityConfig.DistanceLimit .. ".", "‚öôÔ∏è")
end

-- –£—Å—Ç–∞–Ω–æ–≤–∫–∞ —Ü–µ–ª–µ–≤–æ–π —á–∞—Å—Ç–∏ —Ç–µ–ª–∞
function EntityX:SetTargetPart(part)
    entityConfig.TargetPart = part or "Head"
    Log("Target part set to " .. entityConfig.TargetPart .. ".", "‚öôÔ∏è")
end

-- –ö–∞—Å—Ç–æ–º–Ω—ã–π –ø–æ–∏—Å–∫ NPC –≤ –∑–∞–¥–∞–Ω–Ω–æ–π –ª–æ–∫–∞—Ü–∏–∏
function EntityX:FindNPCsInLocation(location, mobTypes)
    local validTargets = {}
    if not location or not location:IsA("Instance") then
        Log("Invalid location provided.", "‚ùå")
        return validTargets
    end

    for _, container in pairs(location:GetChildren()) do
        for _, mobType in pairs(mobTypes or {}) do
            local mob = container:FindFirstChild(mobType)
            if mob and mob.Parent then
                local humanoid = mob:FindFirstChild("Humanoid")
                if humanoid and humanoid.Health > 0 then
                    local targetPart = mob:FindFirstChild(entityConfig.TargetPart) or mob:FindFirstChild("HumanoidRootPart")
                    if targetPart then
                        local distance = (Camera.CFrame.Position - targetPart.Position).Magnitude
                        if distance <= entityConfig.DistanceLimit then
                            table.insert(validTargets, {
                                Mob = mob,
                                TargetPart = targetPart,
                                Distance = distance,
                                Health = humanoid.Health
                            })
                        end
                    end
                end
            end
        end
    end

    if #validTargets > 0 and tick() - lastLog >= logInterval then
        Log("Found entities! (" .. #validTargets .. ")", "üõ°")
        lastLog = tick()
    end
    return validTargets
end

-- –ü—Ä–æ–≤–µ—Ä–∫–∞ —Å–æ—Å—Ç–æ—è–Ω–∏—è NPC (–∂–∏–≤/–º—ë—Ä—Ç–≤)
function EntityX:IsNPCAlive(mob)
    if not mob or not mob:FindFirstChild("Humanoid") then return false end
    return mob.Humanoid.Health > 0
end

-- –ü–æ–ª—É—á–µ–Ω–∏–µ —Ä–∞—Å—Å—Ç–æ—è–Ω–∏—è –¥–æ NPC
function EntityX:GetDistanceToNPC(mob)
    if not mob or not mob:FindFirstChild(entityConfig.TargetPart) then return math.huge end
    return (Camera.CFrame.Position - mob[entityConfig.TargetPart].Position).Magnitude
end

-- –ó–∞–ø—É—Å–∫ —Å–∏—Å—Ç–µ–º—ã
function EntityX.start()
    if EntityX.Running then EntityX.stop() end
    table.insert(EntityX.Connections, Players.PlayerAdded:Connect(function(v)
        EntityX.addPlayer(v)
    end))
    table.insert(EntityX.Connections, Players.PlayerRemoving:Connect(function(v)
        EntityX.removePlayer(v)
    end))
    for _, v in Players:GetPlayers() do
        EntityX.addPlayer(v)
    end
    table.insert(EntityX.Connections, workspace:GetPropertyChangedSignal('CurrentCamera'):Connect(function()
        Camera = workspace.CurrentCamera or workspace:FindFirstChildWhichIsA('Camera')
    end))
    EntityX.Running = true
end

-- –û—Å—Ç–∞–Ω–æ–≤–∫–∞ —Å–∏—Å—Ç–µ–º—ã
function EntityX.stop()
    for _, v in EntityX.Connections do
        v:Disconnect()
    end
    for _, v in EntityX.PlayerConnections do
        for _, v2 in v do
            v2:Disconnect()
        end
        table.clear(v)
    end
    EntityX.removeEntity(nil, true)
    local cloned = table.clone(entityList)
    for _, v in cloned do
        EntityX.removeEntity(v.Character)
    end
    for _, v in EntityX.EntityThreads do
        task.cancel(v)
    end
    table.clear(EntityX.PlayerConnections)
    table.clear(EntityX.EntityThreads)
    table.clear(EntityX.Connections)
    table.clear(cloned)
    EntityX.Running = false
end

-- –î–æ–±–∞–≤–ª–µ–Ω–∏–µ –∏–≥—Ä–æ–∫–∞
function EntityX.addPlayer(plr)
    if plr.Character then
        EntityX.addEntity(plr.Character, plr)
    end
    EntityX.PlayerConnections[plr] = {
        plr.CharacterAdded:Connect(function(char)
            EntityX.addEntity(char, plr)
        end),
        plr.CharacterRemoving:Connect(function(char)
            EntityX.removeEntity(char, plr == LocalPlayer)
        end),
        plr:GetPropertyChangedSignal('Team'):Connect(function()
            for _, v in entityList do
                if v.Targetable ~= (v.NPC or (v.Player ~= LocalPlayer and (not v.Player.Team or v.Player.Team ~= LocalPlayer.Team))) then
                    EntityX.removeEntity(v.Character)
                    EntityX.addEntity(v.Character, v.Player)
                end
            end
            if plr == LocalPlayer then
                EntityX.start()
            else
                EntityX.addEntity(plr.Character, plr)
            end
        end)
    }
end

-- –£–¥–∞–ª–µ–Ω–∏–µ –∏–≥—Ä–æ–∫–∞
function EntityX.removePlayer(plr)
    if EntityX.PlayerConnections[plr] then
        for _, v in EntityX.PlayerConnections[plr] do
            v:Disconnect()
        end
        table.clear(EntityX.PlayerConnections[plr])
        EntityX.PlayerConnections[plr] = nil
    end
    EntityX.removeEntity(plr.Character)
end

-- –°—Ç–∞—Ç—É—Å —Å–∏—Å—Ç–µ–º—ã
EntityX.isAlive = false
EntityX.character = nil
EntityX.Connections = {}
EntityX.PlayerConnections = {}
EntityX.EntityThreads = {}
EntityX.Running = false

EntityX.start()

return EntityX
