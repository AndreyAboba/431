local Players = game:GetService("Players")
local Workspace = game:GetService("Workspace")
local RunService = game:GetService("RunService")
local UserInputService = game:GetService("UserInputService")
local TweenService = game:GetService("TweenService")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Stats = game:GetService("Stats")

local GunSilent = {
    Settings = {
        BasePrediction = { Value = 0.1, Default = 0.1 },
        VelocityPredictionWeight = { Value = 0.9, Default = 0.9 },
        PingCompensationFactor = { Value = 0.8, Default = 0.8 },
        SmoothingFactor = { Value = 0.1, Default = 0.1 },
        Enabled = { Value = false, Default = false },
        RangePlus = { Value = 200, Default = 200 },
        HitPart = { Value = "Head", Default = "Head" },
        UseFOV = { Value = true, Default = true },
        FOV = { Value = 120, Default = 120 },
        ShowCircle = { Value = true, Default = true },
        CircleMethod = { Value = "Center", Default = "Center", Options = {"Center", "Cursor"} },
        PredictVisual = { Value = true, Default = true },
        TrajectoryBeam = { Value = true, Default = true },
        BulletTrailsEnabled = { Value = false, Default = false },
        BulletTrailsFadeTime = { Value = 1, Default = 1 },
        BulletTrailsColor = { Value = Color3.fromRGB(147, 112, 219), Default = Color3.fromRGB(147, 112, 219) },
        HitChance = { Value = 100, Default = 100 },
        ResolverEnabled = { Value = true, Default = true },
        ResolverThreshold = { Value = 0.3, Default = 0.3 },
        PositionHistorySize = { Value = 20, Default = 20 },
        SortMethod = { Value = "Mouse&Distance", Default = "Mouse&Distance" },
        ShotgunSupport = { Value = false, Default = false },
        GenBullet = { Value = 4, Default = 4 },
        TestGenBullet = { Value = false, Default = false },
        HitParticlesEnabled = { Value = false, Default = false },
        HitParticlesMode = { Value = "Orbs", Default = "Orbs", Options = {"Orbs", "Sparks"} },
        HitParticlesCount = { Value = 30, Default = 30 },
        HitParticlesLifetime = { Value = 0.8, Default = 0.8 },
        HitParticlesMoveDistance = { Value = 12, Default = 12 },
        HitParticlesColor = { Value = Color3.fromRGB(255, 215, 0), Default = Color3.fromRGB(255, 215, 0) },
        UseGradient = { Value = false, Default = false },
        ParticlePhysics = { Value = "None", Default = "None", Options = {"None", "Fall", "Rise"} },
        HitVisualEnabled = { Value = false, Default = false },
        HitVisualFadeTime = { Value = 2, Default = 2 },
        HitVisualColor = { Value = Color3.fromRGB(147, 112, 219), Default = Color3.fromRGB(147, 112, 219) },
        HitVisualTransparency = { Value = 0.5, Default = 0.5 },
        DistanceFactor = { Value = 0.0015, Default = 0.0015 },
        SpeedFactor = { Value = 0.00003, Default = 0.00003 },
        HitVisualAnimate = { Value = false, Default = false },
        FakeHitTimestampEnabled = { Value = false, Default = false },
        FakeHitTimestampOffset = { Value = 0, Default = 0 },
        ForceHitConfirmationEnabled = { Value = false, Default = false },
        OverrideServerTickEnabled = { Value = false, Default = false },
        ServerTickOffset = { Value = 0, Default = 0 },
        FakeHitMultiplierEnabled = { Value = false, Default = false },
        FakeHitMultiplierFactor = { Value = 2, Default = 2 }
    },
    State = {
        LastEventId = 0,
        LastTool = nil,
        PredictVisualPart = nil,
        TrajectoryBeam = nil,
        TrajectoryAttachment0 = nil,
        TrajectoryAttachment1 = nil,
        FovCircle = nil,
        V_U_4 = nil,
        Connection = nil,
        OldFireServer = nil,
        PositionHistory = {},
        SmoothedVelocity = {},
        LastVisualUpdateTime = 0,
        LastTargetPosition = {},
        LocalCharacter = nil,
        LocalRoot = nil,
        LastTargetPos = nil,
        LastPredictionPos = nil,
        LastTargetUpdate = 0,
        TargetUpdateInterval = 0.1,
        LastFriendsList = nil,
        BulletTrails = {},
        TrailFadeConnections = {},
        CurrentToolRangeApplied = nil,
        BaseRangeCache = {},
        LastHitTarget = nil,
        LastHitPosition = nil,
        LastShotTime = 0,
        PendingHits = {},
        ActiveHitboxes = {}
    }
}

local function smoothVelocity(target, newVelocity, alpha)
    local smoothed = GunSilent.State.SmoothedVelocity[target] or newVelocity
    smoothed = smoothed:Lerp(newVelocity, alpha)
    GunSilent.State.SmoothedVelocity[target] = smoothed
    return smoothed
end

local function safeCreateInstance(className, properties)
    local instance = Instance.new(className)
    if properties then
        for prop, value in pairs(properties) do
            instance[prop] = value
        end
    end
    return instance
end

local function createOrb(position)
    local orb = safeCreateInstance("Part", {
        Shape = Enum.PartType.Ball,
        Size = Vector3.new(0.6, 0.6, 0.6),
        Position = position,
        Anchored = true,
        CanCollide = false,
        Transparency = 0,
        Material = Enum.Material.Neon,
        Parent = Workspace
    })
    return orb
end

local function createSpark(position)
    local spark = safeCreateInstance("Part", {
        Shape = Enum.PartType.Cylinder,
        Size = Vector3.new(0.3, 2.5, 0.3),
        Position = position,
        Anchored = true,
        CanCollide = false,
        Transparency = 0,
        Material = Enum.Material.Neon,
        Parent = Workspace
    })
    return spark
end

local function interpolateColor(color1, color2, t)
    return Color3.new(
        color1.R + (color2.R - color1.R) * t,
        color1.G + (color2.G - color1.G) * t,
        color1.B + (color2.B - color1.B) * t
    )
end

local function animateParticle(particle, isSpark)
    local theta = math.random() * 2 * math.pi
    local phi = math.random() * math.pi - math.pi / 2
    local distance = GunSilent.Settings.HitParticlesMoveDistance.Value * math.random(0.8, 1.2)
    local moveX = math.cos(theta) * math.cos(phi) * distance
    local moveY = math.sin(phi) * distance
    local moveZ = math.sin(theta) * math.cos(phi) * distance
    local targetPosition = particle.Position + Vector3.new(moveX, moveY, moveZ)
    local physicsMode = GunSilent.Settings.ParticlePhysics.Value
    local yOffset = physicsMode == "Fall" and -5 * GunSilent.Settings.HitParticlesLifetime.Value or physicsMode == "Rise" and 5 * GunSilent.Settings.HitParticlesLifetime.Value or 0

    if isSpark then
        particle.CFrame = CFrame.new(particle.Position, targetPosition) * CFrame.Angles(0, math.random() * 2 * math.pi, 0)
    end

    local tweenInfo = TweenInfo.new(GunSilent.Settings.HitParticlesLifetime.Value, Enum.EasingStyle.Quad, Enum.EasingDirection.Out)
    local targetProperties = {
        Position = targetPosition + Vector3.new(0, yOffset, 0),
        Transparency = 1,
        Size = isSpark and Vector3.new(0.2, 1.8, 0.2) or Vector3.new(0.4, 0.4, 0.4)
    }

    if GunSilent.Settings.HitParticlesMode.Value == "Orbs" then
        local pulseTween = TweenService:Create(particle, TweenInfo.new(0.2, Enum.EasingStyle.Sine, Enum.EasingDirection.InOut, -1, true), { Size = Vector3.new(0.8, 0.8, 0.8) })
        pulseTween:Play()
    end

    local color = GunSilent.Settings.HitParticlesColor.Value
    if GunSilent.Settings.UseGradient.Value and GunSilent.Core and GunSilent.Core.GradientColors then
        local gradientColor1 = GunSilent.Core.GradientColors.Color1.Value
        local gradientColor2 = GunSilent.Core.GradientColors.Color2.Value
        color = gradientColor1
        task.spawn(function()
            local t = 0
            while t < 1 and particle and particle.Parent do
                particle.Color = interpolateColor(gradientColor1, gradientColor2, math.sin(t * math.pi))
                t = t + RunService.Heartbeat:Wait() / GunSilent.Settings.HitParticlesLifetime.Value
            end
        end)
    end
    particle.Color = color

    local tween = TweenService:Create(particle, tweenInfo, targetProperties)
    tween:Play()

    task.delay(GunSilent.Settings.HitParticlesLifetime.Value, function()
        if particle then particle:Destroy() end
    end)
end

local function spawnHitParticles(target, hitPosition)
    if not GunSilent.Settings.HitParticlesEnabled.Value or not target or not hitPosition then return end

    local hitPart = target.Character:FindFirstChild(GunSilent.Settings.HitPart.Value) or target.Character:FindFirstChild("HumanoidRootPart")
    if not hitPart then return end

    local position = hitPosition or hitPart.Position
    local mode = GunSilent.Settings.HitParticlesMode.Value
    local particleCount = math.min(GunSilent.Settings.HitParticlesCount.Value, 30)

    for i = 1, particleCount do
        local particle = mode == "Orbs" and createOrb(position) or createSpark(position)
        if particle then animateParticle(particle, mode == "Sparks") end
    end
end

local function createHitboxPart(part, color, animate)
    if not part then return end
    local hitbox = safeCreateInstance("Part", {
        Size = part.Size * 1.1,
        CFrame = part.CFrame,
        Anchored = true,
        CanCollide = false,
        Transparency = GunSilent.Settings.HitVisualTransparency.Value,
        Material = Enum.Material.Neon,
        Color = color,
        Parent = Workspace
    })
    hitbox.Name = part.Name

    local smoothTime = 0.1
    local tweenInfo = TweenInfo.new(smoothTime, Enum.EasingStyle.Sine, Enum.EasingDirection.InOut)
    local smoothTween = TweenService:Create(hitbox, tweenInfo, { CFrame = part.CFrame })
    smoothTween:Play()

    local fadeTweenInfo = TweenInfo.new(GunSilent.Settings.HitVisualFadeTime.Value, Enum.EasingStyle.Exponential, Enum.EasingDirection.In)
    local fadeTween = TweenService:Create(hitbox, fadeTweenInfo, { Transparency = 1 })
    fadeTween:Play()
    fadeTween.Completed:Connect(function()
        hitbox:Destroy()
        GunSilent.State.ActiveHitboxes[hitbox] = nil
    end)

    GunSilent.State.ActiveHitboxes[hitbox] = true
    if #GunSilent.State.ActiveHitboxes > 50 then
        for oldHitbox, _ in pairs(GunSilent.State.ActiveHitboxes) do
            if oldHitbox ~= hitbox then
                oldHitbox:Destroy()
                GunSilent.State.ActiveHitboxes[oldHitbox] = nil
                break
            end
        end
    end

    return hitbox
end

local function spawnHitVisual(target, hitPosition)
    if not GunSilent.Settings.HitVisualEnabled.Value or not target or not hitPosition then return end

    local character = target.Character
    if not character then return end

    local parts = {
        "Head", "LeftFoot", "LeftHand", "LeftLowerArm", "LeftLowerLeg", "LeftUpperArm", "LeftUpperLeg",
        "LowerTorso", "RightFoot", "RightHand", "RightLowerArm", "RightLowerLeg", "RightUpperArm", "RightUpperLeg", "UpperTorso"
    }

    for _, partName in ipairs(parts) do
        local part = character:FindFirstChild(partName)
        if part then createHitboxPart(part, GunSilent.Settings.HitVisualColor.Value, false) end
    end
end

local function isGunTool(tool)
    local items = ReplicatedStorage:FindFirstChild("Items")
    if not items then return false end
    local gunFolder = items:FindFirstChild("gun")
    if not gunFolder then return false end
    return gunFolder:FindFirstChild(tool.Name) ~= nil
end

local function isShotgun(tool)
    if not tool then return false end
    local ammoType = tool:GetAttribute("AmmoType")
    return ammoType and ammoType:lower() == "shotgun"
end

local function getEquippedGunTool()
    local localPlayer = Players.LocalPlayer
    if not localPlayer or not localPlayer.Character then return nil end

    local playerName = localPlayer.Name
    local playerFolder = Workspace:FindFirstChild(playerName)
    if playerFolder then
        for _, child in pairs(playerFolder:GetChildren()) do
            if child.ClassName == "Tool" and isGunTool(child) then return child end
        end
    end

    local character = localPlayer.Character
    for _, child in pairs(character:GetChildren()) do
        if child.ClassName == "Tool" and isGunTool(child) then return child end
    end
    return nil
end

local function getGunRange(tool)
    if not tool or not isGunTool(tool) then return GunSilent.Settings.RangePlus.Value end

    local equippedTool = getEquippedGunTool()
    if tool ~= equippedTool then return GunSilent.Settings.RangePlus.Value end

    local encryptedRangeAttr = GunSilent.Core.GetEncryptedAttributeName and GunSilent.Core.GetEncryptedAttributeName("range") or "range"
    local toolId = tostring(tool)
    local baseRange = GunSilent.State.BaseRangeCache[toolId] or tool:GetAttribute(encryptedRangeAttr) or 0
    GunSilent.State.BaseRangeCache[toolId] = baseRange

    local totalRange = baseRange + GunSilent.Settings.RangePlus.Value
    if GunSilent.State.CurrentToolRangeApplied ~= tool then
        tool:SetAttribute(encryptedRangeAttr, totalRange)
        GunSilent.State.CurrentToolRangeApplied = tool
    end

    return totalRange
end

local function updateFovCircle()
    if not GunSilent.Settings.ShowCircle.Value then
        if GunSilent.State.FovCircle then GunSilent.State.FovCircle.Visible = false end
        return
    end

    local camera = Workspace.CurrentCamera
    if not camera then return end

    local fovCircle = GunSilent.State.FovCircle
    if not fovCircle then
        fovCircle = Drawing.new("Circle")
        fovCircle.Thickness = 2
        fovCircle.NumSides = 100
        fovCircle.Color = Color3.fromRGB(255, 255, 255)
        fovCircle.Visible = true
        fovCircle.Filled = false
        GunSilent.State.FovCircle = fovCircle
    end

    local newRadius = math.tan(math.rad(GunSilent.Settings.FOV.Value) / 2) * camera.ViewportSize.X / 2
    local circlePos = GunSilent.Settings.CircleMethod.Value == "Cursor" and UserInputService:GetMouseLocation() or camera.ViewportSize / 2

    fovCircle.Radius = newRadius
    fovCircle.Position = circlePos
    fovCircle.Visible = true
end

local function isInFov(targetPos, camera)
    if not GunSilent.Settings.UseFOV.Value then return true end
    local screenPos, onScreen = camera:WorldToViewportPoint(targetPos)
    if not onScreen then return false end
    local referencePos = GunSilent.Settings.CircleMethod.Value == "Cursor" and UserInputService:GetMouseLocation() or camera.ViewportSize / 2
    local distanceFromReference = (Vector2.new(screenPos.X, screenPos.Y) - referencePos).Magnitude
    return distanceFromReference <= math.tan(math.rad(GunSilent.Settings.FOV.Value) / 2) * camera.ViewportSize.X / 2
end

local function getNearestPlayerGun(gunRange)
    local currentTime = tick()
    if currentTime - GunSilent.State.LastTargetUpdate < GunSilent.State.TargetUpdateInterval then
        local target = GunSilent.Core.GunSilentTarget.CurrentTarget
        if target and target.Character and target.Character.Humanoid and target.Character.Humanoid.Health > 0 then return target end
    end
    GunSilent.State.LastTargetUpdate = currentTime

    local friendsList = GunSilent.Core.Services.FriendsList or {}
    local friendsHash = {}
    for k in pairs(friendsList) do friendsHash[k:lower()] = true end

    local localRoot = GunSilent.State.LocalRoot
    if not localRoot then return nil end
    local rootPos = localRoot.Position
    local camera = Workspace.CurrentCamera
    if not camera then return nil end

    local nearestPlayer, shortestDistance, closestToCursor, bestScore = nil, gunRange, math.huge, math.huge
    local sortMethod = GunSilent.Settings.SortMethod.Value

    for _, player in pairs(Players:GetPlayers()) do
        if player ~= Players.LocalPlayer and not friendsHash[player.Name:lower()] then
            local targetChar = player.Character
            if targetChar then
                local targetRoot = targetChar:FindFirstChild("HumanoidRootPart")
                local targetHumanoid = targetChar:FindFirstChild("Humanoid")
                if targetRoot and targetHumanoid and targetHumanoid.Health > 0 then
                    local distance = (rootPos - targetRoot.Position).Magnitude
                    local inFov = isInFov(targetRoot.Position, camera)
                    if inFov then
                        if sortMethod == "Mouse&Distance" then
                            local screenPos = camera:WorldToViewportPoint(targetRoot.Position)
                            local cursorDistance = (Vector2.new(screenPos.X, screenPos.Y) - UserInputService:GetMouseLocation()).Magnitude
                            local score = (cursorDistance / camera.ViewportSize.X) * 0.7 + (distance / (GunSilent.Settings.RangePlus.Value + 50)) * 0.3
                            if score < bestScore then
                                bestScore = score
                                nearestPlayer = player
                            end
                        elseif sortMethod == "Distance" and distance < shortestDistance then
                            shortestDistance = distance
                            nearestPlayer = player
                        elseif sortMethod == "Mouse" then
                            local screenPos = camera:WorldToViewportPoint(targetRoot.Position)
                            local cursorDistance = (Vector2.new(screenPos.X, screenPos.Y) - UserInputService:GetMouseLocation()).Magnitude
                            if cursorDistance < closestToCursor then
                                closestToCursor = cursorDistance
                                nearestPlayer = player
                            end
                        end
                    end
                end
            end
        end
    end

    GunSilent.Core.GunSilentTarget.CurrentTarget = nearestPlayer
    GunSilent.State.LastFriendsList = friendsList
    return nearestPlayer
end

local function isInVehicle(targetChar)
    local humanoid = targetChar:FindFirstChild("Humanoid")
    if humanoid then return humanoid.SeatPart ~= nil end
    return false
end

local function resolveVelocity(target, positionHistory, clientVelocity, targetChar)
    if not GunSilent.Settings.ResolverEnabled.Value or not positionHistory or #positionHistory < 3 then return clientVelocity end

    local currentTime = tick()
    local totalVelocity = Vector3.new(0, 0, 0)
    local totalWeight = 0
    local validEntries = 0
    local maxSpeedLimit = isInVehicle(targetChar) and 150 or 80

    for i = #positionHistory - 1, math.max(1, #positionHistory - 3), -1 do
        local currEntry = positionHistory[i + 1]
        local prevEntry = positionHistory[i]
        local timeDelta = currEntry.time - prevEntry.time
        if timeDelta > 0 and timeDelta < 0.2 then
            local velocity = (currEntry.pos - prevEntry.pos) / timeDelta
            if velocity.Magnitude <= maxSpeedLimit * 1.5 then
                local weight = math.max(0.1, 1 - (currentTime - currEntry.time) * 2)
                totalVelocity = totalVelocity + velocity * weight
                totalWeight = totalWeight + weight
                validEntries = validEntries + 1
            end
        end
    end

    return validEntries > 0 and totalVelocity / totalWeight or clientVelocity
end

local function calculateAcceleration(positionHistory)
    if not positionHistory or #positionHistory < 3 then return Vector3.new(0, 0, 0) end

    local totalAcceleration = Vector3.new(0, 0, 0)
    local validEntries = 0

    for i = #positionHistory - 1, math.max(1, #positionHistory - 2), -1 do
        local currEntry = positionHistory[i + 1]
        local prevEntry = positionHistory[i]
        local timeDelta = currEntry.time - prevEntry.time
        if timeDelta > 0 and timeDelta < 0.2 then
            local velocity = (currEntry.pos - prevEntry.pos) / timeDelta
            local prevVelocity = i > 1 and (prevEntry.pos - positionHistory[i - 1].pos) / (prevEntry.time - positionHistory[i - 1].time) or velocity
            local acceleration = (velocity - prevVelocity) / timeDelta
            if acceleration.Magnitude <= 200 then
                totalAcceleration = totalAcceleration + acceleration
                validEntries = validEntries + 1
            end
        end
    end

    return validEntries > 0 and totalAcceleration / validEntries or Vector3.new(0, 0, 0)
end

local function predictTargetPositionGun(target)
    local localRoot = GunSilent.State.LocalRoot
    if not target or not target.Character or not localRoot then 
        return { position = nil, direction = nil, timeToTarget = 0, clientPosition = nil, resolvedVelocity = nil } 
    end

    local targetChar = target.Character
    local myPos = localRoot.Position
    local hitPart = targetChar:FindFirstChild(GunSilent.Settings.HitPart.Value)
    if not hitPart then hitPart = targetChar:FindFirstChild("HumanoidRootPart") end
    local targetRoot = targetChar:FindFirstChild("HumanoidRootPart")
    if not hitPart or not targetRoot then 
        return { position = nil, direction = nil, timeToTarget = 0, clientPosition = nil, resolvedVelocity = nil } 
    end

    local targetPos = hitPart.Position
    local targetId = target and target.UserId and tostring(target.UserId) or nil
    if not targetId then 
        return { position = nil, direction = nil, timeToTarget = 0, clientPosition = nil, resolvedVelocity = nil } 
    end
    GunSilent.State.LastTargetPosition[targetId] = targetPos

    local distance = (targetPos - myPos).Magnitude
    local positionHistory = GunSilent.State.PositionHistory[target] or {}
    local currentTime = tick()

    positionHistory[#positionHistory + 1] = { pos = targetPos, time = currentTime, velocity = targetRoot.Velocity }
    while #positionHistory > GunSilent.Settings.PositionHistorySize.Value do 
        table.remove(positionHistory, 1) 
    end
    GunSilent.State.PositionHistory[target] = positionHistory

    local rawVelocity = resolveVelocity(target, positionHistory, targetRoot.Velocity, targetChar)
    local smoothedVelocity = smoothVelocity(target, rawVelocity, GunSilent.Settings.SmoothingFactor.Value)

    local acceleration = calculateAcceleration(positionHistory)
    local velocityMagnitude = smoothedVelocity.Magnitude
    local maxSpeed = 80
    if velocityMagnitude > maxSpeed then
        smoothedVelocity = smoothedVelocity.Unit * maxSpeed
        velocityMagnitude = maxSpeed
    end

    local localPlayer = Players.LocalPlayer
    local rawPing = localPlayer:GetAttribute("ServerPing") or 0.05
    local ping = math.floor(rawPing * 1000 + 0.5) / 1000

    local distanceWeight = velocityMagnitude > 30 and math.min(1, (velocityMagnitude - 30) / 30) or 0

    local basePrediction = GunSilent.Settings.BasePrediction.Value
    local distanceFactor = GunSilent.Settings.DistanceFactor.Value
    local speedFactor = GunSilent.Settings.SpeedFactor.Value
    local velocityPredictionWeight = GunSilent.Settings.VelocityPredictionWeight.Value
    local pingCompensationFactor = GunSilent.Settings.PingCompensationFactor.Value

    local velocityContribution = (velocityMagnitude * distanceFactor * distanceWeight) * velocityPredictionWeight
    local distanceContribution = (distance * speedFactor) * (1 - velocityPredictionWeight)
    local pingContribution = ping * pingCompensationFactor

    local predictionTime = basePrediction + pingContribution + velocityContribution + distanceContribution

    local clientPos = targetPos
    local predictedPos = clientPos + smoothedVelocity * predictionTime + (0.5 * acceleration * predictionTime * predictionTime)

    if GunSilent.State.LastPredictionPos and GunSilent.Settings.SmoothingFactor.Value > 0 then
        predictedPos = GunSilent.State.LastPredictionPos:Lerp(predictedPos, 1 - GunSilent.Settings.SmoothingFactor.Value)
    end
    GunSilent.State.LastPredictionPos = predictedPos

    return {
        position = predictedPos,
        direction = (predictedPos - myPos).Unit,
        timeToTarget = predictionTime,
        clientPosition = clientPos,
        resolvedVelocity = smoothedVelocity
    }
end

local function getAimCFrameGun(target)
    local localRoot = GunSilent.State.LocalRoot
    if not target or not target.Character or not localRoot then return nil end
    local prediction = predictTargetPositionGun(target)
    if not prediction.position or not prediction.direction then return nil end
    return CFrame.new(localRoot.Position, localRoot.Position + prediction.direction)
end

local function createHitDataGun(target)
    local localRoot = GunSilent.State.LocalRoot
    if not target or not target.Character or not localRoot then return nil end
    local targetChar = target.Character
    local prediction = predictTargetPositionGun(target)
    if not prediction.position or not prediction.direction then return nil end

    local hitPart = targetChar:FindFirstChild(GunSilent.Settings.HitPart.Value)
    if not hitPart then hitPart = targetChar:FindFirstChild("HumanoidRootPart") end

    local finalPosition = prediction.position
    local startPos = localRoot.Position + Vector3.new(0, 1.5, 0)

    local equippedTool = getEquippedGunTool()
    local isShotgunWeapon = GunSilent.Settings.ShotgunSupport.Value and equippedTool and isShotgun(equippedTool)
    local useMultiBullets = isShotgunWeapon or GunSilent.Settings.TestGenBullet.Value
    local numBullets = useMultiBullets and (isShotgunWeapon and GunSilent.Settings.GenBullet.Value or 4) or 1
    local hitData = {}

    -- FakeHitTimestamp: Подмена временной метки в hitData
    local timestamp = tick()
    if GunSilent.Settings.FakeHitTimestampEnabled.Value then
        local timeOffset = GunSilent.Settings.FakeHitTimestampOffset.Value
        timestamp = timestamp + timeOffset
        print("[GunSilent] FakeHitTimestamp Applied: Original Timestamp = " .. tostring(tick()) .. ", Modified Timestamp = " .. tostring(timestamp))
    end

    for i = 1, numBullets do
        hitData[i] = {{Normal = prediction.direction, Instance = hitPart, Position = finalPosition, Origin = startPos, Timestamp = timestamp}}
    end

    -- FakeHitMultiplier: Дублирование hitData для увеличения количества попаданий
    if GunSilent.Settings.FakeHitMultiplierEnabled.Value then
        local multiplier = math.clamp(GunSilent.Settings.FakeHitMultiplierFactor.Value, 1, 5)
        local originalHitData = table.clone(hitData)
        for m = 2, multiplier do
            for i = 1, #originalHitData do
                hitData[#hitData + 1] = table.clone(originalHitData[i])
            end
        end
        print("[GunSilent] FakeHitMultiplier Applied: Original Hits = " .. tostring(numBullets) .. ", Multiplied Hits = " .. tostring(#hitData) .. ", Multiplier = " .. tostring(multiplier))
    end

    if GunSilent.Settings.BulletTrailsEnabled.Value and localRoot and finalPosition then
        local trail = safeCreateInstance("Beam", {
            FaceCamera = true,
            Width0 = 0.1,
            Width1 = 0.1,
            Transparency = NumberSequence.new(0),
            Color = ColorSequence.new(GunSilent.Settings.BulletTrailsColor.Value),
            Parent = Workspace
        })
        if trail then
            local attachment0 = safeCreateInstance("Attachment", { Parent = Workspace.Terrain })
            local attachment1 = safeCreateInstance("Attachment", { Parent = Workspace.Terrain })
            if attachment0 and attachment1 then
                attachment0.Position = startPos
                attachment1.Position = finalPosition
                trail.Attachment0 = attachment0
                trail.Attachment1 = attachment1

                table.insert(GunSilent.State.BulletTrails, { beam = trail, attachment0 = attachment0, attachment1 = attachment1 })

                local fadeTime = GunSilent.Settings.BulletTrailsFadeTime.Value
                local startTime = tick()
                local fadeConnection
                fadeConnection = RunService.RenderStepped:Connect(function()
                    local elapsed = tick() - startTime
                    local t = math.clamp(elapsed / fadeTime, 0, 1)
                    if trail and trail.Parent then trail.Transparency = NumberSequence.new(t) end
                    if t >= 1 then
                        if trail then trail:Destroy() end
                        if attachment0 then attachment0:Destroy() end
                        if attachment1 then attachment1:Destroy() end
                        if fadeConnection then fadeConnection:Disconnect() end
                        for i, v in ipairs(GunSilent.State.BulletTrails) do
                            if v.beam == trail then table.remove(GunSilent.State.BulletTrails, i) break end
                        end
                        for i, conn in ipairs(GunSilent.State.TrailFadeConnections) do
                            if conn == fadeConnection then table.remove(GunSilent.State.TrailFadeConnections, i) break end
                        end
                    end
                end)
                table.insert(GunSilent.State.TrailFadeConnections, fadeConnection)

                if #GunSilent.State.BulletTrails > 20 then
                    local oldTrail = table.remove(GunSilent.State.BulletTrails, 1)
                    if oldTrail.beam then oldTrail.beam:Destroy() end
                    if oldTrail.attachment0 then oldTrail.attachment0:Destroy() end
                    if oldTrail.attachment1 then oldTrail.attachment1:Destroy() end
                end
            end
        end
    end

    GunSilent.State.LastHitTarget = target
    GunSilent.State.LastHitPosition = finalPosition
    GunSilent.State.LastShotTime = tick()

    return hitData
end

local function cleanupTrajectoryBeam()
    if GunSilent.State.TrajectoryBeam then
        GunSilent.State.TrajectoryBeam:Destroy()
        GunSilent.State.TrajectoryBeam = nil
    end
    if GunSilent.State.TrajectoryAttachment0 then
        GunSilent.State.TrajectoryAttachment0:Destroy()
        GunSilent.State.TrajectoryAttachment0 = nil
    end
    if GunSilent.State.TrajectoryAttachment1 then
        GunSilent.State.TrajectoryAttachment1:Destroy()
        GunSilent.State.TrajectoryAttachment1 = nil
    end
end

local function createTrajectoryBeam(startPos, endPos)
    cleanupTrajectoryBeam()

    local trajectoryBeam = safeCreateInstance("Beam", {
        FaceCamera = true,
        Width0 = 0.15,
        Width1 = 0.15,
        Transparency = NumberSequence.new(0.4),
        Color = ColorSequence.new(Color3.fromRGB(147, 112, 219)),
        Parent = Workspace
    })
    if not trajectoryBeam then return end

    local attachment0 = safeCreateInstance("Attachment", { Parent = Workspace.Terrain })
    local attachment1 = safeCreateInstance("Attachment", { Parent = Workspace.Terrain })
    if not attachment0 or not attachment1 then
        trajectoryBeam:Destroy()
        if attachment0 then attachment0:Destroy() end
        if attachment1 then attachment1:Destroy() end
        return
    end

    attachment0.Position = startPos
    attachment1.Position = endPos
    trajectoryBeam.Attachment0 = attachment0
    trajectoryBeam.Attachment1 = attachment1

    GunSilent.State.TrajectoryBeam = trajectoryBeam
    GunSilent.State.TrajectoryAttachment0 = attachment0
    GunSilent.State.TrajectoryAttachment1 = attachment1
end

local function updateVisualsGun(target)
    local currentTime = tick()
    if currentTime - GunSilent.State.LastVisualUpdateTime < 0.0345 then return end
    GunSilent.State.LastVisualUpdateTime = currentTime

    local localRoot = GunSilent.State.LocalRoot
    if not GunSilent.Settings.Enabled.Value or not localRoot then
        if GunSilent.State.PredictVisualPart then GunSilent.State.PredictVisualPart.Transparency = 1 end
        if GunSilent.State.TrajectoryBeam then GunSilent.State.TrajectoryBeam.Enabled = false end
        return
    end

    local prediction = target and predictTargetPositionGun(target)
    local targetPos = prediction and prediction.clientPosition
    local predictionPos = prediction and prediction.position

    if not target or not target.Character or not predictionPos or not prediction.direction then
        if GunSilent.State.PredictVisualPart then GunSilent.State.PredictVisualPart.Transparency = 1 end
        if GunSilent.State.TrajectoryBeam then GunSilent.State.TrajectoryBeam.Enabled = false end
        return
    end

    if GunSilent.State.LastTargetPos and (targetPos - GunSilent.State.LastTargetPos).Magnitude < 1 then return end

    local targetChar = target.Character
    local hitPart = targetChar:FindFirstChild(GunSilent.Settings.HitPart.Value)
    if not hitPart then hitPart = targetChar:FindFirstChild("HumanoidRootPart") end

    GunSilent.State.LastTargetPos, GunSilent.State.LastPredictionPos = targetPos, predictionPos
    local startPos = localRoot.Position + Vector3.new(0, 1.5, 0)

    if GunSilent.Settings.PredictVisual.Value then
        local predictVisualPart = GunSilent.State.PredictVisualPart
        if not predictVisualPart or not predictVisualPart.Parent then
            predictVisualPart = safeCreateInstance("Part", {
                Size = Vector3.new(0.5, 0.5, 0.5),
                Shape = Enum.PartType.Ball,
                Anchored = true,
                CanCollide = false,
                Transparency = 0.3,
                Parent = Workspace
            })
            GunSilent.State.PredictVisualPart = predictVisualPart
        end
        if predictVisualPart then
            predictVisualPart.Position = predictionPos
            predictVisualPart.Color = Color3.fromRGB(0, 255, 255)
            predictVisualPart.Transparency = 0.3
        end
    elseif GunSilent.State.PredictVisualPart then
        GunSilent.State.PredictVisualPart.Transparency = 1
    end

    if GunSilent.Settings.TrajectoryBeam.Value and GunSilent.Settings.PredictVisual.Value then
        if not GunSilent.State.TrajectoryBeam or not GunSilent.State.TrajectoryAttachment0 or not GunSilent.State.TrajectoryAttachment1 then
            createTrajectoryBeam(startPos, predictionPos)
        else
            GunSilent.State.TrajectoryAttachment0.Position = startPos
            GunSilent.State.TrajectoryAttachment1.Position = predictionPos
            GunSilent.State.TrajectoryBeam.Enabled = true
        end
    else
        if GunSilent.State.TrajectoryBeam then GunSilent.State.TrajectoryBeam.Enabled = false end
    end
end

local function initializeGunSilent()
    if GunSilent.State.Connection then GunSilent.State.Connection:Disconnect() end
    if not GunSilent.State.V_U_4 then
        for _, obj in pairs(getgc(true)) do
            if type(obj) == "table" and not getmetatable(obj) and obj.event and obj.func then
                GunSilent.State.V_U_4 = obj
                break
            end
        end
    end

    local remoteEvent = ReplicatedStorage:FindFirstChild("Remotes") and ReplicatedStorage.Remotes:FindFirstChild("Send")
    if not remoteEvent or not remoteEvent:IsA("RemoteEvent") then return end

    remoteEvent.OnClientEvent:Connect(function(...)
        local args = {...}
        if args[1] == "hit_confirmed" then
            local headshot = args[2]
            local kill = args[3]
            local pendingHit = GunSilent.State.PendingHits[GunSilent.State.LastEventId] or
                             { target = GunSilent.Core.GunSilentTarget.CurrentTarget, position = GunSilent.State.LastHitPosition }
            if pendingHit.target then
                -- ForceHitConfirmation: Принудительное подтверждение попадания
                if GunSilent.Settings.ForceHitConfirmationEnabled.Value then
                    local originalHeadshot = headshot
                    headshot = true -- Принудительно подтверждаем попадание
                    print("[GunSilent] ForceHitConfirmation Applied: Original Headshot = " .. tostring(originalHeadshot) .. ", Forced Headshot = " .. tostring(headshot))
                end
                if headshot or kill then
                    spawnHitParticles(pendingHit.target, pendingHit.position)
                    spawnHitVisual(pendingHit.target, pendingHit.position)
                    print("[GunSilent] Hit Confirmed: Target = " .. pendingHit.target.Name .. ", Position = " .. tostring(pendingHit.position))
                else
                    print("[GunSilent] Hit Rejected: Target = " .. pendingHit.target.Name)
                end
                if GunSilent.State.PendingHits[GunSilent.State.LastEventId] then
                    GunSilent.State.PendingHits[GunSilent.State.LastEventId] = nil
                end
            end
        end
    end)

    if not GunSilent.State.OldFireServer then
        GunSilent.State.OldFireServer = hookfunction(remoteEvent.FireServer, function(self, ...)
            local args = {...}
            local modifiedArgs = args
            local nearestPlayer = nil
            if GunSilent.Settings.Enabled.Value and #args >= 2 and typeof(args[1]) == "number" and math.random(100) <= GunSilent.Settings.HitChance.Value then
                GunSilent.State.LastEventId = args[1]
                local equippedTool = getEquippedGunTool()
                if equippedTool and args[2] == "shoot_gun" then
                    local gunRange = getGunRange(equippedTool)
                    nearestPlayer = getNearestPlayerGun(gunRange)
                    if nearestPlayer then
                        local aimCFrame = getAimCFrameGun(nearestPlayer)
                        local hitData = createHitDataGun(nearestPlayer)
                        if aimCFrame and hitData then
                            modifiedArgs = {args[1], args[2], equippedTool, aimCFrame, hitData}

                            -- OverrideServerTick: Синхронизация клиентского времени с серверным
                            if GunSilent.Settings.OverrideServerTickEnabled.Value then
                                local serverTickOffset = GunSilent.Settings.ServerTickOffset.Value
                                local originalTimestamp = hitData[1][1].Timestamp
                                local adjustedTimestamp = tick() + serverTickOffset
                                for i, data in ipairs(hitData) do
                                    for j, hit in ipairs(data) do
                                        hit.Timestamp = adjustedTimestamp
                                    end
                                end
                                print("[GunSilent] OverrideServerTick Applied: Original Timestamp = " .. tostring(originalTimestamp) .. ", Adjusted Timestamp = " .. tostring(adjustedTimestamp) .. ", Offset = " .. tostring(serverTickOffset))
                            end

                            GunSilent.State.PendingHits[args[1]] = {
                                target = nearestPlayer,
                                position = GunSilent.State.LastHitPosition
                            }
                        end
                    end
                end
            end

            local success, result = pcall(function()
                return GunSilent.State.OldFireServer(self, unpack(modifiedArgs))
            end)

            if not success then
                if GunSilent.State.PendingHits[GunSilent.State.LastEventId] then
                    GunSilent.State.PendingHits[GunSilent.State.LastEventId] = nil
                end
            end

            return success and result or nil
        end)
    end

    GunSilent.State.Connection = RunService.RenderStepped:Connect(function(deltaTime)
        if not GunSilent.Settings.Enabled.Value then
            if GunSilent.State.FovCircle then GunSilent.State.FovCircle.Visible = false end
            GunSilent.Core.GunSilentTarget.CurrentTarget = nil
            updateVisualsGun(nil)
            return
        end

        local character = GunSilent.State.LocalCharacter
        if character and character:FindFirstChild("HumanoidRootPart") then
            GunSilent.State.LocalRoot = character.HumanoidRootPart
        else
            GunSilent.State.LocalRoot = nil
        end

        local currentTool = getEquippedGunTool()
        if currentTool ~= GunSilent.State.LastTool then
            GunSilent.State.PositionHistory = {}
            GunSilent.State.SmoothedVelocity = {}
            GunSilent.State.LastTool = currentTool
        end

        updateFovCircle()
        if not currentTool then
            GunSilent.Core.GunSilentTarget.CurrentTarget = nil
            updateVisualsGun(nil)
            return
        end

        local gunRange = getGunRange(currentTool)
        local nearestPlayer = getNearestPlayerGun(gunRange)
        if nearestPlayer ~= GunSilent.Core.GunSilentTarget.CurrentTarget then
            GunSilent.State.PositionHistory[nearestPlayer] = nil
            GunSilent.State.SmoothedVelocity[nearestPlayer] = nil
        end
        updateVisualsGun(nearestPlayer)
    end)
end

local function Init(UI, Core, notify)
    GunSilent.Core = Core
    GunSilent.notify = notify

    local LocalPlayer = Core.PlayerData.LocalPlayer
    if LocalPlayer then
        LocalPlayer.CharacterAdded:Connect(function(character)
            character:WaitForChild("HumanoidRootPart")
            GunSilent.State.LocalCharacter = character
            GunSilent.State.LocalRoot = character.HumanoidRootPart
            GunSilent.State.CurrentToolRangeApplied = nil
            GunSilent.State.BaseRangeCache = {}
            GunSilent.State.PositionHistory = {}
            GunSilent.State.SmoothedVelocity = {}
            cleanupTrajectoryBeam()
        end)
        if LocalPlayer.Character then
            GunSilent.State.LocalCharacter = LocalPlayer.Character
            GunSilent.State.LocalRoot = LocalPlayer.Character:FindFirstChild("HumanoidRootPart")
        end

        local humanoid = LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("Humanoid")
        if humanoid then
            humanoid.Died:Connect(cleanupTrajectoryBeam)
        end
        LocalPlayer.CharacterAdded:Connect(function(character)
            local newHumanoid = character:WaitForChild("Humanoid")
            newHumanoid.Died:Connect(cleanupTrajectoryBeam)
        end)
    end

    local CombatElements = {}
    local VisualsElements = {}

    if UI.Tabs.Combat then
        local combatSection = UI.Tabs.Combat:Section({ Side = "Right", Name = "GunSilent" })
        if combatSection then
            combatSection:Header({ Name = "GunSilent" })
            CombatElements.GSEnabled = {
                element = combatSection:Toggle({
                    Name = "Enabled",
                    Default = GunSilent.Settings.Enabled.Value,
                    Callback = function(value)
                        GunSilent.Settings.Enabled.Value = value
                        initializeGunSilent()
                    end
                }, 'GSEnabled'),
                callback = function(value)
                    GunSilent.Settings.Enabled.Value = value
                    initializeGunSilent()
                end
            }
            CombatElements.RangePlus = {
                element = combatSection:Slider({
                    Name = "Range Plus",
                    Minimum = 0,
                    Maximum = 300,
                    Default = GunSilent.Settings.RangePlus.Value,
                    Precision = 0,
                    Callback = function(value)
                        GunSilent.Settings.RangePlus.Value = value
                        local currentTool = getEquippedGunTool()
                        if currentTool then
                            GunSilent.State.CurrentToolRangeApplied = nil
                            getGunRange(currentTool)
                        end
                    end
                }, 'RangePlus'),
                callback = function(value)
                    GunSilent.Settings.RangePlus.Value = value
                    local currentTool = getEquippedGunTool()
                    if currentTool then
                        GunSilent.State.CurrentToolRangeApplied = nil
                        getGunRange(currentTool)
                    end
                end
            }
            CombatElements.HitPart = {
                element = combatSection:Dropdown({
                    Name = "Hit Part",
                    Default = GunSilent.Settings.HitPart.Value,
                    Options = {"Head", "UpperTorso", "HumanoidRootPart"},
                    Callback = function(value) GunSilent.Settings.HitPart.Value = value end
                }, 'HitPart'),
                callback = function(value) GunSilent.Settings.HitPart.Value = value end
            }
            CombatElements.ShotgunSupport = {
                element = combatSection:Toggle({
                    Name = "Shotgun Support",
                    Default = GunSilent.Settings.ShotgunSupport.Value,
                    Callback = function(value) GunSilent.Settings.ShotgunSupport.Value = value end
                }, 'ShotgunSupport'),
                callback = function(value) GunSilent.Settings.ShotgunSupport.Value = value end
            }
            CombatElements.GenerateBullets = {
                element = combatSection:Slider({
                    Name = "Generate Bullets",
                    Default = GunSilent.Settings.GenBullet.Value,
                    Minimum = 1,
                    Maximum = 10,
                    Precision = 0,
                    Callback = function(value) GunSilent.Settings.GenBullet.Value = value end
                }, 'GenerateBullets'),
                callback = function(value) GunSilent.Settings.GenBullet.Value = value end
            }
            CombatElements.TestGenerateBullets = {
                element = combatSection:Toggle({
                    Name = "Test Generate Bullets",
                    Default = GunSilent.Settings.TestGenBullet.Value,
                    Callback = function(value) GunSilent.Settings.TestGenBullet.Value = value end
                }, 'TestGenerateBullets'),
                callback = function(value) GunSilent.Settings.TestGenBullet.Value = value end
            }
            CombatElements.SortMethod = {
                element = combatSection:Dropdown({
                    Name = "Sort Method",
                    Default = GunSilent.Settings.SortMethod.Value,
                    Options = {"Mouse", "Distance", "Mouse&Distance"},
                    Callback = function(value) GunSilent.Settings.SortMethod.Value = value end
                }, 'SortMethod'),
                callback = function(value) GunSilent.Settings.SortMethod.Value = value end
            }
            CombatElements.UseFOV = {
                element = combatSection:Toggle({
                    Name = "Use FOV",
                    Default = GunSilent.Settings.UseFOV.Value,
                    Callback = function(value) GunSilent.Settings.UseFOV.Value = value end
                }, 'UseFOV'),
                callback = function(value) GunSilent.Settings.UseFOV.Value = value end
            }
            CombatElements.FOV = {
                element = combatSection:Slider({
                    Name = "FOV",
                    Default = GunSilent.Settings.FOV.Value,
                    Minimum = 30,
                    Maximum = 120,
                    Precision = 0,
                    Callback = function(value) GunSilent.Settings.FOV.Value = value end
                }, 'FOV'),
                callback = function(value) GunSilent.Settings.FOV.Value = value end
            }
            CombatElements.ShowCircle = {
                element = combatSection:Toggle({
                    Name = "Show Circle",
                    Default = GunSilent.Settings.ShowCircle.Value,
                    Callback = function(value) GunSilent.Settings.ShowCircle.Value = value end
                }, 'ShowCircle'),
                callback = function(value) GunSilent.Settings.ShowCircle.Value = value end
            }
            CombatElements.CircleMethod = {
                element = combatSection:Dropdown({
                    Name = "Circle Method",
                    Default = GunSilent.Settings.CircleMethod.Value,
                    Options = GunSilent.Settings.CircleMethod.Options,
                    Callback = function(value) GunSilent.Settings.CircleMethod.Value = value end
                }, 'CircleMethod'),
                callback = function(value) GunSilent.Settings.CircleMethod.Value = value end
            }
            combatSection:Header({ Name = "Visuals" })
            CombatElements.PredictVisual = {
                element = combatSection:Toggle({
                    Name = "Predict Visual",
                    Default = GunSilent.Settings.PredictVisual.Value,
                    Callback = function(value) GunSilent.Settings.PredictVisual.Value = value end
                }, 'PredictVisual'),
                callback = function(value) GunSilent.Settings.PredictVisual.Value = value end
            }
            CombatElements.TrajectoryBeam = {
                element = combatSection:Toggle({
                    Name = "Trajectory Beam",
                    Default = GunSilent.Settings.TrajectoryBeam.Value,
                    Callback = function(value)
                        GunSilent.Settings.TrajectoryBeam.Value = value
                        if not value then cleanupTrajectoryBeam() end
                    end
                }, 'TrajectoryBeam'),
                callback = function(value)
                    GunSilent.Settings.TrajectoryBeam.Value = value
                    if not value then cleanupTrajectoryBeam() end
                end
            }
            CombatElements.HitChance = {
                element = combatSection:Slider({
                    Name = "Hit Chance",
                    Default = GunSilent.Settings.HitChance.Value,
                    Minimum = 0,
                    Maximum = 100,
                    Precision = 0,
                    Callback = function(value) GunSilent.Settings.HitChance.Value = value end
                }, 'HitChance'),
                callback = function(value) GunSilent.Settings.HitChance.Value = value end
            }
            combatSection:Header({ Name = "Prediction Settings" })
            CombatElements.ResolverEnabled = {
                element = combatSection:Toggle({
                    Name = "Resolver Enabled",
                    Default = GunSilent.Settings.ResolverEnabled.Value,
                    Callback = function(value) GunSilent.Settings.ResolverEnabled.Value = value end
                }, 'ResolverEnabled'),
                callback = function(value) GunSilent.Settings.ResolverEnabled.Value = value end
            }
            CombatElements.ResolverThreshold = {
                element = combatSection:Slider({
                    Name = "Resolver Threshold",
                    Minimum = 0.2,
                    Maximum = 0.5,
                    Default = GunSilent.Settings.ResolverThreshold.Value,
                    Precision = 2,
                    Callback = function(value) GunSilent.Settings.ResolverThreshold.Value = value end
                }, 'ResolverThreshold'),
                callback = function(value) GunSilent.Settings.ResolverThreshold.Value = value end
            }
            CombatElements.BasePrediction = {
                element = combatSection:Slider({
                    Name = "Base Prediction",
                    Minimum = 0.05,
                    Maximum = 0.5,
                    Default = GunSilent.Settings.BasePrediction.Value,
                    Precision = 2,
                    Callback = function(value) GunSilent.Settings.BasePrediction.Value = value end
                }, 'BasePrediction'),
                callback = function(value) GunSilent.Settings.BasePrediction.Value = value end
            }
            CombatElements.VelocityPredictionWeight = {
                element = combatSection:Slider({
                    Name = "Velocity Prediction Weight",
                    Minimum = 0,
                    Maximum = 1,
                    Default = GunSilent.Settings.VelocityPredictionWeight.Value,
                    Precision = 2,
                    Callback = function(value) GunSilent.Settings.VelocityPredictionWeight.Value = value end
                }, 'VelocityPredictionWeight'),
                callback = function(value) GunSilent.Settings.VelocityPredictionWeight.Value = value end
            }
            CombatElements.PingCompensationFactor = {
                element = combatSection:Slider({
                    Name = "Ping Compensation Factor",
                    Minimum = 0.5,
                    Maximum = 2,
                    Default = GunSilent.Settings.PingCompensationFactor.Value,
                    Precision = 2,
                    Callback = function(value) GunSilent.Settings.PingCompensationFactor.Value = value end
                }, 'PingCompensationFactor'),
                callback = function(value) GunSilent.Settings.PingCompensationFactor.Value = value end
            }
            CombatElements.SmoothingFactor = {
                element = combatSection:Slider({
                    Name = "Smoothing Factor",
                    Minimum = 0,
                    Maximum = 1,
                    Default = GunSilent.Settings.SmoothingFactor.Value,
                    Precision = 2,
                    Callback = function(value) GunSilent.Settings.SmoothingFactor.Value = value end
                }, 'SmoothingFactor'),
                callback = function(value) GunSilent.Settings.SmoothingFactor.Value = value end
            }
            CombatElements.DistanceFactor = {
                element = combatSection:Slider({
                    Name = "Distance Factor",
                    Minimum = 0.001,
                    Maximum = 0.01,
                    Default = GunSilent.Settings.DistanceFactor.Value,
                    Precision = 4,
                    Callback = function(value) GunSilent.Settings.DistanceFactor.Value = value end
                }, 'DistanceFactor'),
                callback = function(value) GunSilent.Settings.DistanceFactor.Value = value end
            }
            CombatElements.SpeedFactor = {
                element = combatSection:Slider({
                    Name = "Speed Factor",
                    Minimum = 0.00001,
                    Maximum = 0.0001,
                    Default = GunSilent.Settings.SpeedFactor.Value,
                    Precision = 5,
                    Callback = function(value) GunSilent.Settings.SpeedFactor.Value = value end
                }, 'SpeedFactor'),
                callback = function(value) GunSilent.Settings.SpeedFactor.Value = value end
            }

            -- Новая секция для эксплоитов: GunSilent Mods
            combatSection:Header({ Name = "GunSilent Mods" })
            CombatElements.FakeHitTimestampEnabled = {
                element = combatSection:Toggle({
                    Name = "FakeHitTimestamp Enabled",
                    Default = GunSilent.Settings.FakeHitTimestampEnabled.Value,
                    Callback = function(value) GunSilent.Settings.FakeHitTimestampEnabled.Value = value end
                }, 'FakeHitTimestampEnabled'),
                callback = function(value) GunSilent.Settings.FakeHitTimestampEnabled.Value = value end
            }
            CombatElements.FakeHitTimestampOffset = {
                element = combatSection:Slider({
                    Name = "FakeHitTimestamp Offset",
                    Default = GunSilent.Settings.FakeHitTimestampOffset.Value,
                    Minimum = -0.1,
                    Maximum = 0.1,
                    Precision = 2,
                    Callback = function(value) GunSilent.Settings.FakeHitTimestampOffset.Value = value end
                }, 'FakeHitTimestampOffset'),
                callback = function(value) GunSilent.Settings.FakeHitTimestampOffset.Value = value end
            }
            CombatElements.ForceHitConfirmationEnabled = {
                element = combatSection:Toggle({
                    Name = "ForceHitConfirmation Enabled",
                    Default = GunSilent.Settings.ForceHitConfirmationEnabled.Value,
                    Callback = function(value) GunSilent.Settings.ForceHitConfirmationEnabled.Value = value end
                }, 'ForceHitConfirmationEnabled'),
                callback = function(value) GunSilent.Settings.ForceHitConfirmationEnabled.Value = value end
            }
            CombatElements.OverrideServerTickEnabled = {
                element = combatSection:Toggle({
                    Name = "OverrideServerTick Enabled",
                    Default = GunSilent.Settings.OverrideServerTickEnabled.Value,
                    Callback = function(value) GunSilent.Settings.OverrideServerTickEnabled.Value = value end
                }, 'OverrideServerTickEnabled'),
                callback = function(value) GunSilent.Settings.OverrideServerTickEnabled.Value = value end
            }
            CombatElements.ServerTickOffset = {
                element = combatSection:Slider({
                    Name = "ServerTick Offset",
                    Default = GunSilent.Settings.ServerTickOffset.Value,
                    Minimum = -0.1,
                    Maximum = 0.1,
                    Precision = 2,
                    Callback = function(value) GunSilent.Settings.ServerTickOffset.Value = value end
                }, 'ServerTickOffset'),
                callback = function(value) GunSilent.Settings.ServerTickOffset.Value = value end
            }
            CombatElements.FakeHitMultiplierEnabled = {
                element = combatSection:Toggle({
                    Name = "FakeHitMultiplier Enabled",
                    Default = GunSilent.Settings.FakeHitMultiplierEnabled.Value,
                    Callback = function(value) GunSilent.Settings.FakeHitMultiplierEnabled.Value = value end
                }, 'FakeHitMultiplierEnabled'),
                callback = function(value) GunSilent.Settings.FakeHitMultiplierEnabled.Value = value end
            }
            CombatElements.FakeHitMultiplierFactor = {
                element = combatSection:Slider({
                    Name = "FakeHitMultiplier Factor",
                    Default = GunSilent.Settings.FakeHitMultiplierFactor.Value,
                    Minimum = 1,
                    Maximum = 5,
                    Precision = 0,
                    Callback = function(value) GunSilent.Settings.FakeHitMultiplierFactor.Value = value end
                }, 'FakeHitMultiplierFactor'),
                callback = function(value) GunSilent.Settings.FakeHitMultiplierFactor.Value = value end
            }
        end
    end

    if UI.Tabs.Visuals then
        local bulletTrailsSection = UI.Tabs.Visuals:Section({ Side = "Right", Name = "Bullet Trails" })
        if bulletTrailsSection then
            bulletTrailsSection:Header({ Name = "Bullet Trails" })
            VisualsElements.BulletTrailsEnabled = {
                element = bulletTrailsSection:Toggle({
                    Name = "Enabled",
                    Default = GunSilent.Settings.BulletTrailsEnabled.Value,
                    Callback = function(value)
                        GunSilent.Settings.BulletTrailsEnabled.Value = value
                        if not value then
                            for _, trailData in ipairs(GunSilent.State.BulletTrails) do
                                if trailData.beam then trailData.beam:Destroy() end
                                if trailData.attachment0 then trailData.attachment0:Destroy() end
                                if trailData.attachment1 then trailData.attachment1:Destroy() end
                            end
                            GunSilent.State.BulletTrails = {}
                            for _, conn in ipairs(GunSilent.State.TrailFadeConnections) do
                                if conn then conn:Disconnect() end
                            end
                            GunSilent.State.TrailFadeConnections = {}
                        end
                    end
                }, 'BulletTrailsEnabled'),
                callback = function(value)
                    GunSilent.Settings.BulletTrailsEnabled.Value = value
                    if not value then
                        for _, trailData in ipairs(GunSilent.State.BulletTrails) do
                            if trailData.beam then trailData.beam:Destroy() end
                            if trailData.attachment0 then trailData.attachment0:Destroy() end
                            if trailData.attachment1 then trailData.attachment1:Destroy() end
                        end
                        GunSilent.State.BulletTrails = {}
                        for _, conn in ipairs(GunSilent.State.TrailFadeConnections) do
                            if conn then conn:Disconnect() end
                        end
                        GunSilent.State.TrailFadeConnections = {}
                    end
                end
            }
            VisualsElements.BulletTrailsFadeTime = {
                element = bulletTrailsSection:Slider({
                    Name = "Fade Time",
                    Default = GunSilent.Settings.BulletTrailsFadeTime.Value,
                    Minimum = 0.5,
                    Maximum = 3,
                    Precision = 1,
                    Callback = function(value) GunSilent.Settings.BulletTrailsFadeTime.Value = value end
                }, 'BulletTrailsFadeTime'),
                callback = function(value) GunSilent.Settings.BulletTrailsFadeTime.Value = value end
            }
            VisualsElements.BulletTrailsColor = {
                element = bulletTrailsSection:Colorpicker({
                    Name = "Trails Color",
                    Default = GunSilent.Settings.BulletTrailsColor.Value,
                    Callback = function(value) GunSilent.Settings.BulletTrailsColor.Value = value end
                }, 'BulletTrailsColor'),
                callback = function(value) GunSilent.Settings.BulletTrailsColor.Value = value end
            }
        end

        local hitParticlesSection = UI.Tabs.Visuals:Section({ Side = "Left", Name = "Hit Particles" })
        if hitParticlesSection then
            hitParticlesSection:Header({ Name = "Hit Particles" })
            VisualsElements.HitParticlesEnabled = {
                element = hitParticlesSection:Toggle({
                    Name = "Enabled",
                    Default = GunSilent.Settings.HitParticlesEnabled.Value,
                    Callback = function(value) GunSilent.Settings.HitParticlesEnabled.Value = value end
                }, 'HitParticlesEnabled'),
                callback = function(value) GunSilent.Settings.HitParticlesEnabled.Value = value end
            }
            VisualsElements.UseGradient = {
                element = hitParticlesSection:Toggle({
                    Name = "Use Gradient",
                    Default = GunSilent.Settings.UseGradient.Value,
                    Callback = function(value) GunSilent.Settings.UseGradient.Value = value end
                }, 'UseGradient'),
                callback = function(value) GunSilent.Settings.UseGradient.Value = value end
            }
            VisualsElements.HitParticlesMode = {
                element = hitParticlesSection:Dropdown({
                    Name = "Mode",
                    Default = GunSilent.Settings.HitParticlesMode.Value,
                    Options = GunSilent.Settings.HitParticlesMode.Options,
                    Callback = function(value) GunSilent.Settings.HitParticlesMode.Value = value end
                }, 'HitParticlesMode'),
                callback = function(value) GunSilent.Settings.HitParticlesMode.Value = value end
            }
            VisualsElements.ParticlePhysics = {
                element = hitParticlesSection:Dropdown({
                    Name = "Particle Physics",
                    Default = GunSilent.Settings.ParticlePhysics.Value,
                    Options = GunSilent.Settings.ParticlePhysics.Options,
                    Callback = function(value) GunSilent.Settings.ParticlePhysics.Value = value end
                }, 'ParticlePhysics'),
                callback = function(value) GunSilent.Settings.ParticlePhysics.Value = value end
            }
            VisualsElements.HitParticlesCount = {
                element = hitParticlesSection:Slider({
                    Name = "Particle Count",
                    Default = GunSilent.Settings.HitParticlesCount.Value,
                    Minimum = 5,
                    Maximum = 50,
                    Precision = 0,
                    Callback = function(value) GunSilent.Settings.HitParticlesCount.Value = value end
                }, 'HitParticlesCount'),
                callback = function(value) GunSilent.Settings.HitParticlesCount.Value = value end
            }
            VisualsElements.HitParticlesLifetime = {
                element = hitParticlesSection:Slider({
                    Name = "Lifetime",
                    Default = GunSilent.Settings.HitParticlesLifetime.Value,
                    Minimum = 0.3,
                    Maximum = 2,
                    Precision = 1,
                    Callback = function(value) GunSilent.Settings.HitParticlesLifetime.Value = value end
                }, 'HitParticlesLifetime'),
                callback = function(value) GunSilent.Settings.HitParticlesLifetime.Value = value end
            }
            VisualsElements.HitParticlesMoveDistance = {
                element = hitParticlesSection:Slider({
                    Name = "Move Distance",
                    Default = GunSilent.Settings.HitParticlesMoveDistance.Value,
                    Minimum = 2,
                    Maximum = 20,
                    Precision = 0,
                    Callback = function(value) GunSilent.Settings.HitParticlesMoveDistance.Value = value end
                }, 'HitParticlesMoveDistance'),
                callback = function(value) GunSilent.Settings.HitParticlesMoveDistance.Value = value end
            }
            VisualsElements.HitParticlesColor = {
                element = hitParticlesSection:Colorpicker({
                    Name = "Particles Color",
                    Default = GunSilent.Settings.HitParticlesColor.Value,
                    Callback = function(value) GunSilent.Settings.HitParticlesColor.Value = value end
                }, 'HitParticlesColor'),
                callback = function(value) GunSilent.Settings.HitParticlesColor.Value = value end
            }
        end

        local hitVisualSection = UI.Tabs.Visuals:Section({ Side = "Left", Name = "Hit Visual" })
        if hitVisualSection then
            hitVisualSection:Header({ Name = "Hit Visual" })
            VisualsElements.HitVisualEnabled = {
                element = hitVisualSection:Toggle({
                    Name = "Enabled",
                    Default = GunSilent.Settings.HitVisualEnabled.Value,
                    Callback = function(value) GunSilent.Settings.HitVisualEnabled.Value = value end
                }, 'HitVisualEnabled'),
                callback = function(value) GunSilent.Settings.HitVisualEnabled.Value = value end
            }
            VisualsElements.HitVisualAnimate = {
                element = hitVisualSection:Toggle({
                    Name = "Animate",
                    Default = GunSilent.Settings.HitVisualAnimate.Value,
                    Callback = function(value) GunSilent.Settings.HitVisualAnimate.Value = value end
                }, 'HitVisualAnimate'),
                callback = function(value) GunSilent.Settings.HitVisualAnimate.Value = value end
            }
            VisualsElements.HitVisualFadeTime = {
                element = hitVisualSection:Slider({
                    Name = "Fade Time",
                    Default = GunSilent.Settings.HitVisualFadeTime.Value,
                    Minimum = 0.5,
                    Maximum = 3,
                    Precision = 1,
                    Callback = function(value) GunSilent.Settings.HitVisualFadeTime.Value = value end
                }, 'HitVisualFadeTime'),
                callback = function(value) GunSilent.Settings.HitVisualFadeTime.Value = value end
            }
            VisualsElements.HitVisualTransparency = {
                element = hitVisualSection:Slider({
                    Name = "Transparency",
                    Default = GunSilent.Settings.HitVisualTransparency.Value,
                    Minimum = 0,
                    Maximum = 1,
                    Precision = 2,
                    Callback = function(value) GunSilent.Settings.HitVisualTransparency.Value = value end
                }, 'HitVisualTransparency'),
                callback = function(value) GunSilent.Settings.HitVisualTransparency.Value = value end
            }
            VisualsElements.HitVisualColor = {
                element = hitVisualSection:Colorpicker({
                    Name = "Visual Color",
                    Default = GunSilent.Settings.HitVisualColor.Value,
                    Callback = function(value) GunSilent.Settings.HitVisualColor.Value = value end
                }, 'HitVisualColor'),
                callback = function(value) GunSilent.Settings.HitVisualColor.Value = value end
            }
        end
    end

    local gunconfigSection
    if UI.Tabs.Config then
        gunconfigSection = UI.Tabs.Config:Section({ Name = "GunSilent Sync", Side = "Right" })
        gunconfigSection:Header({ Name = "GunSilent Settings Sync" })
        gunconfigSection:Button({
            Name = "Sync Settings",
            Callback = function()
                CombatElements.GSEnabled.callback(CombatElements.GSEnabled.element:GetState())
                CombatElements.RangePlus.callback(CombatElements.RangePlus.element:GetValue())
                local hitPartOptions = CombatElements.HitPart.element:GetOptions()
                for option, selected in pairs(hitPartOptions) do
                    if selected then CombatElements.HitPart.callback(option) break end
                end
                CombatElements.ShotgunSupport.callback(CombatElements.ShotgunSupport.element:GetState())
                CombatElements.GenerateBullets.callback(CombatElements.GenerateBullets.element:GetValue())
                CombatElements.TestGenerateBullets.callback(CombatElements.TestGenerateBullets.element:GetState())
                local sortMethodOptions = CombatElements.SortMethod.element:GetOptions()
                for option, selected in pairs(sortMethodOptions) do
                    if selected then CombatElements.SortMethod.callback(option) break end
                end
                CombatElements.UseFOV.callback(CombatElements.UseFOV.element:GetState())
                CombatElements.FOV.callback(CombatElements.FOV.element:GetValue())
                CombatElements.ShowCircle.callback(CombatElements.ShowCircle.element:GetState())
                local circleMethodOptions = CombatElements.CircleMethod.element:GetOptions()
                for option, selected in pairs(circleMethodOptions) do
                    if selected then CombatElements.CircleMethod.callback(option) break end
                end
                CombatElements.PredictVisual.callback(CombatElements.PredictVisual.element:GetState())
                CombatElements.TrajectoryBeam.callback(CombatElements.TrajectoryBeam.element:GetState())
                CombatElements.HitChance.callback(CombatElements.HitChance.element:GetValue())
                CombatElements.ResolverEnabled.callback(CombatElements.ResolverEnabled.element:GetState())
                CombatElements.ResolverThreshold.callback(CombatElements.ResolverThreshold.element:GetValue())
                CombatElements.BasePrediction.callback(CombatElements.BasePrediction.element:GetValue())
                CombatElements.VelocityPredictionWeight.callback(CombatElements.VelocityPredictionWeight.element:GetValue())
                CombatElements.PingCompensationFactor.callback(CombatElements.PingCompensationFactor.element:GetValue())
                CombatElements.SmoothingFactor.callback(CombatElements.SmoothingFactor.element:GetValue())
                CombatElements.DistanceFactor.callback(CombatElements.DistanceFactor.element:GetValue())
                CombatElements.SpeedFactor.callback(CombatElements.SpeedFactor.element:GetValue())
                CombatElements.FakeHitTimestampEnabled.callback(CombatElements.FakeHitTimestampEnabled.element:GetState())
                CombatElements.FakeHitTimestampOffset.callback(CombatElements.FakeHitTimestampOffset.element:GetValue())
                CombatElements.ForceHitConfirmationEnabled.callback(CombatElements.ForceHitConfirmationEnabled.element:GetState())
                CombatElements.OverrideServerTickEnabled.callback(CombatElements.OverrideServerTickEnabled.element:GetState())
                CombatElements.ServerTickOffset.callback(CombatElements.ServerTickOffset.element:GetValue())
                CombatElements.FakeHitMultiplierEnabled.callback(CombatElements.FakeHitMultiplierEnabled.element:GetState())
                CombatElements.FakeHitMultiplierFactor.callback(CombatElements.FakeHitMultiplierFactor.element:GetValue())
                VisualsElements.BulletTrailsEnabled.callback(VisualsElements.BulletTrailsEnabled.element:GetState())
                VisualsElements.BulletTrailsFadeTime.callback(VisualsElements.BulletTrailsFadeTime.element:GetValue())
                VisualsElements.HitParticlesEnabled.callback(VisualsElements.HitParticlesEnabled.element:GetState())
                VisualsElements.UseGradient.callback(VisualsElements.UseGradient.element:GetState())
                local hitParticlesModeOptions = VisualsElements.HitParticlesMode.element:GetOptions()
                for option, selected in pairs(hitParticlesModeOptions) do
                    if selected then VisualsElements.HitParticlesMode.callback(option) break end
                end
                VisualsElements.ParticlePhysics.callback(VisualsElements.ParticlePhysics.element:GetValue())
                VisualsElements.HitParticlesCount.callback(VisualsElements.HitParticlesCount.element:GetValue())
                VisualsElements.HitParticlesLifetime.callback(VisualsElements.HitParticlesLifetime.element:GetValue())
                VisualsElements.HitParticlesMoveDistance.callback(VisualsElements.HitParticlesMoveDistance.element:GetValue())
                VisualsElements.HitVisualEnabled.callback(VisualsElements.HitVisualEnabled.element:GetState())
                VisualsElements.HitVisualAnimate.callback(VisualsElements.HitVisualAnimate.element:GetState())
                VisualsElements.HitVisualFadeTime.callback(VisualsElements.HitVisualFadeTime.element:GetValue())
                VisualsElements.HitVisualTransparency.callback(VisualsElements.HitVisualTransparency.element:GetValue())
            end
        }, 'SyncSettings')
    end

    initializeGunSilent()
end

return { Init = Init }
