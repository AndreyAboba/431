local Players = game:GetService("Players")
local Workspace = game:GetService("Workspace")
local RunService = game:GetService("RunService")
local UserInputService = game:GetService("UserInputService")
local TweenService = game:GetService("TweenService")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local CoreGui = game:GetService("CoreGui")

local GunSilent = {
    Settings = {
        BasePrediction = { Value = 0.1, Default = 0.1 },
        Enabled = { Value = false, Default = false },
        RangePlus = { Value = 200, Default = 200 },
        HitPart = { Value = "Head", Default = "Head" },
        UseFOV = { Value = true, Default = true },
        FOV = { Value = 120, Default = 120 },
        ShowCircle = { Value = true, Default = true },
        CircleMethod = { Value = "Center", Default = "Center", Options = {"Center", "Cursor"} },
        PredictVisual = { Value = true, Default = true },
        PredictVisualMode = { Value = "Sphere", Default = "Sphere", Options = {"Sphere", "Hitboxes", "FullHitbox"} },
        PredictVisualMaterial = { Value = "Neon", Default = "Neon", Options = {"Neon", "ForceField"} },
        TrajectoryBeam = { Value = true, Default = true },
        TrajectoryBeamColor = { Value = Color3.fromRGB(147, 112, 219), Default = Color3.fromRGB(147, 112, 219) },
        TrajectoryBeamWidth = { Value = 0.15, Default = 0.15 },
        BulletTrailsEnabled = { Value = false, Default = false },
        BulletTrailsFadeTime = { Value = 1, Default = 1 },
        BulletTrailsColor = { Value = Color3.fromRGB(147, 112, 219), Default = Color3.fromRGB(147, 112, 219) },
        HitChance = { Value = 100, Default = 100 },
        SortMethod = { Value = "Mouse&Distance", Default = "Mouse&Distance" },
        ShotgunSupport = { Value = false, Default = false },
        GenBullet = { Value = 4, Default = 4 },
        HitParticlesEnabled = { Value = false, Default = false },
        HitParticlesMode = { Value = "Orbs", Default = "Orbs", Options = {"Orbs", "Sparks"} },
        HitParticlesCount = { Value = 30, Default = 30 },
        HitParticlesLifetime = { Value = 0.8, Default = 0.8 },
        HitParticlesMoveDistance = { Value = 12, Default = 12 },
        HitParticlesColor = { Value = Color3.fromRGB(255, 215, 0), Default = Color3.fromRGB(255, 215, 0) },
        UseGradient = { Value = false, Default = false },
        ParticlePhysics = { Value = "None", Default = "None", Options = {"None", "Fall", "Rise"} },
        HitVisualEnabled = { Value = false, Default = false },
        HitVisualFadeTime = { Value = 2, Default = 2 },
        HitVisualColor = { Value = Color3.fromRGB(147, 112, 219), Default = Color3.fromRGB(147, 112, 219) },
        HitVisualTransparency = { Value = 0.5, Default = 0.5 },
        HitVisualMaterial = { Value = "Neon", Default = "Neon", Options = {"Neon", "ForceField"} },
        HitNotifyEnabled = { Value = true, Default = true },
        HitNotifyDuration = { Value = 2, Default = 2 }
    },
    State = {
        LastEventId = 0,
        LastTool = nil,
        PredictVisualPart = nil,
        TrajectoryBeam = nil,
        TrajectoryAttachment0 = nil,
        TrajectoryAttachment1 = nil,
        FovCircle = nil,
        V_U_4 = nil,
        Connection = nil,
        OldFireServer = nil,
        LastVisualUpdateTime = 0,
        LastTargetPosition = {},
        LocalCharacter = nil,
        LocalRoot = nil,
        LastTargetPos = nil,
        LastPredictionPos = nil,
        LastTargetUpdate = 0,
        TargetUpdateInterval = 0.1,
        LastFriendsList = nil,
        BulletTrails = {},
        TrailFadeConnections = {},
        CurrentToolRangeApplied = nil,
        BaseRangeCache = {},
        LastHitTarget = nil,
        LastHitPosition = nil,
        LastShotTime = 0,
        PendingHits = {},
        ActiveHitboxes = {},
        Notification = nil
    }
}

local function safeCreateInstance(className, properties)
    local instance = Instance.new(className)
    if properties then
        for prop, value in pairs(properties) do
            instance[prop] = value
        end
    end
    return instance
end

local function createOrb(position)
    local orb = safeCreateInstance("Part", {
        Shape = Enum.PartType.Ball,
        Size = Vector3.new(0.5, 0.5, 0.5),
        Position = position,
        Anchored = true,
        CanCollide = false,
        Transparency = 0.3,
        Material = Enum.Material.Neon,
        Color = Color3.fromRGB(0, 255, 255),
        Parent = Workspace
    })
    return orb
end

local function createHitboxPart(part, color, material, fadeTime, transparency)
    if not part then return end
    local hitbox = safeCreateInstance("Part", {
        Size = part.Size * 1.1,
        CFrame = part.CFrame,
        Anchored = true,
        CanCollide = false,
        Transparency = transparency,
        Material = Enum.Material[material],
        Color = color,
        Parent = Workspace
    })
    hitbox.Name = part.Name

    local fadeTweenInfo = TweenInfo.new(fadeTime, Enum.EasingStyle.Exponential, Enum.EasingDirection.In)
    local fadeTween = TweenService:Create(hitbox, fadeTweenInfo, { Transparency = 1 })
    fadeTween:Play()
    fadeTween.Completed:Connect(function()
        hitbox:Destroy()
        GunSilent.State.ActiveHitboxes[hitbox] = nil
    end)

    GunSilent.State.ActiveHitboxes[hitbox] = true
    if #GunSilent.State.ActiveHitboxes > 50 then
        for oldHitbox, _ in pairs(GunSilent.State.ActiveHitboxes) do
            if oldHitbox ~= hitbox then
                oldHitbox:Destroy()
                GunSilent.State.ActiveHitboxes[oldHitbox] = nil
                break
            end
        end
    end

    return hitbox
end

local function createPredictHitbox(position, size, color, material)
    local hitbox = safeCreateInstance("Part", {
        Size = size,
        CFrame = CFrame.new(position),
        Anchored = true,
        CanCollide = false,
        Transparency = 0.3,
        Material = Enum.Material[material],
        Color = color,
        Parent = Workspace
    })
    return hitbox
end

local function createPredictVisual(position, mode, material, targetChar)
    if mode == "Sphere" then
        return createOrb(position)
    elseif mode == "Hitboxes" then
        local parts = {
            {"Head", Vector3.new(1, 1, 1)},
            {"UpperTorso", Vector3.new(1, 1, 1)},
            {"LowerTorso", Vector3.new(1, 1, 1)},
            {"LeftUpperArm", Vector3.new(0.5, 1, 0.5)},
            {"RightUpperArm", Vector3.new(0.5, 1, 0.5)},
            {"LeftLowerArm", Vector3.new(0.5, 1, 0.5)},
            {"RightLowerArm", Vector3.new(0.5, 1, 0.5)},
            {"LeftUpperLeg", Vector3.new(0.5, 1, 0.5)},
            {"RightUpperLeg", Vector3.new(0.5, 1, 0.5)},
            {"LeftLowerLeg", Vector3.new(0.5, 1, 0.5)},
            {"RightLowerLeg", Vector3.new(0.5, 1, 0.5)}
        }
        local hitboxes = {}
        for _, partData in ipairs(parts) do
            local hitbox = createPredictHitbox(position, partData[2], Color3.fromRGB(0, 255, 255), material)
            table.insert(hitboxes, hitbox)
        end
        return hitboxes
    elseif mode == "FullHitbox" then
        if not targetChar then return nil end
        local parts = {
            "Head", "LeftFoot", "LeftHand", "LeftLowerArm", "LeftLowerLeg", "LeftUpperArm", "LeftUpperLeg",
            "LowerTorso", "RightFoot", "RightHand", "RightLowerArm", "RightLowerLeg", "RightUpperArm", "RightUpperLeg", "UpperTorso"
        }
        local hitboxes = {}
        for _, partName in ipairs(parts) do
            local part = targetChar:FindFirstChild(partName)
            if part then
                local hitbox = createPredictHitbox(position + (part.Position - targetChar.HumanoidRootPart.Position), part.Size * 1.1, Color3.fromRGB(0, 255, 255), material)
                table.insert(hitboxes, hitbox)
            end
        end
        return hitboxes
    end
    return nil
end

local function createSpark(position)
    local spark = safeCreateInstance("Part", {
        Shape = Enum.PartType.Cylinder,
        Size = Vector3.new(0.3, 2.5, 0.3),
        Position = position,
        Anchored = true,
        CanCollide = false,
        Transparency = 0,
        Material = Enum.Material.Neon,
        Parent = Workspace
    })
    return spark
end

local function interpolateColor(color1, color2, t)
    return Color3.new(
        color1.R + (color2.R - color1.R) * t,
        color1.G + (color2.G - color1.G) * t,
        color1.B + (color2.B - color1.B) * t
    )
end

local function animateParticle(particle, isSpark)
    local theta = math.random() * 2 * math.pi
    local phi = math.random() * math.pi - math.pi / 2
    local distance = GunSilent.Settings.HitParticlesMoveDistance.Value * math.random(0.8, 1.2)
    local moveX = math.cos(theta) * math.cos(phi) * distance
    local moveY = math.sin(phi) * distance
    local moveZ = math.sin(theta) * math.cos(phi) * distance
    local targetPosition = particle.Position + Vector3.new(moveX, moveY, moveZ)
    local physicsMode = GunSilent.Settings.ParticlePhysics.Value
    local yOffset = physicsMode == "Fall" and -5 * GunSilent.Settings.HitParticlesLifetime.Value or physicsMode == "Rise" and 5 * GunSilent.Settings.HitParticlesLifetime.Value or 0

    if isSpark then
        particle.CFrame = CFrame.new(particle.Position, targetPosition) * CFrame.Angles(0, math.random() * 2 * math.pi, 0)
    end

    local tweenInfo = TweenInfo.new(GunSilent.Settings.HitParticlesLifetime.Value, Enum.EasingStyle.Quad, Enum.EasingDirection.Out)
    local targetProperties = {
        Position = targetPosition + Vector3.new(0, yOffset, 0),
        Transparency = 1,
        Size = isSpark and Vector3.new(0.2, 1.8, 0.2) or Vector3.new(0.4, 0.4, 0.4)
    }

    if GunSilent.Settings.HitParticlesMode.Value == "Orbs" then
        local pulseTween = TweenService:Create(particle, TweenInfo.new(0.2, Enum.EasingStyle.Sine, Enum.EasingDirection.InOut, -1, true), { Size = Vector3.new(0.8, 0.8, 0.8) })
        pulseTween:Play()
    end

    local color = GunSilent.Settings.HitParticlesColor.Value
    if GunSilent.Settings.UseGradient.Value and GunSilent.Core and GunSilent.Core.GradientColors then
        local gradientColor1 = GunSilent.Core.GradientColors.Color1.Value
        local gradientColor2 = GunSilent.Core.GradientColors.Color2.Value
        color = gradientColor1
        task.spawn(function()
            local t = 0
            while t < 1 and particle and particle.Parent do
                particle.Color = interpolateColor(gradientColor1, gradientColor2, math.sin(t * math.pi))
                t = t + RunService.Heartbeat:Wait() / GunSilent.Settings.HitParticlesLifetime.Value
            end
        end)
    end
    particle.Color = color

    local tween = TweenService:Create(particle, tweenInfo, targetProperties)
    tween:Play()

    task.delay(GunSilent.Settings.HitParticlesLifetime.Value, function()
        if particle then particle:Destroy() end
    end)
end

local function spawnHitParticles(target, hitPosition)
    if not GunSilent.Settings.HitParticlesEnabled.Value or not target or not hitPosition then return end

    local hitPart = target.Character:FindFirstChild(GunSilent.Settings.HitPart.Value) or target.Character:FindFirstChild("HumanoidRootPart")
    if not hitPart then return end

    local position = hitPosition or hitPart.Position
    local mode = GunSilent.Settings.HitParticlesMode.Value
    local particleCount = math.min(GunSilent.Settings.HitParticlesCount.Value, 30)

    for i = 1, particleCount do
        local particle = mode == "Orbs" and createOrb(position) or createSpark(position)
        if particle then animateParticle(particle, mode == "Sparks") end
    end
end

local function spawnHitVisual(target, hitPosition)
    if not GunSilent.Settings.HitVisualEnabled.Value or not target or not hitPosition then return end

    local character = target.Character
    if not character then return end

    local parts = {
        "Head", "LeftFoot", "LeftHand", "LeftLowerArm", "LeftLowerLeg", "LeftUpperArm", "LeftUpperLeg",
        "LowerTorso", "RightFoot", "RightHand", "RightLowerArm", "RightLowerLeg", "RightUpperArm", "RightUpperLeg", "UpperTorso"
    }

    for _, partName in ipairs(parts) do
        local part = character:FindFirstChild(partName)
        if part then
            createHitboxPart(part, GunSilent.Settings.HitVisualColor.Value, GunSilent.Settings.HitVisualMaterial.Value, GunSilent.Settings.HitVisualFadeTime.Value, GunSilent.Settings.HitVisualTransparency.Value)
        end
    end
end

local function showNotification(message, color)
    if not GunSilent.Settings.HitNotifyEnabled.Value then return end
    if GunSilent.State.Notification then GunSilent.State.Notification:Destroy() end

    local screenGui = Instance.new("ScreenGui", CoreGui)
    screenGui.ResetOnSpawn = false
    screenGui.Name = "GunSilentNotify"

    local frame = Instance.new("Frame", screenGui)
    frame.Size = UDim2.new(0, 200, 0, 50)
    frame.Position = UDim2.new(0.5, -100, 0.9, -60)
    frame.BackgroundColor3 = Color3.fromRGB(30, 30, 30)
    frame.BorderSizePixel = 0
    frame.BackgroundTransparency = 1

    local uicorner = Instance.new("UICorner", frame)
    uicorner.CornerRadius = UDim.new(0, 8)

    local border = Instance.new("UIStroke", frame)
    border.Color = color
    border.Thickness = 2
    border.Transparency = 1

    local shadow = Instance.new("ImageLabel", frame)
    shadow.Size = UDim2.new(1, 20, 1, 20)
    shadow.Position = UDim2.new(0, -10, 0, -10)
    shadow.BackgroundTransparency = 1
    shadow.Image = "rbxassetid://1316045217"
    shadow.ImageColor3 = Color3.fromRGB(0, 0, 0)
    shadow.ImageTransparency = 0.8
    shadow.ScaleType = Enum.ScaleType.Slice
    shadow.SliceCenter = Rect.new(10, 10, 10, 10)

    local textLabel = Instance.new("TextLabel", frame)
    textLabel.Size = UDim2.new(1, 0, 1, 0)
    textLabel.BackgroundTransparency = 1
    textLabel.Text = message
    textLabel.TextColor3 = Color3.fromRGB(255, 255, 255)
    textLabel.Font = Enum.Font.SourceSansBold
    textLabel.TextSize = 20
    textLabel.TextTransparency = 1

    GunSilent.State.Notification = frame

    local appearTweenInfo = TweenInfo.new(0.3, Enum.EasingStyle.Quad, Enum.EasingDirection.Out)
    local appearTween = TweenService:Create(frame, appearTweenInfo, { BackgroundTransparency = 0 })
    local textAppearTween = TweenService:Create(textLabel, appearTweenInfo, { TextTransparency = 0 })
    local borderAppearTween = TweenService:Create(border, appearTweenInfo, { Transparency = 0 })
    appearTween:Play()
    textAppearTween:Play()
    borderAppearTween:Play()

    task.delay(GunSilent.Settings.HitNotifyDuration.Value, function()
        if frame and frame.Parent then
            local fadeTweenInfo = TweenInfo.new(0.3, Enum.EasingStyle.Quad, Enum.EasingDirection.In)
            local fadeTween = TweenService:Create(frame, fadeTweenInfo, { BackgroundTransparency = 1 })
            local textFadeTween = TweenService:Create(textLabel, fadeTweenInfo, { TextTransparency = 1 })
            local borderFadeTween = TweenService:Create(border, fadeTweenInfo, { Transparency = 1 })
            fadeTween:Play()
            textFadeTween:Play()
            borderFadeTween:Play()
            fadeTween.Completed:Connect(function()
                frame:Destroy()
                GunSilent.State.Notification = nil
            end)
        end
    end)
end

local function isGunTool(tool)
    local items = ReplicatedStorage:FindFirstChild("Items")
    if not items then return false end
    local gunFolder = items:FindFirstChild("gun")
    if not gunFolder then return false end
    return gunFolder:FindFirstChild(tool.Name) ~= nil
end

local function isShotgun(tool)
    if not tool then return false end
    local ammoType = tool:GetAttribute("AmmoType")
    return ammoType and ammoType:lower() == "shotgun"
end

local function getEquippedGunTool()
    local localPlayer = Players.LocalPlayer
    if not localPlayer or not localPlayer.Character then return nil end

    local playerName = localPlayer.Name
    local playerFolder = Workspace:FindFirstChild(playerName)
    if playerFolder then
        for _, child in pairs(playerFolder:GetChildren()) do
            if child.ClassName == "Tool" and isGunTool(child) then return child end
        end
    end

    local character = localPlayer.Character
    for _, child in pairs(character:GetChildren()) do
        if child.ClassName == "Tool" and isGunTool(child) then return child end
    end
    return nil
end

local function getGunRange(tool)
    if not tool or not isGunTool(tool) then return GunSilent.Settings.RangePlus.Value end

    local equippedTool = getEquippedGunTool()
    if tool ~= equippedTool then return GunSilent.Settings.RangePlus.Value end

    local encryptedRangeAttr = GunSilent.Core.GetEncryptedAttributeName and GunSilent.Core.GetEncryptedAttributeName("range") or "range"
    local toolId = tostring(tool)
    local baseRange = GunSilent.State.BaseRangeCache[toolId] or tool:GetAttribute(encryptedRangeAttr) or 0
    GunSilent.State.BaseRangeCache[toolId] = baseRange

    local totalRange = baseRange + GunSilent.Settings.RangePlus.Value
    if GunSilent.State.CurrentToolRangeApplied ~= tool then
        tool:SetAttribute(encryptedRangeAttr, totalRange)
        GunSilent.State.CurrentToolRangeApplied = tool
    end

    return totalRange
end

local function updateFovCircle()
    if not GunSilent.Settings.ShowCircle.Value then
        if GunSilent.State.FovCircle then GunSilent.State.FovCircle.Visible = false end
        return
    end

    local camera = Workspace.CurrentCamera
    if not camera then return end

    local fovCircle = GunSilent.State.FovCircle
    if not fovCircle then
        fovCircle = Drawing.new("Circle")
        fovCircle.Thickness = 2
        fovCircle.NumSides = 100
        fovCircle.Color = Color3.fromRGB(255, 255, 255)
        fovCircle.Visible = true
        fovCircle.Filled = false
        GunSilent.State.FovCircle = fovCircle
    end

    local newRadius = math.tan(math.rad(GunSilent.Settings.FOV.Value) / 2) * camera.ViewportSize.X / 2
    local circlePos = GunSilent.Settings.CircleMethod.Value == "Cursor" and UserInputService:GetMouseLocation() or camera.ViewportSize / 2

    fovCircle.Radius = newRadius
    fovCircle.Position = circlePos
    fovCircle.Visible = true
end

local function isInFov(targetPos, camera)
    if not GunSilent.Settings.UseFOV.Value then return true end
    local screenPos, onScreen = camera:WorldToViewportPoint(targetPos)
    if not onScreen then return false end
    local referencePos = GunSilent.Settings.CircleMethod.Value == "Cursor" and UserInputService:GetMouseLocation() or camera.ViewportSize / 2
    local distanceFromReference = (Vector2.new(screenPos.X, screenPos.Y) - referencePos).Magnitude
    return distanceFromReference <= math.tan(math.rad(GunSilent.Settings.FOV.Value) / 2) * camera.ViewportSize.X / 2
end

local function getNearestPlayerGun(gunRange)
    local currentTime = tick()
    if currentTime - GunSilent.State.LastTargetUpdate < GunSilent.State.TargetUpdateInterval then
        local target = GunSilent.Core.GunSilentTarget.CurrentTarget
        if target and target.Character and target.Character.Humanoid and target.Character.Humanoid.Health > 0 then return target end
    end
    GunSilent.State.LastTargetUpdate = currentTime

    local friendsList = GunSilent.Core.Services.FriendsList or {}
    local friendsHash = {}
    for k in pairs(friendsList) do friendsHash[k:lower()] = true end

    local localRoot = GunSilent.State.LocalRoot
    if not localRoot then return nil end
    local rootPos = localRoot.Position
    local camera = Workspace.CurrentCamera
    if not camera then return nil end

    local nearestPlayer, shortestDistance, closestToCursor, bestScore = nil, gunRange, math.huge, math.huge
    local sortMethod = GunSilent.Settings.SortMethod.Value

    for _, player in pairs(Players:GetPlayers()) do
        if player ~= Players.LocalPlayer and not friendsHash[player.Name:lower()] then
            local targetChar = player.Character
            if targetChar then
                local targetRoot = targetChar:FindFirstChild("HumanoidRootPart")
                local targetHumanoid = targetChar:FindFirstChild("Humanoid")
                if targetRoot and targetHumanoid and targetHumanoid.Health > 0 then
                    local distance = (rootPos - targetRoot.Position).Magnitude
                    local inFov = isInFov(targetRoot.Position, camera)
                    if inFov then
                        if sortMethod == "Mouse&Distance" then
                            local screenPos = camera:WorldToViewportPoint(targetRoot.Position)
                            local cursorDistance = (Vector2.new(screenPos.X, screenPos.Y) - UserInputService:GetMouseLocation()).Magnitude
                            local score = (cursorDistance / camera.ViewportSize.X) * 0.7 + (distance / (GunSilent.Settings.RangePlus.Value + 50)) * 0.3
                            if score < bestScore then
                                bestScore = score
                                nearestPlayer = player
                            end
                        elseif sortMethod == "Distance" and distance < shortestDistance then
                            shortestDistance = distance
                            nearestPlayer = player
                        elseif sortMethod == "Mouse" then
                            local screenPos = camera:WorldToViewportPoint(targetRoot.Position)
                            local cursorDistance = (Vector2.new(screenPos.X, screenPos.Y) - UserInputService:GetMouseLocation()).Magnitude
                            if cursorDistance < closestToCursor then
                                closestToCursor = cursorDistance
                                nearestPlayer = player
                            end
                        end
                    end
                end
            end
        end
    end

    GunSilent.Core.GunSilentTarget.CurrentTarget = nearestPlayer
    GunSilent.State.LastFriendsList = friendsList
    return nearestPlayer
end

local function isInVehicle(targetChar)
    local humanoid = targetChar:FindFirstChild("Humanoid")
    if humanoid then return humanoid.SeatPart ~= nil end
    return false
end

local function predictTargetPositionGun(target)
    local localRoot = GunSilent.State.LocalRoot
    if not target or not target.Character or not localRoot then 
        return { position = nil, direction = nil, timeToTarget = 0, clientPosition = nil, velocity = nil } 
    end

    local targetChar = target.Character
    local myPos = localRoot.Position
    local hitPart = targetChar:FindFirstChild(GunSilent.Settings.HitPart.Value)
    if not hitPart then hitPart = targetChar:FindFirstChild("HumanoidRootPart") end
    local targetRoot = targetChar:FindFirstChild("HumanoidRootPart")
    if not hitPart or not targetRoot then 
        return { position = nil, direction = nil, timeToTarget = 0, clientPosition = nil, velocity = nil } 
    end

    local targetPos = hitPart.Position
    local targetId = target and target.UserId and tostring(target.UserId) or nil
    if not targetId then 
        return { position = nil, direction = nil, timeToTarget = 0, clientPosition = nil, velocity = nil } 
    end
    GunSilent.State.LastTargetPosition[targetId] = targetPos

    local velocity = targetRoot.Velocity
    local maxSpeedLimit = isInVehicle(targetChar) and 100 or 50
    if velocity.Magnitude > maxSpeedLimit then
        velocity = velocity.Unit * maxSpeedLimit
    end

    local ping = Players.LocalPlayer:GetAttribute("ServerPing") or 0.05
    local predictionTime = GunSilent.Settings.BasePrediction.Value + ping
    local predictedPos = targetPos + velocity * predictionTime

    return {
        position = predictedPos,
        direction = (predictedPos - myPos).Unit,
        timeToTarget = predictionTime,
        clientPosition = targetPos,
        velocity = velocity
    }
end

local function getAimCFrameGun(target)
    local localRoot = GunSilent.State.LocalRoot
    if not target or not target.Character or not localRoot then return nil end
    local prediction = predictTargetPositionGun(target)
    if not prediction.position or not prediction.direction then return nil end
    return CFrame.new(localRoot.Position, localRoot.Position + prediction.direction)
end

local function createHitDataGun(target)
    local localRoot = GunSilent.State.LocalRoot
    if not target or not target.Character or not localRoot then return nil end
    local targetChar = target.Character
    local prediction = predictTargetPositionGun(target)
    if not prediction.position or not prediction.direction then return nil end

    local hitPart = targetChar:FindFirstChild(GunSilent.Settings.HitPart.Value)
    if not hitPart then hitPart = targetChar:FindFirstChild("HumanoidRootPart") end

    local finalPosition = prediction.position
    local startPos = localRoot.Position + Vector3.new(0, 1.5, 0)

    local equippedTool = getEquippedGunTool()
    local isShotgunWeapon = GunSilent.Settings.ShotgunSupport.Value and equippedTool and isShotgun(equippedTool)
    local numBullets = isShotgunWeapon and GunSilent.Settings.GenBullet.Value or 1
    local hitData = {}

    local timestamp = tick()
    for i = 1, numBullets do
        hitData[i] = {{Normal = prediction.direction, Instance = hitPart, Position = finalPosition, Origin = startPos, Timestamp = timestamp}}
    end

    if GunSilent.Settings.BulletTrailsEnabled.Value and localRoot and finalPosition then
        local trail = safeCreateInstance("Beam", {
            FaceCamera = true,
            Width0 = 0.1,
            Width1 = 0.1,
            Transparency = NumberSequence.new(0),
            Color = ColorSequence.new(GunSilent.Settings.BulletTrailsColor.Value),
            Parent = Workspace
        })
        if trail then
            local attachment0 = safeCreateInstance("Attachment", { Parent = Workspace.Terrain })
            local attachment1 = safeCreateInstance("Attachment", { Parent = Workspace.Terrain })
            if attachment0 and attachment1 then
                attachment0.Position = startPos
                attachment1.Position = finalPosition
                trail.Attachment0 = attachment0
                trail.Attachment1 = attachment1

                table.insert(GunSilent.State.BulletTrails, { beam = trail, attachment0 = attachment0, attachment1 = attachment1 })

                local fadeTime = GunSilent.Settings.BulletTrailsFadeTime.Value
                local startTime = tick()
                local fadeConnection
                fadeConnection = RunService.RenderStepped:Connect(function()
                    local elapsed = tick() - startTime
                    local t = math.clamp(elapsed / fadeTime, 0, 1)
                    if trail and trail.Parent then trail.Transparency = NumberSequence.new(t) end
                    if t >= 1 then
                        if trail then trail:Destroy() end
                        if attachment0 then attachment0:Destroy() end
                        if attachment1 then attachment1:Destroy() end
                        if fadeConnection then fadeConnection:Disconnect() end
                        for i, v in ipairs(GunSilent.State.BulletTrails) do
                            if v.beam == trail then table.remove(GunSilent.State.BulletTrails, i) break end
                        end
                        for i, conn in ipairs(GunSilent.State.TrailFadeConnections) do
                            if conn == fadeConnection then table.remove(GunSilent.State.TrailFadeConnections, i) break end
                        end
                    end
                end)
                table.insert(GunSilent.State.TrailFadeConnections, fadeConnection)

                if #GunSilent.State.BulletTrails > 20 then
                    local oldTrail = table.remove(GunSilent.State.BulletTrails, 1)
                    if oldTrail.beam then oldTrail.beam:Destroy() end
                    if oldTrail.attachment0 then oldTrail.attachment0:Destroy() end
                    if oldTrail.attachment1 then oldTrail.attachment1:Destroy() end
                end
            end
        end
    end

    GunSilent.State.LastHitTarget = target
    GunSilent.State.LastHitPosition = finalPosition
    GunSilent.State.LastShotTime = tick()

    return hitData
end

local function createTrajectoryBeam(startPos, endPos)
    if GunSilent.State.TrajectoryBeam then
        GunSilent.State.TrajectoryBeam:Destroy()
        GunSilent.State.TrajectoryBeam = nil
    end
    if GunSilent.State.TrajectoryAttachment0 then
        GunSilent.State.TrajectoryAttachment0:Destroy()
        GunSilent.State.TrajectoryAttachment0 = nil
    end
    if GunSilent.State.TrajectoryAttachment1 then
        GunSilent.State.TrajectoryAttachment1:Destroy()
        GunSilent.State.TrajectoryAttachment1 = nil
    end

    local trajectoryBeam = safeCreateInstance("Beam", {
        FaceCamera = true,
        Width0 = GunSilent.Settings.TrajectoryBeamWidth.Value,
        Width1 = GunSilent.Settings.TrajectoryBeamWidth.Value,
        Transparency = NumberSequence.new(0.4),
        Color = ColorSequence.new(GunSilent.Settings.TrajectoryBeamColor.Value),
        Parent = Workspace
    })
    if not trajectoryBeam then return end

    local attachment0 = safeCreateInstance("Attachment", { Parent = Workspace.Terrain })
    local attachment1 = safeCreateInstance("Attachment", { Parent = Workspace.Terrain })
    if not attachment0 or not attachment1 then
        trajectoryBeam:Destroy()
        if attachment0 then attachment0:Destroy() end
        if attachment1 then attachment1:Destroy() end
        return
    end

    attachment0.Position = startPos
    attachment1.Position = endPos
    trajectoryBeam.Attachment0 = attachment0
    trajectoryBeam.Attachment1 = attachment1

    GunSilent.State.TrajectoryBeam = trajectoryBeam
    GunSilent.State.TrajectoryAttachment0 = attachment0
    GunSilent.State.TrajectoryAttachment1 = attachment1
end

local function updateVisualsGun(target)
    local currentTime = tick()
    if currentTime - GunSilent.State.LastVisualUpdateTime < 0.05 then return end
    GunSilent.State.LastVisualUpdateTime = currentTime

    local localRoot = GunSilent.State.LocalRoot
    if not GunSilent.Settings.Enabled.Value or not localRoot then
        if GunSilent.State.PredictVisualPart then
            if type(GunSilent.State.PredictVisualPart) == "table" then
                for _, part in ipairs(GunSilent.State.PredictVisualPart) do
                    if part then part:Destroy() end
                end
            else
                GunSilent.State.PredictVisualPart:Destroy()
            end
            GunSilent.State.PredictVisualPart = nil
        end
        if GunSilent.State.TrajectoryBeam then GunSilent.State.TrajectoryBeam.Enabled = false end
        return
    end

    local prediction = target and predictTargetPositionGun(target)
    local targetPos = prediction and prediction.clientPosition
    local predictionPos = prediction and prediction.position

    if not target or not target.Character or not predictionPos or not prediction.direction then
        if GunSilent.State.PredictVisualPart then
            if type(GunSilent.State.PredictVisualPart) == "table" then
                for _, part in ipairs(GunSilent.State.PredictVisualPart) do
                    if part then part:Destroy() end
                end
            else
                GunSilent.State.PredictVisualPart:Destroy()
            end
            GunSilent.State.PredictVisualPart = nil
        end
        if GunSilent.State.TrajectoryBeam then GunSilent.State.TrajectoryBeam.Enabled = false end
        return
    end

    if GunSilent.State.LastTargetPos and (targetPos - GunSilent.State.LastTargetPos).Magnitude < 1 then return end

    local targetChar = target.Character
    local hitPart = targetChar:FindFirstChild(GunSilent.Settings.HitPart.Value)
    if not hitPart then hitPart = targetChar:FindFirstChild("HumanoidRootPart") end

    GunSilent.State.LastTargetPos, GunSilent.State.LastPredictionPos = targetPos, predictionPos
    local startPos = localRoot.Position + Vector3.new(0, 1.5, 0)

    if GunSilent.Settings.PredictVisual.Value then
        if GunSilent.State.PredictVisualPart then
            if type(GunSilent.State.PredictVisualPart) == "table" then
                for _, part in ipairs(GunSilent.State.PredictVisualPart) do
                    if part then part:Destroy() end
                end
            else
                GunSilent.State.PredictVisualPart:Destroy()
            end
            GunSilent.State.PredictVisualPart = nil
        end

        local visual = createPredictVisual(predictionPos, GunSilent.Settings.PredictVisualMode.Value, GunSilent.Settings.PredictVisualMaterial.Value, targetChar)
        if visual then
            GunSilent.State.PredictVisualPart = type(visual) == "table" and visual or {visual}
        end
    elseif GunSilent.State.PredictVisualPart then
        if type(GunSilent.State.PredictVisualPart) == "table" then
            for _, part in ipairs(GunSilent.State.PredictVisualPart) do
                if part then part:Destroy() end
            end
        else
            GunSilent.State.PredictVisualPart:Destroy()
        end
        GunSilent.State.PredictVisualPart = nil
    end

    if GunSilent.Settings.TrajectoryBeam.Value and GunSilent.Settings.PredictVisual.Value then
        if not GunSilent.State.TrajectoryBeam or not GunSilent.State.TrajectoryAttachment0 or not GunSilent.State.TrajectoryAttachment1 then
            createTrajectoryBeam(startPos, predictionPos)
        else
            GunSilent.State.TrajectoryAttachment0.Position = startPos
            GunSilent.State.TrajectoryAttachment1.Position = predictionPos
            GunSilent.State.TrajectoryBeam.Enabled = true
        end
    else
        if GunSilent.State.TrajectoryBeam then GunSilent.State.TrajectoryBeam.Enabled = false end
    end
end

local function initializeGunSilent()
    if GunSilent.State.Connection then GunSilent.State.Connection:Disconnect() end
    if not GunSilent.State.V_U_4 then
        for _, obj in pairs(getgc(true)) do
            if type(obj) == "table" and not getmetatable(obj) and obj.event and obj.func then
                GunSilent.State.V_U_4 = obj
                break
            end
        end
    end

    local remoteEvent = ReplicatedStorage:FindFirstChild("Remotes") and ReplicatedStorage.Remotes:FindFirstChild("Send")
    if not remoteEvent or not remoteEvent:IsA("RemoteEvent") then return end

    remoteEvent.OnClientEvent:Connect(function(...)
        local args = {...}
        if args[1] == "hit_confirmed" then
            local headshot = args[2]
            local kill = args[3]
            local pendingHit = GunSilent.State.PendingHits[GunSilent.State.LastEventId] or
                             { target = GunSilent.Core.GunSilentTarget.CurrentTarget, position = GunSilent.State.LastHitPosition }
            if pendingHit.target and (headshot or kill) then
                spawnHitParticles(pendingHit.target, pendingHit.position)
                spawnHitVisual(pendingHit.target, pendingHit.position)
                showNotification("HIT!", Color3.fromRGB(0, 255, 0))
            else
                showNotification("MISS!", Color3.fromRGB(255, 0, 0))
            end
            if GunSilent.State.PendingHits[GunSilent.State.LastEventId] then
                GunSilent.State.PendingHits[GunSilent.State.LastEventId] = nil
            end
        end
    end)

    if not GunSilent.State.OldFireServer then
        GunSilent.State.OldFireServer = hookfunction(remoteEvent.FireServer, function(self, ...)
            local args = {...}
            local modifiedArgs = args
            local nearestPlayer = nil
            if GunSilent.Settings.Enabled.Value and #args >= 2 and typeof(args[1]) == "number" and math.random(100) <= GunSilent.Settings.HitChance.Value then
                GunSilent.State.LastEventId = args[1]
                local equippedTool = getEquippedGunTool()
                if equippedTool and args[2] == "shoot_gun" then
                    local gunRange = getGunRange(equippedTool)
                    nearestPlayer = getNearestPlayerGun(gunRange)
                    if nearestPlayer then
                        local aimCFrame = getAimCFrameGun(nearestPlayer)
                        local hitData = createHitDataGun(nearestPlayer)
                        if aimCFrame and hitData then
                            modifiedArgs = {args[1], args[2], equippedTool, aimCFrame, hitData}
                            GunSilent.State.PendingHits[args[1]] = {
                                target = nearestPlayer,
                                position = GunSilent.State.LastHitPosition
                            }
                        end
                    end
                end
            end

            local success, result = pcall(function()
                return GunSilent.State.OldFireServer(self, unpack(modifiedArgs))
            end)

            if not success then
                if GunSilent.State.PendingHits[GunSilent.State.LastEventId] then
                    GunSilent.State.PendingHits[GunSilent.State.LastEventId] = nil
                end
            end

            return success and result or nil
        end)
    end

    GunSilent.State.Connection = RunService.RenderStepped:Connect(function(deltaTime)
        if not GunSilent.Settings.Enabled.Value then
            if GunSilent.State.FovCircle then GunSilent.State.FovCircle.Visible = false end
            GunSilent.Core.GunSilentTarget.CurrentTarget = nil
            updateVisualsGun(nil)
            return
        end

        local character = GunSilent.State.LocalCharacter
        if character and character:FindFirstChild("HumanoidRootPart") then
            GunSilent.State.LocalRoot = character.HumanoidRootPart
        else
            GunSilent.State.LocalRoot = nil
        end

        local currentTool = getEquippedGunTool()
        if currentTool ~= GunSilent.State.LastTool then
            GunSilent.State.LastTool = currentTool
        end

        updateFovCircle()
        if not currentTool then
            GunSilent.Core.GunSilentTarget.CurrentTarget = nil
            updateVisualsGun(nil)
            return
        end

        local gunRange = getGunRange(currentTool)
        local nearestPlayer = getNearestPlayerGun(gunRange)
        updateVisualsGun(nearestPlayer)
    end)
end

local function Init(UI, Core, notify)
    GunSilent.Core = Core
    GunSilent.notify = notify

    local LocalPlayer = Core.PlayerData.LocalPlayer
    if LocalPlayer then
        LocalPlayer.CharacterAdded:Connect(function(character)
            character:WaitForChild("HumanoidRootPart")
            GunSilent.State.LocalCharacter = character
            GunSilent.State.LocalRoot = character.HumanoidRootPart
            GunSilent.State.CurrentToolRangeApplied = nil
            GunSilent.State.BaseRangeCache = {}
            if GunSilent.State.PredictVisualPart then
                if type(GunSilent.State.PredictVisualPart) == "table" then
                    for _, part in ipairs(GunSilent.State.PredictVisualPart) do
                        if part then part:Destroy() end
                    end
                else
                    GunSilent.State.PredictVisualPart:Destroy()
                end
                GunSilent.State.PredictVisualPart = nil
            end
            if GunSilent.State.TrajectoryBeam then
                GunSilent.State.TrajectoryBeam:Destroy()
                GunSilent.State.TrajectoryBeam = nil
            end
            if GunSilent.State.TrajectoryAttachment0 then
                GunSilent.State.TrajectoryAttachment0:Destroy()
                GunSilent.State.TrajectoryAttachment0 = nil
            end
            if GunSilent.State.TrajectoryAttachment1 then
                GunSilent.State.TrajectoryAttachment1:Destroy()
                GunSilent.State.TrajectoryAttachment1 = nil
            end
        end)
        if LocalPlayer.Character then
            GunSilent.State.LocalCharacter = LocalPlayer.Character
            GunSilent.State.LocalRoot = LocalPlayer.Character:FindFirstChild("HumanoidRootPart")
        end

        local humanoid = LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("Humanoid")
        if humanoid then
            humanoid.Died:Connect(function()
                if GunSilent.State.PredictVisualPart then
                    if type(GunSilent.State.PredictVisualPart) == "table" then
                        for _, part in ipairs(GunSilent.State.PredictVisualPart) do
                            if part then part:Destroy() end
                        end
                    else
                        GunSilent.State.PredictVisualPart:Destroy()
                    end
                    GunSilent.State.PredictVisualPart = nil
                end
                if GunSilent.State.TrajectoryBeam then
                    GunSilent.State.TrajectoryBeam:Destroy()
                    GunSilent.State.TrajectoryBeam = nil
                end
                if GunSilent.State.TrajectoryAttachment0 then
                    GunSilent.State.TrajectoryAttachment0:Destroy()
                    GunSilent.State.TrajectoryAttachment0 = nil
                end
                if GunSilent.State.TrajectoryAttachment1 then
                    GunSilent.State.TrajectoryAttachment1:Destroy()
                    GunSilent.State.TrajectoryAttachment1 = nil
                end
            end)
        end
        LocalPlayer.CharacterAdded:Connect(function(character)
            local newHumanoid = character:WaitForChild("Humanoid")
            newHumanoid.Died:Connect(function()
                if GunSilent.State.PredictVisualPart then
                    if type(GunSilent.State.PredictVisualPart) == "table" then
                        for _, part in ipairs(GunSilent.State.PredictVisualPart) do
                            if part then part:Destroy() end
                        end
                    else
                        GunSilent.State.PredictVisualPart:Destroy()
                    end
                    GunSilent.State.PredictVisualPart = nil
                end
                if GunSilent.State.TrajectoryBeam then
                    GunSilent.State.TrajectoryBeam:Destroy()
                    GunSilent.State.TrajectoryBeam = nil
                end
                if GunSilent.State.TrajectoryAttachment0 then
                    GunSilent.State.TrajectoryAttachment0:Destroy()
                    GunSilent.State.TrajectoryAttachment0 = nil
                end
                if GunSilent.State.TrajectoryAttachment1 then
                    GunSilent.State.TrajectoryAttachment1:Destroy()
                    GunSilent.State.TrajectoryAttachment1 = nil
                end
            end)
        end)
    end

    local CombatElements = {}
    local VisualsElements = {}

    if UI.Tabs.Combat then
        local combatSection = UI.Tabs.Combat:Section({ Side = "Right", Name = "GunSilent" })
        if combatSection then
            combatSection:Header({ Name = "GunSilent" })
            CombatElements.GSEnabled = {
                element = combatSection:Toggle({
                    Name = "Enabled",
                    Default = GunSilent.Settings.Enabled.Value,
                    Callback = function(value)
                        GunSilent.Settings.Enabled.Value = value
                        initializeGunSilent()
                    end
                }, 'GSEnabled'),
                callback = function(value)
                    GunSilent.Settings.Enabled.Value = value
                    initializeGunSilent()
                end
            }
            CombatElements.RangePlus = {
                element = combatSection:Slider({
                    Name = "Range Plus",
                    Minimum = 0,
                    Maximum = 300,
                    Default = GunSilent.Settings.RangePlus.Value,
                    Precision = 0,
                    Callback = function(value)
                        GunSilent.Settings.RangePlus.Value = value
                        local currentTool = getEquippedGunTool()
                        if currentTool then
                            GunSilent.State.CurrentToolRangeApplied = nil
                            getGunRange(currentTool)
                        end
                    end
                }, 'RangePlus'),
                callback = function(value)
                    GunSilent.Settings.RangePlus.Value = value
                    local currentTool = getEquippedGunTool()
                    if currentTool then
                        GunSilent.State.CurrentToolRangeApplied = nil
                        getGunRange(currentTool)
                    end
                end
            }
            CombatElements.HitPart = {
                element = combatSection:Dropdown({
                    Name = "Hit Part",
                    Default = GunSilent.Settings.HitPart.Value,
                    Options = {"Head", "UpperTorso", "HumanoidRootPart"},
                    Callback = function(value) GunSilent.Settings.HitPart.Value = value end
                }, 'HitPart'),
                callback = function(value) GunSilent.Settings.HitPart.Value = value end
            }
            CombatElements.ShotgunSupport = {
                element = combatSection:Toggle({
                    Name = "Shotgun Support",
                    Default = GunSilent.Settings.ShotgunSupport.Value,
                    Callback = function(value) GunSilent.Settings.ShotgunSupport.Value = value end
                }, 'ShotgunSupport'),
                callback = function(value) GunSilent.Settings.ShotgunSupport.Value = value end
            }
            CombatElements.GenerateBullets = {
                element = combatSection:Slider({
                    Name = "Generate Bullets",
                    Default = GunSilent.Settings.GenBullet.Value,
                    Minimum = 1,
                    Maximum = 10,
                    Precision = 0,
                    Callback = function(value) GunSilent.Settings.GenBullet.Value = value end
                }, 'GenerateBullets'),
                callback = function(value) GunSilent.Settings.GenBullet.Value = value end
            }
            CombatElements.SortMethod = {
                element = combatSection:Dropdown({
                    Name = "Sort Method",
                    Default = GunSilent.Settings.SortMethod.Value,
                    Options = {"Mouse", "Distance", "Mouse&Distance"},
                    Callback = function(value) GunSilent.Settings.SortMethod.Value = value end
                }, 'SortMethod'),
                callback = function(value) GunSilent.Settings.SortMethod.Value = value end
            }
            CombatElements.UseFOV = {
                element = combatSection:Toggle({
                    Name = "Use FOV",
                    Default = GunSilent.Settings.UseFOV.Value,
                    Callback = function(value) GunSilent.Settings.UseFOV.Value = value end
                }, 'UseFOV'),
                callback = function(value) GunSilent.Settings.UseFOV.Value = value end
            }
            CombatElements.FOV = {
                element = combatSection:Slider({
                    Name = "FOV",
                    Default = GunSilent.Settings.FOV.Value,
                    Minimum = 15,
                    Maximum = 120,
                    Precision = 0,
                    Callback = function(value) GunSilent.Settings.FOV.Value = value end
                }, 'FOV'),
                callback = function(value) GunSilent.Settings.FOV.Value = value end
            }
            CombatElements.ShowCircle = {
                element = combatSection:Toggle({
                    Name = "Show Circle",
                    Default = GunSilent.Settings.ShowCircle.Value,
                    Callback = function(value) GunSilent.Settings.ShowCircle.Value = value end
                }, 'ShowCircle'),
                callback = function(value) GunSilent.Settings.ShowCircle.Value = value end
            }
            CombatElements.CircleMethod = {
                element = combatSection:Dropdown({
                    Name = "Circle Method",
                    Default = GunSilent.Settings.CircleMethod.Value,
                    Options = GunSilent.Settings.CircleMethod.Options,
                    Callback = function(value) GunSilent.Settings.CircleMethod.Value = value end
                }, 'CircleMethod'),
                callback = function(value) GunSilent.Settings.CircleMethod.Value = value end
            }
            combatSection:Header({ Name = "Visuals" })
            CombatElements.PredictVisual = {
                element = combatSection:Toggle({
                    Name = "Predict Visual",
                    Default = GunSilent.Settings.PredictVisual.Value,
                    Callback = function(value) GunSilent.Settings.PredictVisual.Value = value end
                }, 'PredictVisual'),
                callback = function(value) GunSilent.Settings.PredictVisual.Value = value end
            }
            CombatElements.TrajectoryBeam = {
                element = combatSection:Toggle({
                    Name = "Trajectory Beam",
                    Default = GunSilent.Settings.TrajectoryBeam.Value,
                    Callback = function(value)
                        GunSilent.Settings.TrajectoryBeam.Value = value
                        if not value and GunSilent.State.TrajectoryBeam then
                            GunSilent.State.TrajectoryBeam:Destroy()
                            GunSilent.State.TrajectoryBeam = nil
                            if GunSilent.State.TrajectoryAttachment0 then
                                GunSilent.State.TrajectoryAttachment0:Destroy()
                                GunSilent.State.TrajectoryAttachment0 = nil
                            end
                            if GunSilent.State.TrajectoryAttachment1 then
                                GunSilent.State.TrajectoryAttachment1:Destroy()
                                GunSilent.State.TrajectoryAttachment1 = nil
                            end
                        end
                    end
                }, 'TrajectoryBeam'),
                callback = function(value)
                    GunSilent.Settings.TrajectoryBeam.Value = value
                    if not value and GunSilent.State.TrajectoryBeam then
                        GunSilent.State.TrajectoryBeam:Destroy()
                        GunSilent.State.TrajectoryBeam = nil
                        if GunSilent.State.TrajectoryAttachment0 then
                            GunSilent.State.TrajectoryAttachment0:Destroy()
                            GunSilent.State.TrajectoryAttachment0 = nil
                        end
                        if GunSilent.State.TrajectoryAttachment1 then
                            GunSilent.State.TrajectoryAttachment1:Destroy()
                            GunSilent.State.TrajectoryAttachment1 = nil
                        end
                    end
                end
            }
            CombatElements.HitChance = {
                element = combatSection:Slider({
                    Name = "Hit Chance",
                    Default = GunSilent.Settings.HitChance.Value,
                    Minimum = 0,
                    Maximum = 100,
                    Precision = 0,
                    Callback = function(value) GunSilent.Settings.HitChance.Value = value end
                }, 'HitChance'),
                callback = function(value) GunSilent.Settings.HitChance.Value = value end
            }
            combatSection:Header({ Name = "Prediction Settings" })
            CombatElements.BasePrediction = {
                element = combatSection:Slider({
                    Name = "Base Prediction",
                    Minimum = 0.05,
                    Maximum = 0.5,
                    Default = GunSilent.Settings.BasePrediction.Value,
                    Precision = 2,
                    Callback = function(value) GunSilent.Settings.BasePrediction.Value = value end
                }, 'BasePrediction'),
                callback = function(value) GunSilent.Settings.BasePrediction.Value = value end
            }
        end
    end

    if UI.Tabs.Visuals then
        local bulletTrailsSection = UI.Tabs.Visuals:Section({ Side = "Right", Name = "Bullet Trails" })
        if bulletTrailsSection then
            bulletTrailsSection:Header({ Name = "Bullet Trails" })
            VisualsElements.BulletTrailsEnabled = {
                element = bulletTrailsSection:Toggle({
                    Name = "Enabled",
                    Default = GunSilent.Settings.BulletTrailsEnabled.Value,
                    Callback = function(value)
                        GunSilent.Settings.BulletTrailsEnabled.Value = value
                        if not value then
                            for _, trailData in ipairs(GunSilent.State.BulletTrails) do
                                if trailData.beam then trailData.beam:Destroy() end
                                if trailData.attachment0 then trailData.attachment0:Destroy() end
                                if trailData.attachment1 then trailData.attachment1:Destroy() end
                            end
                            GunSilent.State.BulletTrails = {}
                            for _, conn in ipairs(GunSilent.State.TrailFadeConnections) do
                                if conn then conn:Disconnect() end
                            end
                            GunSilent.State.TrailFadeConnections = {}
                        end
                    end
                }, 'BulletTrailsEnabled'),
                callback = function(value)
                    GunSilent.Settings.BulletTrailsEnabled.Value = value
                    if not value then
                        for _, trailData in ipairs(GunSilent.State.BulletTrails) do
                            if trailData.beam then trailData.beam:Destroy() end
                            if trailData.attachment0 then trailData.attachment0:Destroy() end
                            if trailData.attachment1 then trailData.attachment1:Destroy() end
                        end
                        GunSilent.State.BulletTrails = {}
                        for _, conn in ipairs(GunSilent.State.TrailFadeConnections) do
                            if conn then conn:Disconnect() end
                        end
                        GunSilent.State.TrailFadeConnections = {}
                    end
                end
            }
            VisualsElements.BulletTrailsFadeTime = {
                element = bulletTrailsSection:Slider({
                    Name = "Fade Time",
                    Default = GunSilent.Settings.BulletTrailsFadeTime.Value,
                    Minimum = 0.5,
                    Maximum = 3,
                    Precision = 1,
                    Callback = function(value) GunSilent.Settings.BulletTrailsFadeTime.Value = value end
                }, 'BulletTrailsFadeTime'),
                callback = function(value) GunSilent.Settings.BulletTrailsFadeTime.Value = value end
            }
            VisualsElements.BulletTrailsColor = {
                element = bulletTrailsSection:Colorpicker({
                    Name = "Trails Color",
                    Default = GunSilent.Settings.BulletTrailsColor.Value,
                    Callback = function(value) GunSilent.Settings.BulletTrailsColor.Value = value end
                }, 'BulletTrailsColor'),
                callback = function(value) GunSilent.Settings.BulletTrailsColor.Value = value end
            }
        end

        local hitParticlesSection = UI.Tabs.Visuals:Section({ Side = "Left", Name = "Hit Particles" })
        if hitParticlesSection then
            hitParticlesSection:Header({ Name = "Hit Particles" })
            VisualsElements.HitParticlesEnabled = {
                element = hitParticlesSection:Toggle({
                    Name = "Enabled",
                    Default = GunSilent.Settings.HitParticlesEnabled.Value,
                    Callback = function(value) GunSilent.Settings.HitParticlesEnabled.Value = value end
                }, 'HitParticlesEnabled'),
                callback = function(value) GunSilent.Settings.HitParticlesEnabled.Value = value end
            }
            VisualsElements.UseGradient = {
                element = hitParticlesSection:Toggle({
                    Name = "Use Gradient",
                    Default = GunSilent.Settings.UseGradient.Value,
                    Callback = function(value) GunSilent.Settings.UseGradient.Value = value end
                }, 'UseGradient'),
                callback = function(value) GunSilent.Settings.UseGradient.Value = value end
            }
            VisualsElements.HitParticlesMode = {
                element = hitParticlesSection:Dropdown({
                    Name = "Mode",
                    Default = GunSilent.Settings.HitParticlesMode.Value,
                    Options = GunSilent.Settings.HitParticlesMode.Options,
                    Callback = function(value) GunSilent.Settings.HitParticlesMode.Value = value end
                }, 'HitParticlesMode'),
                callback = function(value) GunSilent.Settings.HitParticlesMode.Value = value end
            }
            VisualsElements.ParticlePhysics = {
                element = hitParticlesSection:Dropdown({
                    Name = "Particle Physics",
                    Default = GunSilent.Settings.ParticlePhysics.Value,
                    Options = GunSilent.Settings.ParticlePhysics.Options,
                    Callback = function(value) GunSilent.Settings.ParticlePhysics.Value = value end
                }, 'ParticlePhysics'),
                callback = function(value) GunSilent.Settings.ParticlePhysics.Value = value end
            }
            VisualsElements.HitParticlesCount = {
                element = hitParticlesSection:Slider({
                    Name = "Particle Count",
                    Default = GunSilent.Settings.HitParticlesCount.Value,
                    Minimum = 5,
                    Maximum = 50,
                    Precision = 0,
                    Callback = function(value) GunSilent.Settings.HitParticlesCount.Value = value end
                }, 'HitParticlesCount'),
                callback = function(value) GunSilent.Settings.HitParticlesCount.Value = value end
            }
            VisualsElements.HitParticlesLifetime = {
                element = hitParticlesSection:Slider({
                    Name = "Lifetime",
                    Default = GunSilent.Settings.HitParticlesLifetime.Value,
                    Minimum = 0.3,
                    Maximum = 2,
                    Precision = 1,
                    Callback = function(value) GunSilent.Settings.HitParticlesLifetime.Value = value end
                }, 'HitParticlesLifetime'),
                callback = function(value) GunSilent.Settings.HitParticlesLifetime.Value = value end
            }
            VisualsElements.HitParticlesMoveDistance = {
                element = hitParticlesSection:Slider({
                    Name = "Move Distance",
                    Default = GunSilent.Settings.HitParticlesMoveDistance.Value,
                    Minimum = 2,
                    Maximum = 20,
                    Precision = 0,
                    Callback = function(value) GunSilent.Settings.HitParticlesMoveDistance.Value = value end
                }, 'HitParticlesMoveDistance'),
                callback = function(value) GunSilent.Settings.HitParticlesMoveDistance.Value = value end
            }
            VisualsElements.HitParticlesColor = {
                element = hitParticlesSection:Colorpicker({
                    Name = "Particles Color",
                    Default = GunSilent.Settings.HitParticlesColor.Value,
                    Callback = function(value) GunSilent.Settings.HitParticlesColor.Value = value end
                }, 'HitParticlesColor'),
                callback = function(value) GunSilent.Settings.HitParticlesColor.Value = value end
            }
        end

        local hitVisualSection = UI.Tabs.Visuals:Section({ Side = "Left", Name = "Hit Visual" })
        if hitVisualSection then
            hitVisualSection:Header({ Name = "Hit Visual" })
            VisualsElements.HitVisualEnabled = {
                element = hitVisualSection:Toggle({
                    Name = "Enabled",
                    Default = GunSilent.Settings.HitVisualEnabled.Value,
                    Callback = function(value) GunSilent.Settings.HitVisualEnabled.Value = value end
                }, 'HitVisualEnabled'),
                callback = function(value) GunSilent.Settings.HitVisualEnabled.Value = value end
            }
            VisualsElements.HitVisualFadeTime = {
                element = hitVisualSection:Slider({
                    Name = "Fade Time",
                    Default = GunSilent.Settings.HitVisualFadeTime.Value,
                    Minimum = 0.5,
                    Maximum = 3,
                    Precision = 1,
                    Callback = function(value) GunSilent.Settings.HitVisualFadeTime.Value = value end
                }, 'HitVisualFadeTime'),
                callback = function(value) GunSilent.Settings.HitVisualFadeTime.Value = value end
            }
            VisualsElements.HitVisualTransparency = {
                element = hitVisualSection:Slider({
                    Name = "Transparency",
                    Default = GunSilent.Settings.HitVisualTransparency.Value,
                    Minimum = 0,
                    Maximum = 1,
                    Precision = 2,
                    Callback = function(value) GunSilent.Settings.HitVisualTransparency.Value = value end
                }, 'HitVisualTransparency'),
                callback = function(value) GunSilent.Settings.HitVisualTransparency.Value = value end
            }
            VisualsElements.HitVisualColor = {
                element = hitVisualSection:Colorpicker({
                    Name = "Visual Color",
                    Default = GunSilent.Settings.HitVisualColor.Value,
                    Callback = function(value) GunSilent.Settings.HitVisualColor.Value = value end
                }, 'HitVisualColor'),
                callback = function(value) GunSilent.Settings.HitVisualColor.Value = value end
            }
            VisualsElements.HitVisualMaterial = {
                element = hitVisualSection:Dropdown({
                    Name = "Material",
                    Default = GunSilent.Settings.HitVisualMaterial.Value,
                    Options = GunSilent.Settings.HitVisualMaterial.Options,
                    Callback = function(value) GunSilent.Settings.HitVisualMaterial.Value = value end
                }, 'HitVisualMaterial'),
                callback = function(value) GunSilent.Settings.HitVisualMaterial.Value = value end
            }
        end

        local hitNotifySection = UI.Tabs.Visuals:Section({ Side = "Right", Name = "Hit Notify" })
        if hitNotifySection then
            hitNotifySection:Header({ Name = "Hit Notify" })
            VisualsElements.HitNotifyEnabled = {
                element = hitNotifySection:Toggle({
                    Name = "Enabled",
                    Default = GunSilent.Settings.HitNotifyEnabled.Value,
                    Callback = function(value) GunSilent.Settings.HitNotifyEnabled.Value = value end
                }, 'HitNotifyEnabled'),
                callback = function(value) GunSilent.Settings.HitNotifyEnabled.Value = value end
            }
            VisualsElements.HitNotifyDuration = {
                element = hitNotifySection:Slider({
                    Name = "Duration",
                    Default = GunSilent.Settings.HitNotifyDuration.Value,
                    Minimum = 1,
                    Maximum = 5,
                    Precision = 1,
                    Callback = function(value) GunSilent.Settings.HitNotifyDuration.Value = value end
                }, 'HitNotifyDuration'),
                callback = function(value) GunSilent.Settings.HitNotifyDuration.Value = value end
            }
        end

        local predictVisualsSection = UI.Tabs.Visuals:Section({ Side = "Right", Name = "PredictVisuals" })
        if predictVisualsSection then
            predictVisualsSection:Header({ Name = "Predict Visual" })
            VisualsElements.PredictVisualMode = {
                element = predictVisualsSection:Dropdown({
                    Name = "Mode",
                    Default = GunSilent.Settings.PredictVisualMode.Value,
                    Options = GunSilent.Settings.PredictVisualMode.Options,
                    Callback = function(value) GunSilent.Settings.PredictVisualMode.Value = value end
                }, 'PredictVisualMode'),
                callback = function(value) GunSilent.Settings.PredictVisualMode.Value = value end
            }
            VisualsElements.PredictVisualMaterial = {
                element = predictVisualsSection:Dropdown({
                    Name = "Material",
                    Default = GunSilent.Settings.PredictVisualMaterial.Value,
                    Options = GunSilent.Settings.PredictVisualMaterial.Options,
                    Callback = function(value) GunSilent.Settings.PredictVisualMaterial.Value = value end
                }, 'PredictVisualMaterial'),
                callback = function(value) GunSilent.Settings.PredictVisualMaterial.Value = value end
            }
            predictVisualsSection:Header({ Name = "Trajectory Beam" })
            VisualsElements.TrajectoryBeamColor = {
                element = predictVisualsSection:Colorpicker({
                    Name = "Beam Color",
                    Default = GunSilent.Settings.TrajectoryBeamColor.Value,
                    Callback = function(value) GunSilent.Settings.TrajectoryBeamColor.Value = value end
                }, 'TrajectoryBeamColor'),
                callback = function(value) GunSilent.Settings.TrajectoryBeamColor.Value = value end
            }
            VisualsElements.TrajectoryBeamWidth = {
                element = predictVisualsSection:Slider({
                    Name = "Beam Width",
                    Default = GunSilent.Settings.TrajectoryBeamWidth.Value,
                    Minimum = 0.1,
                    Maximum = 0.5,
                    Precision = 2,
                    Callback = function(value) GunSilent.Settings.TrajectoryBeamWidth.Value = value end
                }, 'TrajectoryBeamWidth'),
                callback = function(value) GunSilent.Settings.TrajectoryBeamWidth.Value = value end
            }
        end
    end

    local gunconfigSection
    if UI.Tabs.Config then
        gunconfigSection = UI.Tabs.Config:Section({ Name = "GunSilent Sync", Side = "Right" })
        gunconfigSection:Header({ Name = "GunSilent Settings Sync" })
        gunconfigSection:Button({
            Name = "Sync Settings",
            Callback = function()
                CombatElements.GSEnabled.callback(CombatElements.GSEnabled.element:GetState())
                CombatElements.RangePlus.callback(CombatElements.RangePlus.element:GetValue())
                local hitPartOptions = CombatElements.HitPart.element:GetOptions()
                for option, selected in pairs(hitPartOptions) do
                    if selected then CombatElements.HitPart.callback(option) break end
                end
                CombatElements.ShotgunSupport.callback(CombatElements.ShotgunSupport.element:GetState())
                CombatElements.GenerateBullets.callback(CombatElements.GenerateBullets.element:GetValue())
                local sortMethodOptions = CombatElements.SortMethod.element:GetOptions()
                for option, selected in pairs(sortMethodOptions) do
                    if selected then CombatElements.SortMethod.callback(option) break end
                end
                CombatElements.UseFOV.callback(CombatElements.UseFOV.element:GetState())
                CombatElements.FOV.callback(CombatElements.FOV.element:GetValue())
                CombatElements.ShowCircle.callback(CombatElements.ShowCircle.element:GetState())
                local circleMethodOptions = CombatElements.CircleMethod.element:GetOptions()
                for option, selected in pairs(circleMethodOptions) do
                    if selected then CombatElements.CircleMethod.callback(option) break end
                end
                CombatElements.PredictVisual.callback(CombatElements.PredictVisual.element:GetState())
                CombatElements.TrajectoryBeam.callback(CombatElements.TrajectoryBeam.element:GetState())
                CombatElements.HitChance.callback(CombatElements.HitChance.element:GetValue())
                CombatElements.BasePrediction.callback(CombatElements.BasePrediction.element:GetValue())
                VisualsElements.BulletTrailsEnabled.callback(VisualsElements.BulletTrailsEnabled.element:GetState())
                VisualsElements.BulletTrailsFadeTime.callback(VisualsElements.BulletTrailsFadeTime.element:GetValue())
                VisualsElements.HitParticlesEnabled.callback(VisualsElements.HitParticlesEnabled.element:GetState())
                VisualsElements.UseGradient.callback(VisualsElements.UseGradient.element:GetState())
                local hitParticlesModeOptions = VisualsElements.HitParticlesMode.element:GetOptions()
                for option, selected in pairs(hitParticlesModeOptions) do
                    if selected then VisualsElements.HitParticlesMode.callback(option) break end
                end
                VisualsElements.ParticlePhysics.callback(VisualsElements.ParticlePhysics.element:GetValue())
                VisualsElements.HitParticlesCount.callback(VisualsElements.HitParticlesCount.element:GetValue())
                VisualsElements.HitParticlesLifetime.callback(VisualsElements.HitParticlesLifetime.element:GetValue())
                VisualsElements.HitParticlesMoveDistance.callback(VisualsElements.HitParticlesMoveDistance.element:GetValue())
                VisualsElements.HitVisualEnabled.callback(VisualsElements.HitVisualEnabled.element:GetState())
                VisualsElements.HitVisualFadeTime.callback(VisualsElements.HitVisualFadeTime.element:GetValue())
                VisualsElements.HitVisualTransparency.callback(VisualsElements.HitVisualTransparency.element:GetValue())
                local hitVisualMaterialOptions = VisualsElements.HitVisualMaterial.element:GetOptions()
                for option, selected in pairs(hitVisualMaterialOptions) do
                    if selected then VisualsElements.HitVisualMaterial.callback(option) break end
                end
                VisualsElements.HitNotifyEnabled.callback(VisualsElements.HitNotifyEnabled.element:GetState())
                VisualsElements.HitNotifyDuration.callback(VisualsElements.HitNotifyDuration.element:GetValue())
                local predictVisualModeOptions = VisualsElements.PredictVisualMode.element:GetOptions()
                for option, selected in pairs(predictVisualModeOptions) do
                    if selected then VisualsElements.PredictVisualMode.callback(option) break end
                end
                local predictVisualMaterialOptions = VisualsElements.PredictVisualMaterial.element:GetOptions()
                for option, selected in pairs(predictVisualMaterialOptions) do
                    if selected then VisualsElements.PredictVisualMaterial.callback(option) break end
                end
                VisualsElements.TrajectoryBeamColor.callback(VisualsElements.TrajectoryBeamColor.element:GetValue())
                VisualsElements.TrajectoryBeamWidth.callback(VisualsElements.TrajectoryBeamWidth.element:GetValue())
            end
        }, 'SyncSettings')
    end

    initializeGunSilent()
end

return { Init = Init }
