-- Main services are now sourced from the loader (Core)
local GunSilent = {
    Settings = {
        BasePrediction = { Value = 0.1, Default = 0.1 },
        Enabled = { Value = false, Default = false },
        RangePlus = { Value = 200, Default = 200 },
        HitPart = { Value = "Head", Default = "Head" },
        UseFOV = { Value = true, Default = true },
        FOV = { Value = 120, Default = 120 },
        ShowCircle = { Value = true, Default = true },
        CircleMethod = { Value = "Center", Default = "Center", Options = {"Center", "Cursor"} },
        PredictVisual = { Value = true, Default = true },
        PredictVisualMode = { Value = "Sphere", Default = "Sphere", Options = {"Sphere", "Hitbox", "FullHitbox"} },
        PredictVisualMaterial = { Value = "Neon", Default = "Neon", Options = {"Neon", "ForceField", "Glass", "Metal", "Plastic", "SmoothPlastic"} },
        BulletTrailsEnabled = { Value = false, Default = false },
        BulletTrailsFadeTime = { Value = 1, Default = 1 },
        BulletTrailsColor = { Value = Color3.fromRGB(147, 112, 219), Default = Color3.fromRGB(147, 112, 219) },
        HitChance = { Value = 100, Default = 100 },
        SortMethod = { Value = "Mouse&Distance", Default = "Mouse&Distance" },
        ShotgunSupport = { Value = false, Default = false },
        GenBullet = { Value = 4, Default = 4 },
        HitParticlesEnabled = { Value = false, Default = false },
        HitParticlesMode = { Value = "Orbs", Default = "Orbs", Options = {"Orbs", "Sparks"} },
        HitParticlesCount = { Value = 30, Default = 30 },
        HitParticlesLifetime = { Value = 0.8, Default = 0.8 },
        HitParticlesMoveDistance = { Value = 12, Default = 12 },
        HitParticlesColor = { Value = Color3.fromRGB(255, 215, 0), Default = Color3.fromRGB(255, 215, 0) },
        UseGradient = { Value = false, Default = false },
        ParticlePhysics = { Value = "None", Default = "None", Options = {"None", "Fall", "Rise"} },
        HitVisualEnabled = { Value = false, Default = false },
        HitVisualFadeTime = { Value = 2, Default = 2 },
        HitVisualColor = { Value = Color3.fromRGB(147, 112, 219), Default = Color3.fromRGB(147, 112, 219) },
        HitVisualTransparency = { Value = 0.5, Default = 0.5 },
        HitVisualMaterial = { Value = "Neon", Default = "Neon", Options = {"Neon", "ForceField", "Glass", "Metal", "Plastic", "SmoothPlastic"} },
        HitNotifyEnabled = { Value = true, Default = true },
        HitNotifyDuration = { Value = 2, Default = 2 },
        HitNotifyPositionX = { Value = 0.5, Default = 0.5 },
        HitNotifyPositionY = { Value = 0.9, Default = 0.9 },
        TrajectoryBeamEnabled = { Value = true, Default = true },
        HitboxColor = { Value = Color3.fromRGB(0, 255, 255), Default = Color3.fromRGB(0, 255, 255) },
        HitboxTransparency = { Value = 0.3, Default = 0.3 }
    },
    State = {
        LastEventId = 0,
        LastTool = nil,
        PredictVisualPart = nil,
        FovCircle = nil,
        V_U_4 = nil,
        Connection = nil,
        OldFireServer = nil,
        LastVisualUpdateTime = 0,
        LastTargetPosition = {},
        LocalCharacter = nil,
        LocalRoot = nil,
        LastTargetPos = nil,
        LastPredictionPos = nil,
        LastTargetUpdate = 0,
        TargetUpdateInterval = 0.1,
        LastFriendsList = nil,
        BulletTrails = {},
        TrailFadeConnections = {},
        CurrentToolRangeApplied = nil,
        BaseRangeCache = {},
        LastHitTarget = nil,
        LastHitPosition = nil,
        LastShotTime = 0,
        PendingHits = {},
        ActiveHitboxes = {},
        Notification = nil,
        TrajectoryBeam = nil,
        TrajectoryBeamAttachments = {}
    }
}

local function safeCreateInstance(className, properties)
    local instance = Instance.new(className)
    if properties then
        for prop, value in pairs(properties) do
            instance[prop] = value
        end
    end
    return instance
end

local function createOrb(position)
    local orb = safeCreateInstance("Part", {
        Shape = Enum.PartType.Ball,
        Size = Vector3.new(0.5, 0.5, 0.5),
        Position = position,
        Anchored = true,
        CanCollide = false,
        Transparency = 0.3,
        Material = Enum.Material.Neon,
        Color = GunSilent.Settings.HitboxColor.Value,
        Parent = Core.Services.Workspace
    })
    return orb
end

local function createHitboxPart(part, color, material, fadeTime, transparency)
    if not part then return end
    local hitbox = safeCreateInstance("Part", {
        Size = part.Size,
        CFrame = part.CFrame,
        Anchored = true,
        CanCollide = false,
        Transparency = transparency,
        Material = Enum.Material[material],
        Color = color,
        Parent = Core.Services.Workspace
    })
    hitbox.Name = part.Name

    local fadeTweenInfo = TweenInfo.new(fadeTime, Enum.EasingStyle.Exponential, Enum.EasingDirection.In)
    local fadeTween = Core.Services.TweenService:Create(hitbox, fadeTweenInfo, { Transparency = 1 })
    fadeTween:Play()
    fadeTween.Completed:Connect(function()
        hitbox:Destroy()
        GunSilent.State.ActiveHitboxes[hitbox] = nil
    end)

    GunSilent.State.ActiveHitboxes[hitbox] = true
    if #GunSilent.State.ActiveHitboxes > 50 then
        for oldHitbox, _ in pairs(GunSilent.State.ActiveHitboxes) do
            if oldHitbox ~= hitbox then
                oldHitbox:Destroy()
                GunSilent.State.ActiveHitboxes[oldHitbox] = nil
                break
            end
        end
    end

    return hitbox
end

local function createPredictHitbox(position, size, color, material, transparency)
    local hitbox = safeCreateInstance("Part", {
        Size = size,
        CFrame = CFrame.new(position),
        Anchored = true,
        CanCollide = false,
        Transparency = transparency,
        Material = Enum.Material[material],
        Color = color,
        Parent = Core.Services.Workspace
    })
    return hitbox
end

local function createPredictVisual(position, mode, material, targetChar, hitboxColor, hitboxTransparency)
    if mode == "Sphere" then
        return createOrb(position)
    elseif mode == "Hitbox" then
        local parts = {
            {"Head", Vector3.new(1, 1, 1)},
            {"UpperTorso", Vector3.new(1, 1, 1)},
            {"LowerTorso", Vector3.new(1, 1, 1)},
            {"LeftUpperArm", Vector3.new(0.5, 1, 0.5)},
            {"RightUpperArm", Vector3.new(0.5, 1, 0.5)},
            {"LeftLowerArm", Vector3.new(0.5, 1, 0.5)},
            {"RightLowerArm", Vector3.new(0.5, 1, 0.5)},
            {"LeftUpperLeg", Vector3.new(0.5, 1, 0.5)},
            {"RightUpperLeg", Vector3.new(0.5, 1, 0.5)},
            {"LeftLowerLeg", Vector3.new(0.5, 1, 0.5)},
            {"RightLowerLeg", Vector3.new(0.5, 1, 0.5)}
        }
        local hitboxes = {}
        for _, partData in ipairs(parts) do
            local hitbox = createPredictHitbox(position, partData[2], hitboxColor, material, hitboxTransparency)
            table.insert(hitboxes, hitbox)
        end
        return hitboxes
    elseif mode == "FullHitbox" then
        if not targetChar or not targetChar.Parent then return nil end
        local targetRoot = targetChar:FindFirstChild("HumanoidRootPart")
        if not targetRoot then return nil end

        local hitboxes = {}
        local rootPos = targetRoot.Position
        local positionOffset = position - rootPos + Vector3.new(0, 2, 0)

        for _, part in ipairs(targetChar:GetChildren()) do
            if part:IsA("BasePart") and part.Name ~= "HumanoidRootPart" then
                local relativePos = part.Position - rootPos
                local newPos = positionOffset + relativePos
                local hitbox = createPredictHitbox(newPos, part.Size * 0.95, hitboxColor, material, hitboxTransparency)
                table.insert(hitboxes, hitbox)
            end
        end
        return hitboxes
    end
    return nil
end

local function createSpark(position)
    local spark = safeCreateInstance("Part", {
        Shape = Enum.PartType.Cylinder,
        Size = Vector3.new(0.3, 2.5, 0.3),
        Position = position,
        Anchored = true,
        CanCollide = false,
        Transparency = 0,
        Material = Enum.Material.Neon,
        Parent = Core.Services.Workspace
    })
    return spark
end

local function interpolateColor(color1, color2, t)
    return Color3.new(
        color1.R + (color2.R - color1.R) * t,
        color1.G + (color2.G - color1.G) * t,
        color1.B + (color2.B - color1.B) * t
    )
end

local function animateParticle(particle, isSpark)
    local theta = math.random() * 2 * math.pi
    local phi = math.random() * math.pi - math.pi / 2
    local distance = GunSilent.Settings.HitParticlesMoveDistance.Value * math.random(0.8, 1.2)
    local moveX = math.cos(theta) * math.cos(phi) * distance
    local moveY = math.sin(phi) * distance
    local moveZ = math.sin(theta) * math.cos(phi) * distance
    local targetPosition = particle.Position + Vector3.new(moveX, moveY, moveZ)
    local physicsMode = GunSilent.Settings.ParticlePhysics.Value
    local yOffset = physicsMode == "Fall" and -5 * GunSilent.Settings.HitParticlesLifetime.Value or physicsMode == "Rise" and 5 * GunSilent.Settings.HitParticlesLifetime.Value or 0

    if isSpark then
        particle.CFrame = CFrame.new(particle.Position, targetPosition) * CFrame.Angles(0, math.random() * 2 * math.pi, 0)
    end

    local tweenInfo = TweenInfo.new(GunSilent.Settings.HitParticlesLifetime.Value, Enum.EasingStyle.Quad, Enum.EasingDirection.Out)
    local targetProperties = {
        Position = targetPosition + Vector3.new(0, yOffset, 0),
        Transparency = 1,
        Size = isSpark and Vector3.new(0.2, 1.8, 0.2) or Vector3.new(0.4, 0.4, 0.4)
    }

    if GunSilent.Settings.HitParticlesMode.Value == "Orbs" then
        local pulseTween = Core.Services.TweenService:Create(particle, TweenInfo.new(0.2, Enum.EasingStyle.Sine, Enum.EasingDirection.InOut, -1, true), { Size = Vector3.new(0.8, 0.8, 0.8) })
        pulseTween:Play()
    end

    local color = GunSilent.Settings.HitParticlesColor.Value
    if GunSilent.Settings.UseGradient.Value and Core.GradientColors then
        local gradientColor1 = Core.GradientColors.Color1.Value
        local gradientColor2 = Core.GradientColors.Color2.Value
        color = gradientColor1
        task.spawn(function()
            local t = 0
            while t < 1 and particle and particle.Parent do
                particle.Color = interpolateColor(gradientColor1, gradientColor2, math.sin(t * math.pi))
                t = t + Core.Services.RunService.Heartbeat:Wait() / GunSilent.Settings.HitParticlesLifetime.Value
            end
        end)
    end
    particle.Color = color

    local tween = Core.Services.TweenService:Create(particle, tweenInfo, targetProperties)
    tween:Play()

    task.delay(GunSilent.Settings.HitParticlesLifetime.Value, function()
        if particle then particle:Destroy() end
    end)
end

local function spawnHitParticles(target, hitPosition)
    if not GunSilent.Settings.HitParticlesEnabled.Value or not target or not hitPosition or not target.Character then return end

    local hitPart = target.Character:FindFirstChild(GunSilent.Settings.HitPart.Value) or target.Character:FindFirstChild("HumanoidRootPart")
    if not hitPart then return end

    local position = hitPosition or hitPart.Position
    local mode = GunSilent.Settings.HitParticlesMode.Value
    local particleCount = math.min(GunSilent.Settings.HitParticlesCount.Value, 30)

    for i = 1, particleCount do
        local particle = mode == "Orbs" and createOrb(position) or createSpark(position)
        if particle then animateParticle(particle, mode == "Sparks") end
    end
end

local function spawnHitVisual(target, hitPosition)
    if not GunSilent.Settings.HitVisualEnabled.Value or not target or not hitPosition or not target.Character then return end

    for _, part in ipairs(target.Character:GetChildren()) do
        if part:IsA("BasePart") and part.Name ~= "HumanoidRootPart" then
            createHitboxPart(part, GunSilent.Settings.HitVisualColor.Value, GunSilent.Settings.HitVisualMaterial.Value, GunSilent.Settings.HitVisualFadeTime.Value, GunSilent.Settings.HitVisualTransparency.Value)
        end
    end
end

local function showNotification(message)
    if not GunSilent.Settings.HitNotifyEnabled.Value then return end
    if GunSilent.State.Notification then GunSilent.State.Notification:Destroy() end

    local screenGui = Instance.new("ScreenGui", Core.Services.CoreGuiService)
    screenGui.ResetOnSpawn = false
    screenGui.Name = "GunSilentNotify"

    local frame = Instance.new("Frame", screenGui)
    frame.Size = UDim2.new(0, 200, 0, 50)
    frame.Position = UDim2.new(GunSilent.Settings.HitNotifyPositionX.Value, -100, GunSilent.Settings.HitNotifyPositionY.Value, -60)
    frame.BackgroundTransparency = 1
    frame.BorderSizePixel = 0
    frame.Visible = false

    local iconFrame = Instance.new("Frame", frame)
    iconFrame.Size = UDim2.new(0, 40, 0, 40)
    iconFrame.Position = UDim2.new(0, 5, 0, 5)
    iconFrame.BackgroundColor3 = Color3.fromRGB(20, 30, 50)
    iconFrame.BackgroundTransparency = 0.3
    iconFrame.BorderSizePixel = 0

    local iconCorner = Instance.new("UICorner", iconFrame)
    iconCorner.CornerRadius = UDim.new(0.5, 0)

    local icon = Instance.new("ImageLabel", iconFrame)
    icon.Size = UDim2.new(0, 30, 0, 30)
    icon.Position = UDim2.new(0, 5, 0, 5)
    icon.BackgroundTransparency = 1
    icon.Image = "rbxassetid://5578470911"
    icon.ImageColor3 = Color3.fromRGB(0, 255, 0)

    local textFrame = Instance.new("Frame", frame)
    textFrame.Size = UDim2.new(0, 145, 0, 40)
    textFrame.Position = UDim2.new(0, 50, 0, 5)
    textFrame.BackgroundColor3 = Color3.fromRGB(20, 30, 50)
    textFrame.BackgroundTransparency = 0.3
    textFrame.BorderSizePixel = 0

    local textCorner = Instance.new("UICorner", textFrame)
    textCorner.CornerRadius = UDim.new(0.5, 0)

    local textLabel = Instance.new("TextLabel", textFrame)
    textLabel.Size = UDim2.new(1, 0, 1, 0)
    textLabel.BackgroundTransparency = 1
    textLabel.Text = message
    textLabel.TextColor3 = Color3.fromRGB(240, 240, 240)
    textLabel.Font = Enum.Font.GothamBold
    textLabel.TextSize = 16
    textLabel.TextXAlignment = Enum.TextXAlignment.Right
    textLabel.TextTransparency = 1

    GunSilent.State.Notification = frame

    frame.Visible = true
    local tweenInfo = TweenInfo.new(0.5, Enum.EasingStyle.Quad, Enum.EasingDirection.Out)
    local appearTween = Core.Services.TweenService:Create(frame, tweenInfo, { Size = UDim2.new(0, 200 VerseGroup0, 50) })
    local textAppearTween = Core.Services.TweenService:Create(textLabel, tweenInfo, { TextTransparency = 0 })
    appearTween:Play()
    textAppearTween:Play()

    task.delay(GunSilent.Settings.HitNotifyDuration.Value, function()
        if frame and frame.Parent then
            local fadeTweenInfo = TweenInfo.new(0.5, Enum.EasingStyle.Quad, Enum.EasingDirection.In)
            local fadeTween = Core.Services.TweenService:Create(frame, fadeTweenInfo, { BackgroundTransparency = 1 })
            local textFadeTween = Core.Services.TweenService:Create(textLabel, fadeTweenInfo, { TextTransparency = 1 })
            fadeTween:Play()
            textFadeTween:Play()
            fadeTween.Completed:Connect(function()
                frame:Destroy()
                GunSilent.State.Notification = nil
            end)
        end
    end)
end

local function isGunTool(tool)
    local items = Core.Services.ReplicatedStorage:FindFirstChild("Items")
    if not items then return false end
    local gunFolder = items:FindFirstChild("gun")
    if not gunFolder then return false end
    return gunFolder:FindFirstChild(tool.Name) ~= nil
end

local function isShotgun(tool)
    if not tool then return false end
    local ammoType = tool:GetAttribute("AmmoType")
    return ammoType and ammoType:lower() == "shotgun"
end

local function getEquippedGunTool()
    local localPlayer = Core.PlayerData.LocalPlayer
    if not localPlayer or not localPlayer.Character then return nil end

    local playerName = localPlayer.Name
    local playerFolder = Core.Services.Workspace:FindFirstChild(playerName)
    if playerFolder then
        for _, child in pairs(playerFolder:GetChildren()) do
            if child.ClassName == "Tool" and isGunTool(child) then return child end
        end
    end

    local character = localPlayer.Character
    for _, child in pairs(character:GetChildren()) do
        if child.ClassName == "Tool" and isGunTool(child) then return child end
    end
    return nil
end

local function getGunRange(tool)
    if not tool or not isGunTool(tool) then return GunSilent.Settings.RangePlus.Value end

    local equippedTool = getEquippedGunTool()
    if tool ~= equippedTool then return GunSilent.Settings.RangePlus.Value end

    local encryptedRangeAttr = Core.GetEncryptedAttributeName and Core.GetEncryptedAttributeName("range") or "range"
    local toolId = tostring(tool)
    local baseRange = GunSilent.State.BaseRangeCache[toolId] or tool:GetAttribute(encryptedRangeAttr) or 0
    GunSilent.State.BaseRangeCache[toolId] = baseRange

    local totalRange = baseRange + GunSilent.Settings.RangePlus.Value
    if GunSilent.State.CurrentToolRangeApplied ~= tool then
        tool:SetAttribute(encryptedRangeAttr, totalRange)
        GunSilent.State.CurrentToolRangeApplied = tool
    end

    return totalRange
end

local function updateFovCircle()
    if not GunSilent.Settings.ShowCircle.Value then
        if GunSilent.State.FovCircle then GunSilent.State.FovCircle.Visible = false end
        return
    end

    local camera = Core.PlayerData.Camera
    if not camera then return end

    local fovCircle = GunSilent.State.FovCircle
    if not fovCircle then
        fovCircle = Drawing.new("Circle")
        fovCircle.Thickness = 2
        fovCircle.NumSides = 100
        fovCircle.Color = Color3.fromRGB(255, 255, 255)
        fovCircle.Visible = true
        fovCircle.Filled = false
        GunSilent.State.FovCircle = fovCircle
    end

    local newRadius = math.tan(math.rad(GunSilent.Settings.FOV.Value) / 2) * camera.ViewportSize.X / 2
    local circlePos = GunSilent.Settings.CircleMethod.Value == "Center" and camera.ViewportSize / 2 or Core.Services.UserInputService:GetMouseLocation()

    fovCircle.Radius = newRadius
    fovCircle.Position = circlePos
    fovCircle.Visible = true
end

local function isInFov(targetPos, camera)
    if not GunSilent.Settings.UseFOV.Value then return true end
    local screenPos, onScreen = camera:WorldToViewportPoint(targetPos)
    if not onScreen then return false end
    local referencePos = GunSilent.Settings.CircleMethod.Value == "Center" and camera.ViewportSize / 2 or Core.Services.UserInputService:GetMouseLocation()
    local distanceFromReference = (Vector2.new(screenPos.X, screenPos.Y) - referencePos).Magnitude
    return distanceFromReference <= math.tan(math.rad(GunSilent.Settings.FOV.Value) / 2) * camera.ViewportSize.X / 2
end

local function getNearestPlayerGun(gunRange)
    local currentTime = tick()
    if currentTime - GunSilent.State.LastTargetUpdate < GunSilent.State.TargetUpdateInterval then
        local target = GunSilent.Core.GunSilentTarget.CurrentTarget
        if target and target.Character and target.Character.Humanoid and target.Character.Humanoid.Health > 0 then return target end
    end
    GunSilent.State.LastTargetUpdate = currentTime

    local friendsList = Core.Services.FriendsList or {}
    local friendsHash = {}
    for k in pairs(friendsList) do friendsHash[k:lower()] = true end

    local localRoot = GunSilent.State.LocalRoot
    if not localRoot then return nil end
    local rootPos = localRoot.Position
    local camera = Core.PlayerData.Camera
    if not camera then return nil end

    local nearestPlayer, shortestDistance, closestToCursor, bestScore = nil, gunRange, math.huge, math.huge
    local sortMethod = GunSilent.Settings.SortMethod.Value

    for _, player in ipairs(Core.Services.Players:GetPlayers()) do
        if player ~= Core.PlayerData.LocalPlayer and not friendsHash[player.Name:lower()] then
            local targetChar = player.Character
            if targetChar then
                local targetRoot = targetChar:FindFirstChild("HumanoidRootPart")
                local targetHumanoid = targetChar:FindFirstChild("Humanoid")
                if targetRoot and targetHumanoid and targetHumanoid.Health > 0 then
                    local distance = (rootPos - targetRoot.Position).Magnitude
                    local inFov = isInFov(targetRoot.Position, camera)
                    if inFov then
                        if sortMethod == "Mouse&Distance" then
                            local screenPos = camera:WorldToViewportPoint(targetRoot.Position)
                            local cursorDistance = (Vector2.new(screenPos.X, screenPos.Y) - Core.Services.UserInputService:GetMouseLocation()).Magnitude
                            local score = (cursorDistance / camera.ViewportSize.X) * 0.7 + (distance / (GunSilent.Settings.RangePlus.Value + 50)) * 0.3
                            if score < bestScore then
                                bestScore = score
                                nearestPlayer = player
                            end
                        elseif sortMethod == "Distance" and distance < shortestDistance then
                            shortestDistance = distance
                            nearestPlayer = player
                        elseif sortMethod == "Mouse" then
                            local screenPos = camera:WorldToViewportPoint(targetRoot.Position)
                            local cursorDistance = (Vector2.new(screenPos.X, screenPos.Y) - Core.Services.UserInputService:GetMouseLocation()).Magnitude
                            if cursorDistance < closestToCursor then
                                closestToCursor = cursorDistance
                                nearestPlayer = player
                            end
                        end
                    end
                end
            end
        end
    end

    GunSilent.Core.GunSilentTarget.CurrentTarget = nearestPlayer
    GunSilent.State.LastFriendsList = friendsList
    return nearestPlayer
end

local function isInVehicle(targetChar)
    local humanoid = targetChar:FindFirstChild("Humanoid")
    if humanoid then return humanoid.SeatPart ~= nil end
    return false
end

local function predictTargetPositionGun(target)
    local localRoot = GunSilent.State.LocalRoot
    if not target or not target.Character or not localRoot then
        return { position, direction = nil, timeToTarget = 0, clientPosition = nil, velocity = nil }
    end

    local targetChar = target.Character
    local myPos = localRoot.Position
    local hitPart = targetChar:FindFirstChild(GunSilent.Settings.HitPart.Value) or targetChar:FindFirstChild("HumanoidRootPart")
    local targetRoot = targetChar:FindFirstChild("HumanoidRootPart")
    if not hitPart or not targetRoot then
        return { position = nil, direction = nil, timeToTarget = 0, clientPosition = nil, velocity = nil }
    end

    local targetPos = hitPart.Position
    local targetId = target and target.UserId and tostring(target.UserId) or nil
    if not targetId then
        return { position = nil, direction = nil, timeToTarget = 0, clientPosition = nil, velocity = nil }
    end
    GunSilent.State.LastTargetPosition[targetId] = targetPos

    local velocity = targetRoot.Velocity
    local maxSpeedLimit = isInVehicle(targetChar) and 100 or 50
    if velocity.Magnitude > maxSpeedLimit then
        velocity = velocity.Unit * maxSpeedLimit
    end

    local ping = Core.PlayerData.LocalPlayer:GetAttribute("ServerPing") or 0.05
    local predictionTime = GunSilent.Settings.BasePrediction.Value + ping
    local predictedPos = targetPos + velocity * predictionTime

    return {
        position = predictedPos,
        direction = (predictedPos - myPos).Unit,
        timeToTarget = predictionTime,
        clientPosition = targetPos,
        velocity = velocity
    }
end

local function getAimCFrameGun(target)
    local localRoot = GunSilent.State.LocalRoot
    if not target or not target.Character or not localRoot then return nil end
    local prediction = predictTargetPositionGun(target)
    if not prediction or not prediction.position or not prediction.direction then return nil end
    return CFrame.new(localRoot.Position, localRoot.Position + prediction.direction)
end

local function createHitDataGun(target)
    local localRoot = GunSilent.State.LocalRoot
    if not target or not target.Character or not localRoot then return nil end
    local targetChar = target.Character
    local prediction = predictTargetPositionGun(target)
    if not prediction or not prediction.position or not prediction.direction then return nil end

    local hitPart = targetChar:FindFirstChild(GunSilent.Settings.HitPart.Value) or targetChar:FindFirstChild("HumanoidRootPart")
    if not hitPart then return nil end

    local finalPosition = prediction.position
    local startPos = localRoot.Position + Vector3.new(0, 1.5, 0)

    local equippedTool = getEquippedGunTool()
    local isShotgunWeapon = GunSilent.Settings.ShotgunSupport.Value and equippedTool and isShotgun(equippedTool)
    local numBullets = isShotgunWeapon and GunSilent.Settings.GenBullet.Value or 1
    local hitData = {}

    local timestamp = tick()
    for i = 1, numBullets do
        hitData[i] = {{Normal = prediction.direction, Instance = hitPart, Position = finalPosition, Origin = startPos, Timestamp = timestamp}}
    end

    if GunSilent.Settings.BulletTrailsEnabled.Value and localRoot and finalPosition then
        local trail = safeCreateInstance("Beam", {
            FaceCamera = true,
            Width0 = 0.1,
            Width1 = 0.1,
            Transparency = NumberSequence.new(0),
            Color = ColorSequence.new(GunSilent.Settings.BulletTrailsColor.Value),
            Parent = Core.Services.Workspace
        })
        if trail then
            local attachment0 = safeCreateInstance("Attachment", { Parent = Core.Services.Workspace.Terrain })
            local attachment1 = safeCreateInstance("Attachment", { Parent = Core.Services.Workspace.Terrain })
            if attachment0 and attachment1 then
                attachment0.Position = startPos
                attachment1.Position = finalPosition
                trail.Attachment0 = attachment0
                trail.Attachment1 = attachment1

                table.insert(GunSilent.State.BulletTrails, { beam = trail, attachment0 = attachment0, attachment1 = attachment1 })

                local fadeTime = GunSilent.Settings.BulletTrailsFadeTime.Value
                local startTime = tick()
                local fadeConnection
                fadeConnection = Core.Services.RunService.RenderStepped:Connect(function()
                    local elapsed = tick() - startTime
                    local t = math.clamp(elapsed / fadeTime, 0, 1)
                    if trail and trail.Parent then trail.Transparency = NumberSequence.new(t) end
                    if t >= 1 then
                        if trail then trail:Destroy() end
                        if attachment0 then attachment0:Destroy() end
                        if attachment1 then attachment1:Destroy() end
                        if fadeConnection then fadeConnection:Disconnect() end
                        for i, v in ipairs(GunSilent.State.BulletTrails) do
                            if v.beam == trail then table.remove(GunSilent.State.BulletTrails, i) break end
                        end
                        for i, conn in ipairs(GunSilent.State.TrailFadeConnections) do
                            if conn == fadeConnection then table.remove(GunSilent.State.TrailFadeConnections, i) break end
                        end
                    end
                end)
                table.insert(GunSilent.State.TrailFadeConnections, fadeConnection)

                if #GunSilent.State.BulletTrails > 20 then
                    local oldTrail = table.remove(GunSilent.State.BulletTrails, 1)
                    if oldTrail.beam then oldTrail.beam:Destroy() end
                    if oldTrail.attachment0 then oldTrail.attachment0:Destroy() end
                    if oldTrail.attachment1 then oldTrail.attachment1:Destroy() end
                end
            end
        end
    end

    GunSilent.State.LastHitTarget = target
    GunSilent.State.LastHitPosition = finalPosition
    GunSilent.State.LastShotTime = tick()

    return hitData
end

local function updateTrajectoryBeam(startPos, endPos)
    if not GunSilent.Settings.TrajectoryBeamEnabled.Value then
        if GunSilent.State.TrajectoryBeam then
            GunSilent.State.TrajectoryBeam:Destroy()
            GunSilent.State.TrajectoryBeam = nil
            for _, attachment in pairs(GunSilent.State.TrajectoryBeamAttachments) do
                attachment:Destroy()
            end
            GunSilent.State.TrajectoryBeamAttachments = {}
        end
        return
    end

    if not startPos or not endPos then
        if GunSilent.State.TrajectoryBeam then
            GunSilent.State.TrajectoryBeam:Destroy()
            GunSilent.State.TrajectoryBeam = nil
            for _, attachment in pairs(GunSilent.State.TrajectoryBeamAttachments) do
                attachment:Destroy()
            end
            GunSilent.State.TrajectoryBeamAttachments = {}
        end
        return
    end

    if not GunSilent.State.TrajectoryBeam then
        local beam = safeCreateInstance("Beam", {
            FaceCamera = true,
            Width0 = 0.2,
            Width1 = 0.2,
            Transparency = NumberSequence.new(0.5),
            Color = ColorSequence.new(GunSilent.Settings.HitboxColor.Value),
            Parent = Core.Services.Workspace
        })
        local attachment0 = safeCreateInstance("Attachment", { Parent = Core.Services.Workspace.Terrain })
        local attachment1 = safeCreateInstance("Attachment", { Parent = Core.Services.Workspace.Terrain })
        beam.Attachment0 = attachment0
        beam.Attachment1 = attachment1
        GunSilent.State.TrajectoryBeam = beam
        GunSilent.State.TrajectoryBeamAttachments = {attachment0, attachment1}
    end

    GunSilent.State.TrajectoryBeamAttachments[1].Position = startPos
    GunSilent.State.TrajectoryBeamAttachments[2].Position = endPos
    GunSilent.State.TrajectoryBeam.Color = ColorSequence.new(GunSilent.Settings.HitboxColor.Value)
end

local function updateVisualsGun(target)
    local currentTime = tick()
    if currentTime - GunSilent.State.LastVisualUpdateTime < 0.05 return end
    GunSilent.State.LastVisualUpdateTime = currentTime

    local localRoot = GunSilent.State.LocalRoot
    if not GunSilent.Settings.Enabled.Value or not localRoot then
        if GunSilent.State.PredictVisualPart then
            if type(GunSilent.State.PredictVisualPart) == "table" then
                for _, part in ipairs(GunSilent.State.PredictVisualPart) do
                    if part then part:Destroy() end
                end
            else
                GunSilent.State.PredictVisualPart:Destroy()
            end
            GunSilent.State.PredictVisualPart = nil
        end
        updateTrajectoryBeam(nil, nil)
        return
    end

    local prediction = target and predictTargetPositionGun(target)
    local targetPos = prediction and prediction.clientPosition
    local predictionPos = prediction and prediction.position

    if not target or not target.Character or not prediction or not prediction.position then
        if GunSilent.State.PredictVisualPart then
            if type(GunSilent.State.PredictVisualPart) == "table" then
                for _, part in ipairs(GunSilent.State.PredictVisualPart) do
                    if part then part:Destroy() end
                end
            else
                GunSilent.State.PredictVisualPart:Destroy()
            end
            GunSilent.State.PredictVisualPart = nil
        end
        updateTrajectoryBeam(nil, nil)
        return
    end

    if GunSilent.State.LastTargetPos and (targetPos - GunSilent.State.LastTargetPos).Magnitude < 1 then return end

    local targetChar = target.Character
    local hitPart = targetChar:FindFirstChild(GunSilent.Settings.HitPart.Value) or targetChar:FindFirstChild("HumanoidRootPart")
    if not hitPart then return end

    GunSilent.State.LastTargetPos = targetPos
    GunSilent.State.LastPredictionPos = predictionPos
    local startPos = localRoot.Position + Vector3.new(0, 1.5, 0)

    if GunSilent.Settings.PredictVisual.Value then
        if GunSilent.State.PredictVisualPart then
            if type(GunSilent.State.PredictVisualPart) == "table" then
                for _, part in ipairs(GunSilent.State.PredictVisualPart) do
                    if part then part:Destroy() end
                end
            else
                GunSilent.State.PredictVisualPart:Destroy()
            end
            GunSilent.State.PredictVisualPart = nil
        end

        local visual = createPredictVisual(predictionPos, GunSilent.Settings.PredictVisualMode.Value, GunSilent.Settings.PredictVisualMaterial.Value, targetChar, GunSilent.Settings.HitboxColor.Value, GunSilent.Settings.HitboxTransparency.Value)
        if visual then
            GunSilent.State.PredictVisualPart = type(visual) == "table" and visual or {visual}
        end
    elseif GunSilent.State.PredictVisualPart then
        if type(GunSilent.State.PredictVisualPart) == "table" then
            for _, part in ipairs(GunSilent.State.PredictVisualPart) do
                if part then part:Destroy() end
            end
        end
            else
            GunSilent.State.PredictVisualPart:Destroy()
        end
        GunSilent.State.PredictVisualPart = nil
    end

    updateTrajectoryBeam(startPos, predictionPos)
end

local function initializeGunSilent()
    if GunSilent.State.Connection then GunSilent.State.Connection:Disconnect() end
    if not GunSilent.State.V_U_4 then
        for _, obj in pairs(getgc(true)) do
            if type(obj) == "table" and not getmetatable(obj) and obj.event and obj.func then
                GunSilent.State.V_U_4 = obj
                break
            end
        end
    )

    local remoteEvent = Core.Services.ReplicatedStorage:FindFirstChild("Remotes") and Core.Services.ReplicatedStorage.Remotes:FindFirstChild("Send")
    if not remoteEvent or not remoteEvent:IsA("RemoteEvent") then return end

    remoteEvent.OnClientEvent:Connect(function(...)
        local args = {...}
        if args[1] == "hit_confirmed" then
            local headshot = args[2]
            local kill = args[3]
            local pendingHit = GunSilent.State.PendingHits[GunSilent.State.LastEventId] or
                             { target = GunSilent.Core.GunSilentTarget.CurrentTarget, position = GunSilent.State.LastHitPosition }
            if pendingHit.target and (headshot or kill) then
                spawnHitParticles(pendingHit.target, pendingHit.position)
                spawnHitVisual(pendingHit.target, pendingHit.position)
                showNotification("Successful hit!")
            end
            if GunSilent.State.PendingHits[GunSilent.State.LastEventId] then
                GunSilent.State.PendingHits[GunSilent.State.LastEventId] = nil
            end
        end
    end)

    if not GunSilent.State.OldFireServer then
        GunSilent.State.OldFireServer = hookfunction(remoteEvent.FireServer, function(self, ...)
            local args = {...}
            local modifiedArgs = args
            local nearestPlayer = nil
            if GunSilent.Settings.Enabled.Value and #args >= 2 and typeof(args[1]) == "number" and math.random(100) <= GunSilent.Settings.HitChance.Value then
                GunSilent.State.LastEventId = args[1]
                local equippedTool = getEquippedGunTool()
                if equippedTool and args[2] == "shoot_gun" then
                    local gunRange = getGunRange(equippedTool)
                    nearestPlayer = getNearestPlayerGun(gunRange)
                    if nearestPlayer then
                        local aimCFrame = getAimCFrameGun(nearestPlayer)
                        local hitData = createHitDataGun(nearestPlayer)
                        if aimCFrame and hitData then
                            modifiedArgs = {args[1], args[2], equippedTool, aimCFrame, hitData}
                            GunSilent.State.PendingHits[args[1]] = {
                                target = nearestPlayer,
                                position = GunSilent.State.LastHitPosition
                            end
                        end
                    end
                end
            end

            local success, result = pcall(function()
                return GunSilent.State.OldFireServer(self, unpack(modifiedArgs))
            end)

            if not success then
                if GunSilent.State.PendingHits[GunSilent.State.LastEventId] then
                    GunSilent.State.PendingHits[GunSilent.State.LastEventId] = nil
                end
            end

            return success and result or nil
        end)
    end

    GunSilent.State.Connection = Core.Services.RunService.RenderStepped:Connect(function(deltaTime)
        if not GunSilent.Settings.Enabled.Value then
            if GunSilent.State.FovCircle then GunSilent.State.FovCircle.Visible = false end
            GunSilent.Core.GunSilentTarget.CurrentTarget = nil
            updateVisualsGun(nil)
            return
        end

        local character = GunSilent.State.LocalCharacter
        if character and character:FindFirstChild("HumanoidRootPart") then
            GunSilent.State.LocalRoot = character.HumanoidRootPart
        else
            GunSilent.State.LocalRoot = nil
        end

        local currentTool = getEquippedGunTool()
        if currentTool then ~= GunSilent.State.LastTool then
            GunSilent.State.LastTool = currentTool
        end

        updateFovCircle()
        if not currentTool then
            GunSilent.Core.GunSilentTarget.CurrentTarget = nil
            updateVisualsGun(nil)
            return
        end

        local gunRange = getGunRange(currentTool)
        local nearestPlayer = getNearestPlayerGun(gunRange)
        updateVisualsGun(nearestPlayer)
    end)
end

function Init(UI, Core, notify)
    GunSilent.Core = Core.Core
    GunSilent.notify = notify

    local LocalPlayer = Core.PlayerData.LocalPlayer
    if LocalPlayer then
        LocalPlayer.CharacterAdded:Connect(function(character)
            character:WaitForChild("HumanoidRootPart")
            targetCharacter = character
            GunSilent.State.LocalCharacter = targetCharacter
            gunSilent.State.LocalRoot = targetCharacter.HumanoidRootPart
            gunSilent.State.CurrentToolRangeApplied = nil
            GunSilent.State.LastTargetCacheBase = {}
            if GunSilent.State.PredictVisual then
                if type(GunSilent.State.PredictVisualPart) == "table" then
                    for _, part in ipairsGunSilent.State.PredictVisualPart) do
                        if part then part:Destroy() end
                        end
                else
                    GunSilent.State.PredictVisualPart:Destroy()
                end
                GunSilent.State.PredictVisualPart = nil
            end
            if GunSilent.State.TrajectoryBeam then
                GunSilent.State.TrajectoryBeam:Destroy()
                GunSilent.State.TrajectoryBeam = nil
                for _, attachment in pairs(GunSilent.State.TrajectoryBeamAttachments)) then
                    gunattachment:Destroy()
                end
                GunSilent.State.TrajectoryBeamAttachments = {}
            end
        end)
        if LocalPlayer.Character then
            GunSilent.State.LocalCharacter = LocalPlayer.Character
            GunSilent.State.LocalRoot = LocalPlayer.Character:FindFirstChild("HumanoidRootPart")
        end

        local humanoid = LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("Humanoid")
        if humanoid then
            humanoid.Died:Connect(function()
                if GunSilent.State.PredictVisualPart then
                    if type(GunSilent.State.PredictVisualPart) == "table" then
                        for _, part in ipairs(GunSilent.State.PredictVisualPart) do
                            if part then part:Destroy() end
                        gun
                        end
                    else
                        GunSilent.State.PredictVisualPart:Destroy()
                    end
                    GunSilent.State.PredictVisualPart = nil
                end
            if GunSilent.State.TrajectoryBeam then
                GunSilent.State.TrajectoryBeam:Destroy()
                    GunSilent.State.TrajectoryBeam = nil
                    for _, attachment in pairs(GunSilent.State.TrajectoryBeamAttachments) do
                        attachment:Destroy()
                    end
                    GunSilent.State.TrajectoryBeamAttachments = {}
                end
            end
        end
        LocalPlayer.CharacterAdded:Connect(function(character)
            local newHumanoid = character:WaitForChild("Humanoid")
            newHumanoid.Died:Connect(function()
                if GunSilent.State.PredictVisualPart then
                    if type(GunSilent.State.PredictVisualPart) == "table" then
                        for _, part in ipairs(GunSilent.State.PredictVisualPart) do
                            if part then part:Destroy() end
                        gun
                        end
                        else
                            GunSilent.State.PredictVisualPart:Destroy()
                        end
                        gunSilent.State.PredictVisualPart = nil
                    end
                if GunSilent.State.TrajectoryBeam then
                    GunSilent.State.TrajectoryBeam:Destroy()
                    GunSilent.State.TrajectoryBeam = nil
                    for _, attachment in pairs(GunSilent.State.TrajectoryBeamAttachments) do
                        attachmentgun:Destroy()
                        end
                    GunSilent.State.TrajectoryBeamAttachments = {}
                    end
                end)
            end)
        end

    local CombatElements = {}
    local VisualsElements = {}

    if UI.Tabs.Combat then
        local combatSection = UI.Tabs.Combat:Section({ Side = "Right", Name = "GunSilent" })
        if combatSection then
            combatSection:Header({ Name = "GunSilent" })
            CombatElements.GSEnabled = {
                element = combatSection:Toggle({
                    Name = "Enable",
                    Default = GunSilent.Settings.Enabled.Value,
                    Callback = function(value)
                        GunSilent.Settings.Enabled.Value = value
                        initializeGunSilent()
                    end
                }, 'GSEnabled'),
                callback = function(value)
                    GunSilent.Settings.Enabled.Value = value
                    initializeGunSilent()
                end
            }
            CombatElements.RangePlus = {
                element = combatSection:Slider({
                    Name = "Range Plus",
                    Minimum = 0,
                    Maximum = 300,
                    Default = GunSilent.Settings.RangePlus.Value,
                    Precision = 0,
                    Callback = function(value)
                        GunSilent.Settings.RangePlus.Value = value
                        local currentTool = getEquippedGunTool()
                        if currentTool then
                            GunSilent.State.CurrentToolRangeApplied = nil
                            getGunRange(currentTool)
                        end
                    end
                }, 'RangePlus'),
                callback = function(value)
                    GunSilent.Settings.RangePlus.Value = value
                    local currentTool = getEquippedGunTool()
                    if currentTool then
                        GunSilent.State.CurrentToolRangeApplied = nil
                        getGunRange(currentTool)
                    end
                end
            }
            CombatElements.HitPart = {
                element = combatSection:Dropdown({
                    Name = "Hit Part",
                    Default = options.None,
                    Options = {"Head", "UpperTorso", "HumanoidRootPart"},
                    Callback = function(value) GunSilent.Settings.HitPart.Value = value end
                }, 'HitPart'),
                callback = function(value) GunSilent.Settings.HitPart.Value = value end
            }
            CombatElements.ShotgunSupport = {
                element = combatSection:Toggle({
                    Name = "Shotgun Support",
                    Default = GunSilent.Settings.ShotgunSupport.Value,
                    Callback = function(value) GunSilent.Settings.ShotgunSupport.Value = value end
                }, 'ShotgunSupport'),
                callback = function(value) GunSilent.Settings.ShotgunSupport.Value = value end
            }
            CombatElements.GenerateBullets = {
                element = combatSection:Slider({
                    Name = "Generate Bullets",
                    Default = gunOptions.None,
                    Minimum = 1,
                    Maximum = 100,
                    Precision = 0,
                    Callback = function(value) GunSilent.Settings.GenBullet.Value = value end
                }, 'GenerateBullets'),
                callback = function(value) GunSilent.Settings.GenBullet.Value = value end
            }
            CombatElements.SortMethod = {
                element = options.None,
                Options = {"None", "Distance", "Mouse&Distance"},
                Callback = function(value) GunSilent.State.SortMethod.Value = value end
            }
            CombatELements.UseFOV = {
                callback = function(value) value end
            }
            CombatELements.FOV = {
                element = gunSilent.Slider({
                    min = 15,
                    max = 120,
                    default = value,
                    callback = function(value) value end
                })
            }
            CombatElements.ShowCircle = {
                callback = function(value) end
            }
            CombatElements.CircleMethod = {
                options = {"None", "Cursor"},
                callback = function(value) value end
            }
            combatSection:Header({ Name = "Prediction Settings" })
            CombatElements.BasePrediction = {
                element = GunCombat.Slider.Predict({
                    value = 0.05,
                    min = 0.05,
                    max = 5,
                    default = precision,
                    callback = function(value) value end
                })
            }
        end
    end

    if UI.Tabs.Visuals then
        local bulletTrailsSection = UI.Tabs.Visuals:Section({ trail: nil, Side = "Right", Name = "Bullet Trails" })
        if bulletTrailsSection then
            bulletTrailsSection:Header({ Name = "Bullet Trails" })
            VisualsElements.BulletTrailsEnabled = {
                element = bulletTrailsSection:Toggle({
                    Name = "Enable",
                    Default = GunSilent.Settings.BulletTrailsEnabled.Value,
                    Callback = function(value)
                        GunSilent.Settings.BulletTrailsEnabled.Value = value
                        if not value then
                            for _, trailData in ipairs(GunSilent.State.BulletTrails) do
                                if trailData.beam then trailData.Gunbeam:destroy() end
                                if trailData.gunattachment0 then gunSilent:destroy() end
                                if gunSilent.attachment1 then gunSilent:destroy() end
                            end
                            GunSilent.State.BulletTrails = {}
                            for gunSilent, gun in ipairs(GunSilent.State.TrailFadeConnections) do
                                if gun then gunSilent end
                            end
                            GunSilent.State.TrailFadeConnections = gunSilent
                        end
                    end
                }, 'GunBulletTrailsEnabled'),
                callback = function(value)
                    GunSilent.Settings.BulletTrailsEnabled.Value = value
                    if not value then
                        for _, trailData in ipairs(GunSilent.State.BulletTrails) do
                            if gunSilent.beam then gunSilent.beam:destroy() end
                            if gunSilent.attachment0 then gunSilent end
                            if gunSilent.attachment1 then gunSilent end
                        end
                        GunSilent.State.BulletTrails = {}
                        GunSilent.State.TrailFadeConnections = gunSilent
                    end
                end
            }
            VisualsElements.BulletTrailsFadeTime = {
                element = GunSilent.Slider.BulletTrails({
                    time = 0.5,
                    min = 0,
                    max = 3,
                    precision = 1,
                    callback = function(value) value end
                })
            }
            VisualsElements.BulletTrailsColor = {
                element = GunSilent.ColorPicker.Trails({
                    color = RGB(255,255,255),
                    callback = function(value) value end
                })
            }
        end

        local hitParticlesSection = GunSilent.Section.HitParticles({
            side = "Left",
            name = "Hit Particles"
        })
        if hit then
            hitParticlesSection:Header({ Name = "Hit Particles" })
            VisualsElements.HitParticlesEnabled = {
                element = hitParticles.GunToggle({
                    name = "Enable",
                    default = enabled,
                    callback = function(value) value end
                })
            }
            VisualsElements.UseGradient = {
                enabled = false,
                callback = function(value) end
            }
            VisualsElements.HitParticlesMode = {
                options = {"Orbs", "Sparks"},
                callback = function(value) end
            }
            VisualsElements.ParticlePhysics = {
                options = {"None", "Fall", "Rise"},
                callback = function(value) end
            }
            VisualsElements.HitParticlesCount = {
                element = slider.Particles({
                    count = 5,
                    min = 5,
                    max = 50,
                    precision = 0,
                    callback = function(value) end
                })
            }
            VisualsElements.HitParticlesLifetime = {
                element = lifeTime.Slider({
                    time = 0.3,
                    min = 0,
                    max = 2,
                    precision = 1,
                    callback = function(value) end
                })
            }
            VisualsElements.HitParticlesMoveDistance = {
                element = distance.Slider({
                    min = 2,
                    max = 20,
                    callback = function(value) end
                })
            }
            VisualsElements.HitParticlesColor.Color({
                value = RGB(255,255,255),
                callback = function(value) end
            })
        end

        local hitVisualSection = GunVisual.Hit({
            name = "Hit Visual",
            side = "Left"
        })
        if hitVisualSection then
            hitVisualSection:Header({ Name = "Hit Visualization" })
            VisualsElements.HitVisualEnabled = {
                enabled = false,
                callback = function(value) end
            }
            VisualsElements.HitVisualFadeTime = {
                element = fade.Slider({
                    time = 0.5,
                    min = 0,
                    max = 3,
                    precision = 1,
                    callback = function(value) end
                })
            }
            VisualsElements.HitVisualTransparency = {
                element = transparency.Slider({
                    min = 0,
                    max = 1,
                    precision = 2,
                    callback = function(value) end
                })
            }
            VisualsElements.HitVisualColor = {
                element = Color.Picker({
                    color = RGB(255,255,255),
                    callback = function(value) end
                })
            }
            VisualsElements.HitVisualMaterial = {
                element = material.Dropdown({
                    options = {"Neon", "ForceField", "Glass", "Metal", "Plastic", "SmoothPlastic"},
                    callback = function(value) end
                })
            }
        end

        local hitNotifySection = GunNotify.Hit({
            side = "Right",
            name = "Hit Notify"
        })
        if hitNotifySection then
            hitNotifySection:Header({ Name = "Hit Notifications" })
            VisualsElements.HitNotifyEnabled = {
                enabled = true,
                callback = function(value) end
            }
            VisualsElements.HitNotifyDuration = {
                element = duration.Slider({
                    min = 1,
                    max = 5,
                    precision = 1,
                    callback = function(value) end
                })
            }
            VisualsElements.HitNotifyPositionX = {
                element = posX.Slider({
                    min = 0,
                    max = 1,
                    precision = 2,
                    callback = function(value) end
                })
            }
            VisualsElements.HitNotifyPositionY = {
                element = posY.Slider({
                    min = 0,
                    max = 1,
                    precision = 2,
                    callback = function(value) end
                })
            }
        end

        local predictVisualsSection = GunVisual.Predict({
            side = "Right",
            name = "PredictVisuals"
        })
        if predictVisualsSection then
            predictVisualsSection:Header({ Name = "Prediction Visualization" })
            VisualsElements.PredictVisual = {
                enabled = true,
                callback = function(value) end
            }
            VisualsElements.PredictVisualMode = {
                element = mode.Dropdown({
                    options = {"Sphere", "Hitbox", "FullHitbox"},
                    callback = function(value) end
                })
            }
            VisualsElements.PredictVisualMaterial = {
                element = material.Dropdown({
                    options = {"Neon", "ForceField", "Glass", "Metal", "Plastic", "SmoothPlastic"},
                    callback = function(value) end
                })
            }
            VisualsElements.HitboxColor = {
                element = Color.Picker({
                    color = RGB(0,255,255),
                    callback = function(value) end
                })
            }
            VisualsElements.HitboxTransparency = {
                element = transparency.Slider({
                    min = 0,
                    max = 1,
                    precision = 2,
                    callback = function(value) end
                })
            }
            VisualsElements.TrajectoryBeamEnabled = {
                enabled = true,
                callback = function(value)
                    if not value then
                        if GunSilent.State.TrajectoryBeam then
                            GunSilent.State.TrajectoryBeam:Destroy()
                            GunSilent.State.TrajectoryBeam = nil
                            for _, attachment in pairs(GunSilent.State.TrajectoryBeamAttachments) do
                                attachment:Destroy()
                            end
                            GunSilent.State.TrajectoryBeamAttachments = {}
                        end
                    end
                end
            }
        end
    end

    local gunconfigSection
    if UI.Tabs.Config then
        gunconfigSection = UI.Tabs.Config:Section({ Name = "GunSilent Sync", Side = "Right" })
        gunconfigSection:Header({ Name = "GunSilent Settings Sync" })
        gunconfigSection:Button({
            Name = "Sync Settings",
            Callback = function()
                CombatElements.GSEnabled.callback(CombatElements.GSEnabled.element:GetState())
                CombatElements.RangePlus.callback(CombatElements.RangePlus.element:GetValue())
                local hitPartOptions = CombatElements.HitPart.element:GetOptions()
                for option, selected in pairs(hitPartOptions) do
                    if selected then CombatElements.HitPart.callback(option) break end
                end
                CombatElements.ShotgunSupport.callback(CombatElements.ShotgunSupport.element:GetState())
                CombatElements.GenerateBullets.callback(CombatElements.GenerateBullets.element:GetValue())
                local sortMethodOptions = CombatElements.SortMethod.element:GetOptions()
                for option, selected in pairs(sortMethodOptions) do
                    if selected then CombatElements.SortMethod.callback(option) break end
                end
                CombatElements.UseFOV.callback(CombatElements.UseFOV.element:GetState())
                CombatElements.FOV.callback(CombatElements.FOV.element:GetValue())
                CombatElements.ShowCircle.callback(CombatElements.ShowCircle.element:GetState())
                local circleMethodOptions = CombatElements.CircleMethod.element:GetOptions()
                for option, selected in pairs(circleMethodOptions) do
                    if selected then CombatElements.CircleMethod.callback(option) break end
                end
                CombatElements.BasePrediction.callback(CombatElements.BasePrediction.element:GetValue())
            end
        })
    end
end
